!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACF_DISABLED	ssl_verify.c	728;"	d	file:
ACF_FAILED	ssl_verify.c	729;"	d	file:
ACF_SUCCEEDED	ssl_verify.c	727;"	d	file:
ACF_UNDEFINED	ssl_verify.c	726;"	d	file:
ACK_SIZE	reliable.c	191;"	d	file:
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/missing aclocal-1.14$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
AC_MIN_BYTES	lzo.h	127;"	d
AC_OFF_SEC	lzo.h	133;"	d
AC_SAMP_SEC	lzo.h	126;"	d
AC_SAVE_PCT	lzo.h	130;"	d
ADD_CHECKSUM_32	proto.h	200;"	d
ADJUST_CHECKSUM	proto.h	185;"	d
ADVANCE	route.c	2634;"	d	file:
ADVANCE	route.c	2733;"	d	file:
ADVANCE	route.c	2955;"	d	file:
AF_DID_PUSH	manage.c	288;"	d	file:
AF_DID_RESET	manage.c	289;"	d	file:
ALLOC_ARRAY	buffer.h	836;"	d
ALLOC_ARRAY_CLEAR	buffer.h	846;"	d
ALLOC_ARRAY_CLEAR_GC	buffer.h	852;"	d
ALLOC_ARRAY_GC	buffer.h	841;"	d
ALLOC_OBJ	buffer.h	825;"	d
ALLOC_OBJ_CLEAR	buffer.h	830;"	d
ALLOC_OBJ_CLEAR_GC	buffer.h	867;"	d
ALLOC_OBJ_GC	buffer.h	862;"	d
ALLOC_VAR_ARRAY_CLEAR_GC	buffer.h	857;"	d
ALLOW_NON_CBC_CIPHERS	crypto.h	35;"	d
AMTAR	Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AM_CFLAGS	Makefile	/^AM_CFLAGS = $(TAP_CFLAGS) $(OPTIONAL_CRYPTO_CFLAGS) \\$/;"	m
AM_DEFAULT_VERBOSITY	Makefile	/^AM_DEFAULT_VERBOSITY = 1$/;"	m
AM_V_CC	Makefile	/^AM_V_CC = $(am__v_CC_$(V))$/;"	m
AM_V_CCLD	Makefile	/^AM_V_CCLD = $(am__v_CCLD_$(V))$/;"	m
AM_V_GEN	Makefile	/^AM_V_GEN = $(am__v_GEN_$(V))$/;"	m
AM_V_P	Makefile	/^AM_V_P = $(am__v_P_$(V))$/;"	m
AM_V_at	Makefile	/^AM_V_at = $(am__v_at_$(V))$/;"	m
AM_V_lt	Makefile	/^AM_V_lt = $(am__v_lt_$(V))$/;"	m
ANY_OUT	forward.h	41;"	d
APA_CAT	misc.h	343;"	d
AR	Makefile	/^AR = arm-none-linux-gnueabi-ar$/;"	m
ARP_MAC_ADDR_TYPE	proto.h	68;"	d
ARP_REPLY	proto.h	76;"	d
ARP_REQUEST	proto.h	75;"	d
AR_INTERACT	options.h	757;"	d
AR_NOINTERACT	options.h	758;"	d
AR_NONE	options.h	756;"	d
AS	Makefile	/^AS = as$/;"	m
ASSERT	error.h	214;"	d
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/missing autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/missing autoheader$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/missing automake-1.14$/;"	m
AUTO_USERID	syshead.h	698;"	d
AUTO_USERID	syshead.h	700;"	d
AWK	Makefile	/^AWK = mawk$/;"	m
BASE_N_EVENTS	init.h	34;"	d
BASIC_H	basic.h	26;"	d
BCAP	buffer.h	118;"	d
BDEF	buffer.h	116;"	d
BEND	buffer.h	113;"	d
BIG_TIMEOUT	common.h	51;"	d
BLAST	buffer.h	114;"	d
BLEN	buffer.h	115;"	d
BOOL_CAST	basic.h	28;"	d
BOOTPC_PORT	dhcp.h	52;"	d
BOOTPS_PORT	dhcp.h	51;"	d
BOOTREPLY	dhcp.h	56;"	d
BOOTREQUEST	dhcp.h	55;"	d
BPTR	buffer.h	112;"	d
BSTR	buffer.h	117;"	d
BUFFER_H	buffer.h	26;"	d
BUF_INIT_TRACKING	buffer.h	43;"	d
BUF_SIZE	mtu.h	192;"	d
BUF_SIZE_MAX	buffer.h	31;"	d
CAPI_DATA	cryptoapi.c	/^} CAPI_DATA;$/;"	t	typeref:struct:_CAPI_DATA	file:
CAS_FAILED	openvpn.h	466;"	d
CAS_PARTIAL	openvpn.h	467;"	d
CAS_PENDING	openvpn.h	465;"	d
CAS_SUCCEEDED	openvpn.h	464;"	d
CC	Makefile	/^CC = arm-none-linux-gnueabi-gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCD_DEFAULT	common.h	74;"	d
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CC_ALNUM	buffer.h	711;"	d
CC_ALPHA	buffer.h	712;"	d
CC_ANY	buffer.h	708;"	d
CC_ASCII	buffer.h	713;"	d
CC_ASTERISK	buffer.h	741;"	d
CC_AT	buffer.h	735;"	d
CC_BACKSLASH	buffer.h	725;"	d
CC_BLANK	buffer.h	721;"	d
CC_CNTRL	buffer.h	714;"	d
CC_COLON	buffer.h	730;"	d
CC_COMMA	buffer.h	729;"	d
CC_CR	buffer.h	723;"	d
CC_CRLF	buffer.h	745;"	d
CC_DASH	buffer.h	727;"	d
CC_DIGIT	buffer.h	715;"	d
CC_DOT	buffer.h	728;"	d
CC_DOUBLE_QUOTE	buffer.h	733;"	d
CC_EQUAL	buffer.h	736;"	d
CC_EXCLUDE	buffer.c	895;"	d	file:
CC_GC_FREE	init.h	95;"	d
CC_GREATER_THAN	buffer.h	738;"	d
CC_HARD_USR1_TO_HUP	init.h	97;"	d
CC_INCLUDE	buffer.c	894;"	d	file:
CC_LESS_THAN	buffer.h	737;"	d
CC_NAME	buffer.h	744;"	d
CC_NEWLINE	buffer.h	722;"	d
CC_NO_CLOSE	init.h	98;"	d
CC_NULL	buffer.h	709;"	d
CC_PIPE	buffer.h	739;"	d
CC_PRINT	buffer.h	716;"	d
CC_PUNCT	buffer.h	717;"	d
CC_QUESTION_MARK	buffer.h	740;"	d
CC_REPLACE	buffer.c	896;"	d	file:
CC_REVERSE_QUOTE	buffer.h	734;"	d
CC_SINGLE_QUOTE	buffer.h	732;"	d
CC_SLASH	buffer.h	731;"	d
CC_SPACE	buffer.h	718;"	d
CC_UNDERBAR	buffer.h	726;"	d
CC_USR1_TO_HUP	init.h	96;"	d
CC_XDIGIT	buffer.h	719;"	d
CERT_STORE_OPEN_EXISTING_FLAG	cryptoapi.c	65;"	d	file:
CERT_STORE_READONLY_FLAG	cryptoapi.c	62;"	d	file:
CERT_SYSTEM_STORE_CURRENT_USER	cryptoapi.c	59;"	d	file:
CERT_SYSTEM_STORE_CURRENT_USER_ID	cryptoapi.c	56;"	d	file:
CERT_SYSTEM_STORE_LOCATION_SHIFT	cryptoapi.c	53;"	d	file:
CE_DISABLED	options.h	131;"	d
CE_MAN_QUERY_PROXY	options.h	132;"	d
CE_MAN_QUERY_REMOTE_ACCEPT	options.h	135;"	d
CE_MAN_QUERY_REMOTE_MASK	options.h	138;"	d
CE_MAN_QUERY_REMOTE_MOD	options.h	136;"	d
CE_MAN_QUERY_REMOTE_QUERY	options.h	134;"	d
CE_MAN_QUERY_REMOTE_SHIFT	options.h	139;"	d
CE_MAN_QUERY_REMOTE_SKIP	options.h	137;"	d
CE_MAN_QUERY_REMOTE_UNDEF	options.h	133;"	d
CFLAGS	Makefile	/^CFLAGS = -g -O2$/;"	m
CF_INIT_TLS_AUTH_STANDALONE	init.c	58;"	d	file:
CF_INIT_TLS_MULTI	init.c	57;"	d	file:
CF_LOAD_PERSISTED_PACKET_ID	init.c	56;"	d	file:
CHKACC_ACPTSTDIN	options.c	2558;"	d	file:
CHKACC_DIRPATH	options.c	2555;"	d	file:
CHKACC_FILE	options.c	2554;"	d	file:
CHKACC_FILEXSTWR	options.c	2556;"	d	file:
CHKACC_INLINE	options.c	2557;"	d	file:
CIPHER_ENABLED	openvpn.h	590;"	d
CIPHER_ENABLED	openvpn.h	592;"	d
CIRC_LIST	circ_list.h	32;"	d
CIRC_LIST_ALLOC	circ_list.h	65;"	d
CIRC_LIST_FREE	circ_list.h	75;"	d
CIRC_LIST_H	circ_list.h	26;"	d
CIRC_LIST_INDEX	circ_list.h	51;"	d
CIRC_LIST_ITEM	circ_list.h	56;"	d
CIRC_LIST_PUSH	circ_list.h	41;"	d
CIRC_LIST_RESET	circ_list.h	59;"	d
CIRC_LIST_SIZE	circ_list.h	48;"	d
CLEAR	basic.h	34;"	d
CLINAT_H	clinat.h	26;"	d
CM_CHILD_TCP	openvpn.h	522;"	d
CM_CHILD_UDP	openvpn.h	521;"	d
CM_P2P	openvpn.h	518;"	d
CM_TOP	openvpn.h	519;"	d
CM_TOP_CLONE	openvpn.h	520;"	d
CN_DNAT	clinat.h	37;"	d
CN_INCOMING	clinat.h	33;"	d
CN_OUTGOING	clinat.h	32;"	d
CN_SNAT	clinat.h	36;"	d
COMMAND_EXIT	ps.c	50;"	d	file:
COMMAND_REDIRECT	ps.c	49;"	d	file:
COMMON_H	common.h	26;"	d
COMMON_NAME_CHAR_CLASS	ssl_verify.c	56;"	d	file:
COMPAT_FLAG_QUERY	misc.h	366;"	d
COMPAT_FLAG_SET	misc.h	367;"	d
COMPAT_NAMES	misc.h	368;"	d
COMPAT_NO_NAME_REMAPPING	misc.h	369;"	d
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
COMPRESS_THRESHOLD	lzo.h	105;"	d
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONNECTION_ESTABLISHED	forward-inline.h	292;"	d
CONNECTION_LIST_SIZE	options.h	150;"	d
CONNECT_NONBLOCK	syshead.h	691;"	d
CONSOLE_H	console.h	26;"	d
CONTROL_SEND_ACK_MAX	ssl.h	84;"	d
CO_IGNORE_PACKET_ID	crypto.h	155;"	d
CO_MUTE_REPLAY_WARNINGS	crypto.h	161;"	d
CO_PACKET_ID_LONG_FORM	crypto.h	148;"	d
CO_USE_IV	crypto.h	151;"	d
CPP	Makefile	/^CPP = arm-none-linux-gnueabi-gcc -E$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CRYPTOAPI_F_CERT_FIND_CERTIFICATE_IN_STORE	cryptoapi.c	75;"	d	file:
CRYPTOAPI_F_CERT_OPEN_SYSTEM_STORE	cryptoapi.c	74;"	d	file:
CRYPTOAPI_F_CRYPT_ACQUIRE_CERTIFICATE_PRIVATE_KEY	cryptoapi.c	76;"	d	file:
CRYPTOAPI_F_CRYPT_CREATE_HASH	cryptoapi.c	77;"	d	file:
CRYPTOAPI_F_CRYPT_GET_HASH_PARAM	cryptoapi.c	78;"	d	file:
CRYPTOAPI_F_CRYPT_SET_HASH_PARAM	cryptoapi.c	79;"	d	file:
CRYPTOAPI_F_CRYPT_SIGN_HASH	cryptoapi.c	80;"	d	file:
CRYPTOAPI_F_GET_PROC_ADDRESS	cryptoapi.c	82;"	d	file:
CRYPTOAPI_F_LOAD_LIBRARY	cryptoapi.c	81;"	d	file:
CRYPTOAPI_str_functs	cryptoapi.c	/^static ERR_STRING_DATA CRYPTOAPI_str_functs[] =	{$/;"	v	file:
CRYPTOAPIerr	cryptoapi.c	73;"	d	file:
CRYPTO_BACKEND_H_	crypto_backend.h	31;"	d
CRYPTO_H	crypto.h	31;"	d
CRYPTO_OPENSSL_H_	crypto_openssl.h	31;"	d
CRYPTO_POLARSSL_H_	crypto_polarssl.h	31;"	d
CRYPT_ERROR	crypto.c	65;"	d	file:
CR_ECHO	misc.h	219;"	d
CR_RESPONSE	misc.h	220;"	d
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
CvtHex	httpdigest.c	/^CvtHex($/;"	f	file:
DAF_CONNECTION_CLOSED	manage.h	49;"	d
DAF_CONNECTION_ESTABLISHED	manage.h	48;"	d
DAF_INITIAL_AUTH	manage.h	50;"	d
DEBUG_LEVEL_USEC_TIME	errlevel.h	34;"	d
DECODE_ERROR	base64.c	105;"	d	file:
DECODE_MUTE_LEVEL	error.h	124;"	d
DECRYPT_KEY_ENABLED	ssl_verify.h	93;"	d
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFAULT_SEQ_BACKTRACK	packet_id.h	107;"	d
DEFAULT_TIME_BACKTRACK	packet_id.h	116;"	d
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DES_KEY_LENGTH	crypto_openssl.h	70;"	d
DES_KEY_LENGTH	crypto_polarssl.h	73;"	d
DES_cblock	crypto_openssl.c	73;"	d	file:
DES_check_key_parity	crypto_openssl.c	75;"	d	file:
DES_is_weak_key	crypto_openssl.c	74;"	d	file:
DES_set_odd_parity	crypto_openssl.c	76;"	d	file:
DEV_TYPE_NULL	proto.h	37;"	d
DEV_TYPE_TAP	proto.h	39;"	d
DEV_TYPE_TUN	proto.h	38;"	d
DEV_TYPE_UNDEF	proto.h	36;"	d
DHCPACK	dhcp.h	45;"	d
DHCPDECLINE	dhcp.h	44;"	d
DHCPDISCOVER	dhcp.h	41;"	d
DHCPINFORM	dhcp.h	48;"	d
DHCPNAK	dhcp.h	46;"	d
DHCPOFFER	dhcp.h	42;"	d
DHCPRELEASE	dhcp.h	47;"	d
DHCPREQUEST	dhcp.h	43;"	d
DHCP_END	dhcp.h	38;"	d
DHCP_H	dhcp.h	26;"	d
DHCP_MSG_TYPE	dhcp.h	37;"	d
DHCP_OPTIONS_BUFFER_SIZE	dhcp.h	79;"	d
DHCP_PAD	dhcp.h	35;"	d
DHCP_ROUTER	dhcp.h	36;"	d
DHCP_STATUS_DISABLED	tun.c	3782;"	d	file:
DHCP_STATUS_ENABLED	tun.c	3781;"	d	file:
DHCP_STATUS_UNDEF	tun.c	3780;"	d	file:
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = $(top_srcdir)\/build\/ltrc.inc $(srcdir)\/Makefile.in \\$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(am__openvpn_SOURCES_DIST)$/;"	m
DLLTOOL	Makefile	/^DLLTOOL = false$/;"	m
DL_LIBS	Makefile	/^DL_LIBS = -ldl$/;"	m
DSYMUTIL	Makefile	/^DSYMUTIL = $/;"	m
DUMPBIN	Makefile	/^DUMPBIN = $/;"	m
DUP_CN	pool.c	511;"	d	file:
D_ALIGN_DEBUG	errlevel.h	140;"	d
D_ALIGN_ERRORS	errlevel.h	71;"	d
D_ARGV	errlevel.h	76;"	d
D_ARGV_PARSE_CMD	errlevel.h	146;"	d
D_AUTH	errlevel.h	86;"	d
D_AUTO_USERID	errlevel.h	144;"	d
D_CLIENT_NAT	errlevel.h	117;"	d
D_CLOSE	errlevel.h	74;"	d
D_COMP	errlevel.h	162;"	d
D_COMP_ERRORS	errlevel.h	62;"	d
D_COMP_LOW	errlevel.h	127;"	d
D_CONNECTION_LIST	errlevel.h	128;"	d
D_CRYPTO_DEBUG	errlevel.h	147;"	d
D_CRYPT_ERRORS	errlevel.h	59;"	d
D_DHCP_OPT	errlevel.h	99;"	d
D_EVENT_ERRORS	errlevel.h	67;"	d
D_EVENT_WAIT	errlevel.h	158;"	d
D_FRAG_DEBUG	errlevel.h	122;"	d
D_FRAG_ERRORS	errlevel.h	70;"	d
D_GENKEY	errlevel.h	80;"	d
D_GREMLIN	errlevel.h	79;"	d
D_GREMLIN_VERBOSE	errlevel.h	156;"	d
D_HANDSHAKE	errlevel.h	73;"	d
D_HANDSHAKE_VERBOSE	errlevel.h	152;"	d
D_IFCONFIG_POOL	errlevel.h	85;"	d
D_IMPORT_ERRORS	errlevel.h	65;"	d
D_INIT_MEDIUM	errlevel.h	106;"	d
D_INTERVAL	errlevel.h	154;"	d
D_LINK_ERRORS	errlevel.h	58;"	d
D_LINK_RW	errlevel.h	114;"	d
D_LINK_RW_VERBOSE	errlevel.h	167;"	d
D_LOG_RW	errlevel.h	112;"	d
D_LOW	errlevel.h	98;"	d
D_MANAGEMENT	errlevel.h	89;"	d
D_MANAGEMENT_DEBUG	errlevel.h	136;"	d
D_MBUF	errlevel.h	100;"	d
D_MSS	errlevel.h	126;"	d
D_MTU_DEBUG	errlevel.h	124;"	d
D_MTU_INFO	errlevel.h	107;"	d
D_MULTI_DEBUG	errlevel.h	125;"	d
D_MULTI_DROPPED	errlevel.h	103;"	d
D_MULTI_ERRORS	errlevel.h	66;"	d
D_MULTI_LOW	errlevel.h	87;"	d
D_MULTI_MEDIUM	errlevel.h	104;"	d
D_MULTI_TCP	errlevel.h	159;"	d
D_OPENSSL_LOCK	errlevel.h	175;"	d
D_OSBUF	errlevel.h	92;"	d
D_PACKET_CONTENT	errlevel.h	164;"	d
D_PACKET_TRUNC_DEBUG	errlevel.h	141;"	d
D_PACKET_TRUNC_ERR	errlevel.h	101;"	d
D_PF_DEBUG	errlevel.h	150;"	d
D_PF_DROPPED	errlevel.h	102;"	d
D_PF_DROPPED_BCAST	errlevel.h	149;"	d
D_PF_INFO	errlevel.h	94;"	d
D_PID_DEBUG	errlevel.h	148;"	d
D_PID_DEBUG_LOW	errlevel.h	109;"	d
D_PID_DEBUG_MEDIUM	errlevel.h	110;"	d
D_PID_PERSIST	errlevel.h	69;"	d
D_PID_PERSIST_DEBUG	errlevel.h	166;"	d
D_PING	errlevel.h	142;"	d
D_PKCS11_DEBUG	errlevel.h	170;"	d
D_PLUGIN	errlevel.h	88;"	d
D_PLUGIN_DEBUG	errlevel.h	137;"	d
D_PROXY	errlevel.h	75;"	d
D_PS_PROXY	errlevel.h	93;"	d
D_PS_PROXY_DEBUG	errlevel.h	143;"	d
D_PUSH	errlevel.h	84;"	d
D_PUSH_ERRORS	errlevel.h	68;"	d
D_READ_WRITE	errlevel.h	163;"	d
D_REGISTRY	errlevel.h	174;"	d
D_REL_DEBUG	errlevel.h	157;"	d
D_REL_LOW	errlevel.h	121;"	d
D_REPLAY_ERRORS	errlevel.h	63;"	d
D_RESOLVE_ERRORS	errlevel.h	61;"	d
D_RESTART	errlevel.h	83;"	d
D_ROUTE	errlevel.h	81;"	d
D_ROUTE_DEBUG	errlevel.h	131;"	d
D_ROUTE_QUOTA	errlevel.h	91;"	d
D_SCHEDULER	errlevel.h	155;"	d
D_SCHED_EXIT	errlevel.h	90;"	d
D_SCRIPT	errlevel.h	129;"	d
D_SEMAPHORE	errlevel.h	134;"	d
D_SEMAPHORE_LOW	errlevel.h	133;"	d
D_SHAPER_DEBUG	errlevel.h	172;"	d
D_SHOW_KEYS	errlevel.h	119;"	d
D_SHOW_KEY_SOURCE	errlevel.h	120;"	d
D_SHOW_NET	errlevel.h	130;"	d
D_SHOW_OCC	errlevel.h	97;"	d
D_SHOW_OCC_HASH	errlevel.h	108;"	d
D_SHOW_PARMS	errlevel.h	96;"	d
D_SHOW_PKCS11	errlevel.h	139;"	d
D_SOCKET_DEBUG	errlevel.h	138;"	d
D_STREAM_DEBUG	errlevel.h	168;"	d
D_STREAM_ERRORS	errlevel.h	64;"	d
D_TAP_WIN_DEBUG	errlevel.h	116;"	d
D_TEST_FILE	errlevel.h	135;"	d
D_TLS_DEBUG	errlevel.h	161;"	d
D_TLS_DEBUG_LOW	errlevel.h	78;"	d
D_TLS_DEBUG_MED	errlevel.h	153;"	d
D_TLS_ERRORS	errlevel.h	60;"	d
D_TLS_KEYSELECT	errlevel.h	145;"	d
D_TLS_NO_SEND_KEY	errlevel.h	165;"	d
D_TLS_STATE_ERRORS	errlevel.h	132;"	d
D_TUNTAP_INFO	errlevel.h	82;"	d
D_TUN_RW	errlevel.h	115;"	d
D_WIN32_IO	errlevel.h	169;"	d
D_WIN32_IO_LOW	errlevel.h	123;"	d
D_X509_ATTR	errlevel.h	105;"	d
DigestCalcHA1	httpdigest.c	/^DigestCalcHA1($/;"	f
DigestCalcResponse	httpdigest.c	/^DigestCalcResponse($/;"	f
ECHO_C	Makefile	/^ECHO_C = $/;"	m
ECHO_N	Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
EGREP	Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EKS_INPUT	manage.h	280;"	d
EKS_READY	manage.h	281;"	d
EKS_SOLICIT	manage.h	279;"	d
EKS_UNDEF	manage.h	278;"	d
EMPTY_ARRAY_SIZE	syshead.h	377;"	d
EMPTY_ARRAY_SIZE	syshead.h	378;"	d
ENABLE_BUFFER_LIST	syshead.h	591;"	d
ENABLE_CLIENT_CR	syshead.h	707;"	d
ENABLE_CLIENT_NAT	syshead.h	720;"	d
ENABLE_CRYPTOAPI	syshead.h	629;"	d
ENABLE_DEF_AUTH	syshead.h	543;"	d
ENABLE_FEATURE_EXECVE	syshead.h	505;"	d
ENABLE_FEATURE_SHAPER	syshead.h	684;"	d
ENABLE_IP_PKTINFO	syshead.h	422;"	d
ENABLE_IP_PKTINFO	syshead.h	424;"	d
ENABLE_MEMSTATS	syshead.h	726;"	d
ENABLE_OCC	syshead.h	597;"	d
ENABLE_PF	syshead.h	576;"	d
ENABLE_PREDICTION_RESISTANCE	syshead.h	555;"	d
ENABLE_PUSH_PEER_INFO	syshead.h	714;"	d
ENABLE_X509_TRACK	syshead.h	636;"	d
ENCODE_MUTE_LEVEL	error.h	123;"	d
EPOLL	syshead.h	652;"	d
EPOLL	syshead.h	654;"	d
ERRLEVEL_H	errlevel.h	26;"	d
ERROR_H	error.h	26;"	d
ERR_BUF_SIZE	error.h	33;"	d
ERR_BUF_SIZE	error.h	35;"	d
ERR_LIB_CRYPTOAPI	cryptoapi.c	72;"	d	file:
ERR_MAP_SZ	cryptoapi.c	136;"	d	file:
ES_ERROR	openvpn.h	245;"	d
ES_TIMEOUT	openvpn.h	246;"	d
ETAGS	Makefile	/^ETAGS = etags$/;"	m
ETHERNET_MTU	mtu.h	55;"	d
ETT_DEFAULT	interval.h	199;"	d
EVENT_H	event.h	26;"	d
EVENT_LOOP_CHECK_SIGNAL	openvpn.h	554;"	d
EVENT_METHOD_FAST	event.h	43;"	d
EVENT_METHOD_US_TIMEOUT	event.h	42;"	d
EVENT_READ	event.h	37;"	d
EVENT_UNDEF	event.h	36;"	d
EVENT_WRITE	event.h	38;"	d
EVP_CIPHER_mode	crypto_openssl.c	70;"	d	file:
EVP_CIPHER_mode	crypto_openssl.c	71;"	d	file:
EVP_CIPHER_name	crypto_openssl.c	106;"	d	file:
EVP_CipherInit_ov	crypto_openssl.c	/^EVP_CipherInit_ov (EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, uint8_t *key, uint8_t *iv, int enc)$/;"	f	file:
EVP_CipherUpdate_ov	crypto_openssl.c	/^EVP_CipherUpdate_ov (EVP_CIPHER_CTX *ctx, uint8_t *out, int *outl, uint8_t *in, int inl)$/;"	f	file:
EVP_MD_CTX_cleanup	crypto_openssl.c	81;"	d	file:
EVP_MD_name	crypto_openssl.c	110;"	d	file:
EXEEXT	Makefile	/^EXEEXT = $/;"	m
EXPANDED_SIZE	mtu.h	170;"	d
EXPANDED_SIZE_DYNAMIC	mtu.h	171;"	d
EXPANDED_SIZE_MIN	mtu.h	172;"	d
EXPONENTIAL_BACKOFF	reliable.h	47;"	d
EXTENDED_SOCKET_ERROR_CAPABILITY	syshead.h	412;"	d
EXTENDED_SOCKET_ERROR_CAPABILITY	syshead.h	414;"	d
EXTRA_DIST	Makefile	/^EXTRA_DIST = \\$/;"	m
EXTRA_FRAME	mtu.h	143;"	d
FAILURE	ssl_verify_backend.h	/^typedef enum { SUCCESS=0, FAILURE=1 } result_t;$/;"	e	enum:__anon5
FGREP	Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FORWARD_H	forward.h	33;"	d
FORWARD_INLINE_H	forward-inline.h	26;"	d
FRAGMENT_H	fragment.h	26;"	d
FRAG_ERR	fragment.c	40;"	d	file:
FRAG_EXTRA_MASK	fragment.h	251;"	d
FRAG_EXTRA_SHIFT	fragment.h	253;"	d
FRAG_ID_MASK	fragment.h	224;"	d
FRAG_ID_SHIFT	fragment.h	226;"	d
FRAG_MAP_MASK	fragment.h	72;"	d
FRAG_SEQ_ID_MASK	fragment.h	220;"	d
FRAG_SEQ_ID_SHIFT	fragment.h	222;"	d
FRAG_SIZE_MASK	fragment.h	238;"	d
FRAG_SIZE_ROUND_MASK	fragment.h	243;"	d
FRAG_SIZE_ROUND_SHIFT	fragment.h	242;"	d
FRAG_SIZE_SHIFT	fragment.h	240;"	d
FRAG_TEST	fragment.h	215;"	d
FRAG_TTL_SEC	fragment.h	55;"	d
FRAG_TYPE_MASK	fragment.h	203;"	d
FRAG_TYPE_SHIFT	fragment.h	205;"	d
FRAG_WAKEUP_INTERVAL	fragment.h	58;"	d
FRAG_WHOLE	fragment.h	207;"	d
FRAG_YES_LAST	fragment.h	212;"	d
FRAG_YES_NOTLAST	fragment.h	209;"	d
FRAME_HEADROOM	mtu.h	185;"	d
FRAME_HEADROOM_ADJ	mtu.h	186;"	d
FRAME_HEADROOM_BASE	mtu.h	184;"	d
FRAME_HEADROOM_MARKER_DECRYPT	mtu.h	130;"	d
FRAME_HEADROOM_MARKER_FRAGMENT	mtu.h	131;"	d
FRAME_HEADROOM_MARKER_READ_LINK	mtu.h	132;"	d
FRAME_HEADROOM_MARKER_READ_STREAM	mtu.h	133;"	d
FULL_SYNC	ssl.c	1662;"	d	file:
GENERAL_PROXY_SUPPORT	syshead.h	622;"	d
GETADDR_FATAL	socket.h	475;"	d
GETADDR_FATAL_ON_SIGNAL	socket.h	478;"	d
GETADDR_HOST_ORDER	socket.h	476;"	d
GETADDR_MENTION_RESOLVE_RETRY	socket.h	477;"	d
GETADDR_MSG_VIRT_OUT	socket.h	480;"	d
GETADDR_RANDOMIZE	socket.h	483;"	d
GETADDR_RESOLVE	socket.h	474;"	d
GETADDR_TRY_ONCE	socket.h	481;"	d
GETADDR_UPDATE_MANAGEMENT_STATE	socket.h	482;"	d
GETADDR_WARN_ON_SIGNAL	socket.h	479;"	d
GET_USER_PASS_DYNAMIC_CHALLENGE	misc.h	256;"	d
GET_USER_PASS_MANAGEMENT	misc.h	248;"	d
GET_USER_PASS_NEED_OK	misc.h	251;"	d
GET_USER_PASS_NEED_STR	misc.h	253;"	d
GET_USER_PASS_NOFATAL	misc.h	252;"	d
GET_USER_PASS_PASSWORD_ONLY	misc.h	250;"	d
GET_USER_PASS_PREVIOUS_CREDS_FAILED	misc.h	254;"	d
GET_USER_PASS_SENSITIVE	misc.h	249;"	d
GET_USER_PASS_STATIC_CHALLENGE	misc.h	257;"	d
GET_USER_PASS_STATIC_CHALLENGE_ECHO	misc.h	258;"	d
GHK_INLINE	crypto.h	352;"	d
GIT	Makefile	/^GIT = git$/;"	m
GREMLIN_CONNECTION_FLOOD_LEVEL	gremlin.h	53;"	d
GREMLIN_CONNECTION_FLOOD_MASK	gremlin.h	35;"	d
GREMLIN_CONNECTION_FLOOD_SHIFT	gremlin.h	34;"	d
GREMLIN_CORRUPT_LEVEL	gremlin.h	55;"	d
GREMLIN_CORRUPT_MASK	gremlin.h	41;"	d
GREMLIN_CORRUPT_SHIFT	gremlin.h	40;"	d
GREMLIN_DROP_LEVEL	gremlin.h	57;"	d
GREMLIN_DROP_MASK	gremlin.h	49;"	d
GREMLIN_DROP_SHIFT	gremlin.h	48;"	d
GREMLIN_H	gremlin.h	26;"	d
GREMLIN_PACKET_FLOOD_LEVEL	gremlin.h	54;"	d
GREMLIN_PACKET_FLOOD_MASK	gremlin.h	38;"	d
GREMLIN_PACKET_FLOOD_SHIFT	gremlin.h	37;"	d
GREMLIN_UP_DOWN_LEVEL	gremlin.h	56;"	d
GREMLIN_UP_DOWN_MASK	gremlin.h	44;"	d
GREMLIN_UP_DOWN_SHIFT	gremlin.h	43;"	d
GREP	Makefile	/^GREP = \/bin\/grep$/;"	m
HANDLE_DEFINED	win32.h	60;"	d
HASH	httpdigest.h	/^typedef unsigned char HASH[HASHLEN];$/;"	t
HASHHEX	httpdigest.h	/^typedef unsigned char HASHHEX[HASHHEXLEN+1];$/;"	t
HASHHEXLEN	httpdigest.h	29;"	d
HASHLEN	httpdigest.h	27;"	d
HAVE_CPP_VARARG_MACRO_GCC	syshead.h	375;"	d
HAVE_CPP_VARARG_MACRO_ISO	syshead.h	376;"	d
HAVE_GETTIMEOFDAY_NANOSECONDS	syshead.h	398;"	d
HAVE_VARARG_MACROS	error.h	148;"	d
HAVE_VARARG_MACROS	error.h	156;"	d
HELPER_H	helper.h	30;"	d
HMAC_CTX_cleanup	crypto_openssl.c	80;"	d	file:
HMAC_CTX_init	crypto_openssl.c	78;"	d	file:
HMAC_Init_ex	crypto_openssl.c	79;"	d	file:
HTTP_AUTH_BASIC	proxy.h	35;"	d
HTTP_AUTH_DIGEST	proxy.h	36;"	d
HTTP_AUTH_N	proxy.h	39;"	d
HTTP_AUTH_NONE	proxy.h	34;"	d
HTTP_AUTH_NTLM	proxy.h	37;"	d
HTTP_AUTH_NTLM2	proxy.h	38;"	d
HTTP_PROXY_OVERRIDE	syshead.h	667;"	d
HTTP_PROXY_OVERRIDE	syshead.h	669;"	d
IA_EMPTY_IF_UNDEF	socket.h	368;"	d
IA_NET_ORDER	socket.h	369;"	d
IEC_CLIENT_AUTH	manage.h	268;"	d
IEC_CLIENT_PF	manage.h	269;"	d
IEC_RSA_SIGN	manage.h	270;"	d
IEC_UNDEF	manage.h	267;"	d
IER_NEW	manage.c	782;"	d	file:
IER_RESET	manage.c	781;"	d	file:
IFCONFIG	Makefile	/^IFCONFIG = \/sbin\/ifconfig$/;"	m
IFCONFIG_AFTER_TUN_OPEN	tun.h	279;"	d
IFCONFIG_BEFORE_TUN_OPEN	tun.h	278;"	d
IFCONFIG_DEFAULT	tun.h	281;"	d
IFCONFIG_POOL_30NET	pool.h	38;"	d
IFCONFIG_POOL_INDIV	pool.h	39;"	d
IFCONFIG_POOL_MAX	pool.h	35;"	d
IFCONFIG_POOL_MIN_NETBITS	pool.h	36;"	d
IF_NAMESIZE	socket.c	2233;"	d	file:
IN	httpdigest.h	31;"	d
IN	httpdigest.h	33;"	d
IN6_ARE_ADDR_EQUAL	win32.h	45;"	d
INCLUDES	Makefile	/^INCLUDES = \\$/;"	m
INCR_ERROR	ssl.c	109;"	d	file:
INCR_ERROR	ssl.c	94;"	d	file:
INCR_GENERATED	ssl.c	107;"	d	file:
INCR_GENERATED	ssl.c	92;"	d	file:
INCR_SENT	ssl.c	106;"	d	file:
INCR_SENT	ssl.c	91;"	d	file:
INCR_SUCCESS	ssl.c	108;"	d	file:
INCR_SUCCESS	ssl.c	93;"	d	file:
INETD_NONE	socket.h	187;"	d
INETD_NOWAIT	socket.h	189;"	d
INETD_SOCKET_DESCRIPTOR	misc.h	35;"	d
INETD_WAIT	socket.h	188;"	d
INFO_CALLBACK_SSL_CONST	crypto_openssl.c	83;"	d	file:
INFO_CALLBACK_SSL_CONST	ssl_openssl.c	175;"	d	file:
INIT_H	init.h	26;"	d
INLINE_FILE_TAG	common.h	98;"	d
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INTEGER_H	integer.h	26;"	d
INTERVAL_DEBUG	interval.h	36;"	d
INTERVAL_H	interval.h	32;"	d
IN_TREE	schedule.h	75;"	d
IOSTATE_IMMEDIATE_RETURN	win32.h	187;"	d
IOSTATE_INITIAL	win32.h	185;"	d
IOSTATE_QUEUED	win32.h	186;"	d
IOSTAT_EAGAIN_ON_READ	ps.c	60;"	d	file:
IOSTAT_EAGAIN_ON_WRITE	ps.c	61;"	d	file:
IOSTAT_GOOD	ps.c	64;"	d	file:
IOSTAT_READ_ERROR	ps.c	62;"	d	file:
IOSTAT_WRITE_ERROR	ps.c	63;"	d	file:
IOW_CHECK_RESIDUAL	forward.h	56;"	d
IOW_FRAG	forward.h	57;"	d
IOW_MBUF	forward.h	58;"	d
IOW_READ	forward.h	62;"	d
IOW_READ_LINK	forward.h	54;"	d
IOW_READ_TUN	forward.h	53;"	d
IOW_READ_TUN_FORCE	forward.h	59;"	d
IOW_SHAPER	forward.h	55;"	d
IOW_TO_LINK	forward.h	52;"	d
IOW_TO_TUN	forward.h	51;"	d
IOW_WAIT_SIGNAL	forward.h	60;"	d
IPROUTE	Makefile	/^IPROUTE = \/sbin\/ip$/;"	m
IPV4_INVALID_ADDR	socket.h	396;"	d
IPV4_NETMASK_HOST	basic.h	36;"	d
IPW32_SET_ADAPTIVE	tun.h	57;"	d
IPW32_SET_ADAPTIVE_DELAY_WINDOW	tun.h	46;"	d
IPW32_SET_ADAPTIVE_TRY_NETSH	tun.h	47;"	d
IPW32_SET_DHCP_MASQ	tun.h	56;"	d
IPW32_SET_IPAPI	tun.h	55;"	d
IPW32_SET_MANUAL	tun.h	53;"	d
IPW32_SET_N	tun.h	58;"	d
IPW32_SET_NETSH	tun.h	54;"	d
IP_MCAST_NETWORK	mroute.h	35;"	d
IP_MCAST_SUBNET_MASK	mroute.h	34;"	d
IPv4_TCP_HEADER_SIZE	socket.h	529;"	d
IPv4_UDP_HEADER_SIZE	socket.h	528;"	d
IPv6_TCP_HEADER_SIZE	socket.h	531;"	d
IPv6_UDP_HEADER_SIZE	socket.h	530;"	d
ISC_ERRORS	init.h	106;"	d
ISC_SERVER	init.h	107;"	d
IS_SIG	sig.h	42;"	d
IS_TYPE_BUF	options.c	3685;"	d	file:
IS_TYPE_FP	options.c	3684;"	d	file:
IVM_LEVEL_1	init.h	46;"	d
IVM_LEVEL_2	init.h	47;"	d
KEY_DIRECTION_BIDIRECTIONAL	crypto.h	77;"	d
KEY_DIRECTION_INVERSE	crypto.h	79;"	d
KEY_DIRECTION_NORMAL	crypto.h	78;"	d
KEY_EXPANSION_ID	ssl.h	51;"	d
KEY_METHOD_MASK	ssl.h	126;"	d
KEY_METHOD_MAX	ssl.h	123;"	d
KEY_METHOD_MIN	ssl.h	122;"	d
KEY_SCAN_SIZE	ssl_common.h	418;"	d
KMDA_DEF	ssl_verify.c	1082;"	d	file:
KMDA_ERROR	ssl_verify.c	1079;"	d	file:
KMDA_SUCCESS	ssl_verify.c	1080;"	d	file:
KMDA_UNDEF	ssl_verify.c	1081;"	d	file:
KS_LAME_DUCK	ssl_common.h	322;"	d
KS_PRIMARY	ssl_common.h	321;"	d
KS_SIZE	ssl_common.h	324;"	d
LD	Makefile	/^LD = \/root\/WORK\/kedaVPN\/tools\/dm810x\/armlite\/arm-none-linux-gnueabi\/bin\/ld$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $/;"	m
LIBOBJS	Makefile	/^LIBOBJS = $/;"	m
LIBPAM_CFLAGS	Makefile	/^LIBPAM_CFLAGS = $/;"	m
LIBPAM_LIBS	Makefile	/^LIBPAM_LIBS = $/;"	m
LIBS	Makefile	/^LIBS = $/;"	m
LIBTOOL	Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LINK	Makefile	/^LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
LINK_MTU_DEFAULT	mtu.h	66;"	d
LINK_OUT	forward.h	40;"	d
LIPO	Makefile	/^LIPO = $/;"	m
LIST_H	list.h	26;"	d
LN_S	Makefile	/^LN_S = ln -s$/;"	m
LOGLEV	error.h	136;"	d
LOG_ECHO_TO_LOG	manage.h	111;"	d
LOG_FATAL_NOTIFY	manage.h	105;"	d
LOG_OPENVPN	error.c	56;"	d	file:
LOG_PRINT_CRLF	manage.h	104;"	d
LOG_PRINT_ECHO_PREFIX	manage.h	96;"	d
LOG_PRINT_INTVAL	manage.h	107;"	d
LOG_PRINT_INT_DATE	manage.h	99;"	d
LOG_PRINT_LOCAL_IP	manage.h	102;"	d
LOG_PRINT_LOG_PREFIX	manage.h	95;"	d
LOG_PRINT_MSG_FLAGS	manage.h	100;"	d
LOG_PRINT_REMOTE_IP	manage.h	109;"	d
LOG_PRINT_STATE	manage.h	101;"	d
LOG_PRINT_STATE_PREFIX	manage.h	97;"	d
LOG_RW	errlevel.h	47;"	d
LR_ERROR	route.c	1250;"	d	file:
LR_MATCH	route.c	1249;"	d	file:
LR_NOMATCH	route.c	1248;"	d	file:
LS_MODE_DEFAULT	socket.h	192;"	d
LS_MODE_TCP_ACCEPT_FROM	socket.h	194;"	d
LS_MODE_TCP_LISTEN	socket.h	193;"	d
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS = $/;"	m
LTRCCOMPILE	Makefile	/^LTRCCOMPILE = $(LIBTOOL) --mode=compile --tag=RC $(RCCOMPILE)$/;"	m
LZO_ADAPTIVE	lzo.h	67;"	d
LZO_CFLAGS	Makefile	/^LZO_CFLAGS = -I\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/lzo-arm-lib\/include\/$/;"	m
LZO_COMPRESS	lzo.h	75;"	d
LZO_DECOMPRESS	lzo.h	86;"	d
LZO_EXTRA_BUFFER	lzo.h	102;"	d
LZO_LIBS	Makefile	/^LZO_LIBS = -L\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/lzo-arm-lib\/lib -llzo2$/;"	m
LZO_ON	lzo.h	65;"	d
LZO_PREFIX_LEN	lzo.h	113;"	d
LZO_SELECTED	lzo.h	63;"	d
LZO_WORKSPACE	lzo.h	82;"	d
MAINTAINERCLEANFILES	Makefile	/^MAINTAINERCLEANFILES = \\$/;"	m
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/missing makeinfo$/;"	m
MAN2HTML	Makefile	/^MAN2HTML = $/;"	m
MANAGEMENT_DEF_AUTH	syshead.h	540;"	d
MANAGEMENT_ECHO_BUFFER_SIZE	manage.h	38;"	d
MANAGEMENT_ECHO_FLAGS	manage.c	56;"	d	file:
MANAGEMENT_ECHO_FLAGS	manage.c	58;"	d	file:
MANAGEMENT_ECHO_PULL_INFO	manage.c	53;"	d	file:
MANAGEMENT_IN_EXTRA	syshead.h	563;"	d
MANAGEMENT_LOG_HISTORY_INITIAL_SIZE	manage.h	37;"	d
MANAGEMENT_N_PASSWORD_RETRIES	manage.h	36;"	d
MANAGEMENT_PF	syshead.h	573;"	d
MANAGEMENT_READ	openvpn.h	248;"	d
MANAGEMENT_STATE_BUFFER_SIZE	manage.h	39;"	d
MANAGEMENT_VERSION	manage.h	35;"	d
MANAGEMENT_WRITE	openvpn.h	249;"	d
MANAGE_H	manage.h	26;"	d
MANAGMENT_EXTERNAL_KEY	syshead.h	550;"	d
MANIFEST_TOOL	Makefile	/^MANIFEST_TOOL = :$/;"	m
MANSIG_IGNORE_USR1_HUP	manage.h	229;"	d
MANSIG_MAP_USR1_TO_HUP	manage.h	230;"	d
MANSIG_MAP_USR1_TO_TERM	manage.h	231;"	d
MAN_CLIENT_AUTH_ENABLED	options.h	669;"	d
MAN_CLIENT_AUTH_ENABLED	options.h	671;"	d
MAPF_IA_EMPTY_IF_UNDEF	mroute.h	118;"	d
MAPF_SHOW_ARP	mroute.h	119;"	d
MAPF_SUBNET	mroute.h	117;"	d
MAX_CERT_DEPTH	ssl_verify.h	53;"	d
MAX_CIPHER_KEY_LENGTH	crypto_backend.h	169;"	d
MAX_CLIENT_NAT	clinat.h	30;"	d
MAX_FRAGS	fragment.h	74;"	d
MAX_FRAG_PKT_SIZE	fragment.h	155;"	d
MAX_HMAC_KEY_LENGTH	crypto_backend.h	346;"	d
MAX_PARMS	options.h	50;"	d
MAX_PLUGINS	plugin.h	44;"	d
MAX_ROUTES_DEFAULT	route.h	36;"	d
MAX_RW_SIZE_LINK	mtu.h	179;"	d
MAX_RW_SIZE_TUN	mtu.h	178;"	d
MAX_SEQ_BACKTRACK	packet_id.h	106;"	d
MAX_SUBJECT_LENGTH	ssl_verify_polarssl.c	45;"	d	file:
MAX_TIME_BACKTRACK	packet_id.h	115;"	d
MBUF_H	mbuf.h	26;"	d
MBUF_INDEX	mbuf.h	42;"	d
MCF_SERVER	manage.h	149;"	d
MC_MULTI_THREADED_MASTER	multi.h	121;"	d
MC_MULTI_THREADED_SCHEDULER	multi.h	123;"	d
MC_MULTI_THREADED_WORKER	multi.h	122;"	d
MC_SINGLE_THREADED	multi.h	120;"	d
MC_UNDEF	multi.h	119;"	d
MC_WORK_THREAD	multi.h	124;"	d
MD4_DIGEST_LENGTH	crypto_openssl.h	71;"	d
MD4_DIGEST_LENGTH	crypto_polarssl.h	70;"	d
MD5SUM	openvpn.h	584;"	d
MD5SUM	openvpn.h	586;"	d
MD5_DIGEST_LENGTH	crypto_polarssl.h	71;"	d
MEMDBG_H	memdbg.h	26;"	d
METRIC_NOT_USED	route.c	49;"	d	file:
MF_CLIENT_AUTH	manage.h	325;"	d
MF_CLIENT_PF	manage.h	328;"	d
MF_CONNECT_AS_CLIENT	manage.h	323;"	d
MF_EXTERNAL_KEY	manage.h	332;"	d
MF_FORGET_DISCONNECT	manage.h	322;"	d
MF_HOLD	manage.h	320;"	d
MF_QUERY_PASSWORDS	manage.h	319;"	d
MF_QUERY_PROXY	manage.h	336;"	d
MF_QUERY_REMOTE	manage.h	335;"	d
MF_SERVER	manage.h	318;"	d
MF_SIGNAL	manage.h	321;"	d
MF_UNICAST	mbuf.h	49;"	d
MF_UNIX_SOCK	manage.h	330;"	d
MF_UP_DOWN	manage.h	334;"	d
MIN	syshead.h	405;"	d
MIN_SEQ_BACKTRACK	packet_id.h	105;"	d
MIN_TIME_BACKTRACK	packet_id.h	114;"	d
MISC_H	misc.h	26;"	d
MKDIR_P	Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MN_AT_LEAST	manage.c	1050;"	d	file:
MODE_CLIENTS	pf.c	181;"	d	file:
MODE_POINT_TO_POINT	options.h	183;"	d
MODE_SERVER	options.h	184;"	d
MODE_SUBNETS	pf.c	182;"	d	file:
MODE_UNDEF	pf.c	180;"	d	file:
MPP_CLOSE_ON_SIGNAL	multi.h	222;"	d
MPP_CONDITIONAL_PRE_SELECT	multi.h	221;"	d
MPP_PRE_SELECT	multi.h	220;"	d
MPP_RECORD_TOUCH	multi.h	223;"	d
MROUTE_EXTRACT_BCAST	mroute.h	40;"	d
MROUTE_EXTRACT_IGMP	mroute.h	42;"	d
MROUTE_EXTRACT_MCAST	mroute.h	41;"	d
MROUTE_EXTRACT_SUCCEEDED	mroute.h	39;"	d
MROUTE_H	mroute.h	26;"	d
MROUTE_SEC_EXTRACT_BCAST	mroute.h	45;"	d
MROUTE_SEC_EXTRACT_IGMP	mroute.h	47;"	d
MROUTE_SEC_EXTRACT_MCAST	mroute.h	46;"	d
MROUTE_SEC_EXTRACT_SUCCEEDED	mroute.h	44;"	d
MROUTE_SEC_SHIFT	mroute.h	49;"	d
MR_ADDR_ETHER	mroute.h	62;"	d
MR_ADDR_IPV4	mroute.h	63;"	d
MR_ADDR_IPV6	mroute.h	64;"	d
MR_ADDR_MASK	mroute.h	65;"	d
MR_ADDR_NONE	mroute.h	61;"	d
MR_ARP	mroute.h	74;"	d
MR_HELPER_NET_LEN	mroute.h	88;"	d
MR_MAX_ADDR_LEN	mroute.h	56;"	d
MR_WITH_NETBITS	mroute.h	71;"	d
MR_WITH_PORT	mroute.h	68;"	d
MSG_NOSIGNAL	socket.h	258;"	d
MSG_TEST	error.h	145;"	d
MSSFIX_DEFAULT	mtu.h	81;"	d
MSS_H	mss.h	26;"	d
MSTATS_ACTIVE	mstats.h	41;"	d
MSTATS_EXPIRED	mstats.h	42;"	d
MSTATS_UNDEF	mstats.h	40;"	d
MS_CC_WAIT_READ	manage.h	245;"	d
MS_CC_WAIT_WRITE	manage.h	246;"	d
MS_INITIAL	manage.h	243;"	d
MS_LISTEN	manage.h	244;"	d
MTCP_H	mtcp.h	30;"	d
MTCP_MANAGEMENT	mtcp.c	62;"	d	file:
MTCP_N	mtcp.c	65;"	d	file:
MTCP_SIG	mtcp.c	60;"	d	file:
MTCP_SOCKET	mtcp.c	58;"	d	file:
MTCP_TUN	mtcp.c	59;"	d	file:
MTP_LINK_OUT	mtcp.c	463;"	d	file:
MTP_NONE	mtcp.c	461;"	d	file:
MTP_TUN_OUT	mtcp.c	462;"	d	file:
MTUDISC_NOT_SUPPORTED_MSG	mtu.c	153;"	d	file:
MTU_H	mtu.h	26;"	d
MTU_TO_MSS	proto.h	218;"	d
MUDP_H	mudp.h	30;"	d
MULTI_CACHE_ROUTE_TTL	multi.h	461;"	d
MULTI_CHECK_SIG	multi.h	568;"	d
MULTI_H	multi.h	30;"	d
MULTI_ROUTE_AGEABLE	multi.h	180;"	d
MULTI_ROUTE_CACHE	multi.h	179;"	d
MUST_BE_UNDEF	options.c	2294;"	d	file:
MUST_BE_UNDEF	options.c	2337;"	d	file:
MUTE_LEVEL_MASK	error.h	121;"	d
MUTE_LEVEL_SHIFT	error.h	120;"	d
MWCC_HOLD_WAIT	manage.c	2787;"	d	file:
MWCC_OTHER_WAIT	manage.c	2788;"	d	file:
MWCC_PASSWORD_WAIT	manage.c	2786;"	d	file:
M_CLIENT	error.h	112;"	d
M_DEBUG	error.h	92;"	d
M_DEBUG_LEVEL	error.h	87;"	d
M_ERR	error.h	109;"	d
M_ERRNO	error.h	94;"	d
M_FATAL	error.h	89;"	d
M_INFO	errlevel.h	56;"	d
M_MSG_VIRT_OUT	error.h	103;"	d
M_NOIPREFIX	error.h	106;"	d
M_NOLF	error.h	105;"	d
M_NOMUTE	error.h	100;"	d
M_NONFATAL	error.h	90;"	d
M_NOPREFIX	error.h	101;"	d
M_OPTERR	error.h	104;"	d
M_SSL	error.h	97;"	d
M_SSLERR	error.h	110;"	d
M_USAGE	error.h	111;"	d
M_USAGE_SMALL	error.h	102;"	d
M_VERB0	errlevel.h	54;"	d
M_WARN	error.h	91;"	d
NE32_PERSIST_EVENT	win32.h	80;"	d
NE32_WRITE_EVENT	win32.h	81;"	d
NETSH_PATH_SUFFIX	win32.h	33;"	d
NETSTAT	Makefile	/^NETSTAT = netstat$/;"	m
NEXTADDR	route.c	2629;"	d	file:
NEXTADDR	route.c	2728;"	d	file:
NEXTADDR	route.c	2950;"	d	file:
NI_IP_NETMASK	tun.c	57;"	d	file:
NI_OPTIONS	tun.c	58;"	d	file:
NI_TEST_FIRST	tun.c	56;"	d	file:
NM	Makefile	/^NM = \/root\/WORK\/kedaVPN\/tools\/dm810x\/armlite\/bin\/arm-none-linux-gnueabi-nm -B$/;"	m
NMEDIT	Makefile	/^NMEDIT = $/;"	m
NM_QUOTE_HINT	options.c	4038;"	d	file:
NONCE_SECRET_LEN_MAX	crypto.h	296;"	d
NONCE_SECRET_LEN_MIN	crypto.h	293;"	d
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NO_COMPRESS	lzo.h	118;"	d
NS_CERT_CHECK_CLIENT	ssl_verify.h	237;"	d
NS_CERT_CHECK_NONE	ssl_verify.h	233;"	d
NS_CERT_CHECK_SERVER	ssl_verify.h	235;"	d
NTLM	syshead.h	604;"	d
NTLM	syshead.h	606;"	d
NTLM_H	ntlm.h	2;"	d
N_DHCP_ADDR	tun.h	79;"	d
N_FRAG_BUF	fragment.h	50;"	d
N_ROUTE_BYPASS	route.h	56;"	d
N_SEQ_ID	fragment.h	143;"	d
OBJDUMP	Makefile	/^OBJDUMP = arm-none-linux-gnueabi-objdump$/;"	m
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
OCC_EXIT	occ.h	70;"	d
OCC_H	occ.h	26;"	d
OCC_INLINE_H	occ-inline.h	26;"	d
OCC_INTERVAL_SECONDS	occ.h	49;"	d
OCC_MTU_LOAD	occ.h	56;"	d
OCC_MTU_LOAD_INTERVAL_SECONDS	occ.h	65;"	d
OCC_MTU_LOAD_REQUEST	occ.h	55;"	d
OCC_MTU_REPLY	occ.h	59;"	d
OCC_MTU_REQUEST	occ.h	57;"	d
OCC_N_TRIES	occ.h	50;"	d
OCC_REPLY	occ.h	40;"	d
OCC_REQUEST	occ.h	39;"	d
OCC_STRING_SIZE	occ.h	33;"	d
OIA_ERROR	socket.h	423;"	d
OIA_HOSTNAME	socket.h	421;"	d
OIA_IP	socket.h	422;"	d
OPENSSL_CRYPTO_CFLAGS	Makefile	/^OPENSSL_CRYPTO_CFLAGS = -I\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/include$/;"	m
OPENSSL_CRYPTO_LIBS	Makefile	/^OPENSSL_CRYPTO_LIBS = -L\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/lib -lcrypto$/;"	m
OPENSSL_SSL_CFLAGS	Makefile	/^OPENSSL_SSL_CFLAGS = -I\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/include$/;"	m
OPENSSL_SSL_LIBS	Makefile	/^OPENSSL_SSL_LIBS = -L\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/lib -lssl$/;"	m
OPENVPN_DEBUG_FILE	error.h	65;"	d
OPENVPN_ERROR_FP	error.h	45;"	d
OPENVPN_ETH_ALEN	proto.h	55;"	d
OPENVPN_ETH_P_ARP	proto.h	63;"	d
OPENVPN_ETH_P_IPV4	proto.h	61;"	d
OPENVPN_ETH_P_IPV6	proto.h	62;"	d
OPENVPN_EXIT_STATUS_CANNOT_OPEN_DEBUG_FILE	error.h	54;"	d
OPENVPN_EXIT_STATUS_ERROR	error.h	52;"	d
OPENVPN_EXIT_STATUS_GOOD	error.h	51;"	d
OPENVPN_EXIT_STATUS_USAGE	error.h	53;"	d
OPENVPN_H	openvpn.h	26;"	d
OPENVPN_IPH_GET_LEN	proto.h	87;"	d
OPENVPN_IPH_GET_VER	proto.h	86;"	d
OPENVPN_IPPROTO_IGMP	proto.h	99;"	d
OPENVPN_IPPROTO_TCP	proto.h	100;"	d
OPENVPN_IPPROTO_UDP	proto.h	101;"	d
OPENVPN_IP_OFFMASK	proto.h	94;"	d
OPENVPN_LZO_H	lzo.h	26;"	d
OPENVPN_MAX_IV_LENGTH	crypto_openssl.h	53;"	d
OPENVPN_MAX_IV_LENGTH	crypto_polarssl.h	53;"	d
OPENVPN_MEMSTATS_H	mstats.h	30;"	d
OPENVPN_MODE_CBC	crypto_openssl.h	56;"	d
OPENVPN_MODE_CBC	crypto_polarssl.h	56;"	d
OPENVPN_MODE_CFB	crypto_openssl.h	62;"	d
OPENVPN_MODE_CFB	crypto_polarssl.h	62;"	d
OPENVPN_MODE_OFB	crypto_openssl.h	59;"	d
OPENVPN_MODE_OFB	crypto_polarssl.h	59;"	d
OPENVPN_MSG_FP	error.h	44;"	d
OPENVPN_OP_DECRYPT	crypto_openssl.h	68;"	d
OPENVPN_OP_DECRYPT	crypto_polarssl.h	68;"	d
OPENVPN_OP_ENCRYPT	crypto_openssl.h	65;"	d
OPENVPN_OP_ENCRYPT	crypto_polarssl.h	65;"	d
OPENVPN_PF_H	pf.h	28;"	d
OPENVPN_PKCS11_H	pkcs11.h	26;"	d
OPENVPN_PLUGIN_H	plugin.h	30;"	d
OPENVPN_PORT	socket.h	42;"	d
OPENVPN_SSL_H	ssl.h	31;"	d
OPENVPN_STATE_ADD_ROUTES	manage.h	461;"	d
OPENVPN_STATE_ASSIGN_IP	manage.h	460;"	d
OPENVPN_STATE_AUTH	manage.h	468;"	d
OPENVPN_STATE_CLIENT_BASE	manage.h	473;"	d
OPENVPN_STATE_CONNECTED	manage.h	462;"	d
OPENVPN_STATE_CONNECTING	manage.h	459;"	d
OPENVPN_STATE_EXITING	manage.h	464;"	d
OPENVPN_STATE_GET_CONFIG	manage.h	469;"	d
OPENVPN_STATE_INITIAL	manage.h	458;"	d
OPENVPN_STATE_RECONNECTING	manage.h	463;"	d
OPENVPN_STATE_RESOLVE	manage.h	470;"	d
OPENVPN_STATE_TCP_CONNECT	manage.h	471;"	d
OPENVPN_STATE_WAIT	manage.h	467;"	d
OPENVPN_TCPH_ACK_MASK	proto.h	151;"	d
OPENVPN_TCPH_CWR_MASK	proto.h	154;"	d
OPENVPN_TCPH_ECE_MASK	proto.h	153;"	d
OPENVPN_TCPH_FIN_MASK	proto.h	147;"	d
OPENVPN_TCPH_GET_DOFF	proto.h	144;"	d
OPENVPN_TCPH_PSH_MASK	proto.h	150;"	d
OPENVPN_TCPH_RST_MASK	proto.h	149;"	d
OPENVPN_TCPH_SYN_MASK	proto.h	148;"	d
OPENVPN_TCPH_URG_MASK	proto.h	152;"	d
OPENVPN_TCPOLEN_MAXSEG	proto.h	165;"	d
OPENVPN_TCPOPT_EOL	proto.h	162;"	d
OPENVPN_TCPOPT_MAXSEG	proto.h	164;"	d
OPENVPN_TCPOPT_NOP	proto.h	163;"	d
OPENVPN_WIN32_H	win32.h	27;"	d
OPTIONAL_CRYPTO_CFLAGS	Makefile	/^OPTIONAL_CRYPTO_CFLAGS =  -I\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/include -I\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/include$/;"	m
OPTIONAL_CRYPTO_LIBS	Makefile	/^OPTIONAL_CRYPTO_LIBS =  -L\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/lib -lssl -L\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/arm-openssl-lib\/lib -lcrypto$/;"	m
OPTIONAL_DL_LIBS	Makefile	/^OPTIONAL_DL_LIBS = $/;"	m
OPTIONAL_LZO_CFLAGS	Makefile	/^OPTIONAL_LZO_CFLAGS = -I\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/lzo-arm-lib\/include\/$/;"	m
OPTIONAL_LZO_LIBS	Makefile	/^OPTIONAL_LZO_LIBS = -L\/root\/WORK\/kedaVPN\/arm-vpn\/lib\/lzo-arm-lib\/lib -llzo2$/;"	m
OPTIONAL_PKCS11_HELPER_CFLAGS	Makefile	/^OPTIONAL_PKCS11_HELPER_CFLAGS = $/;"	m
OPTIONAL_PKCS11_HELPER_LIBS	Makefile	/^OPTIONAL_PKCS11_HELPER_LIBS = $/;"	m
OPTIONAL_SELINUX_LIBS	Makefile	/^OPTIONAL_SELINUX_LIBS = $/;"	m
OPTIONS_H	options.h	31;"	d
OPTION_LINE_SIZE	options.h	56;"	d
OPTION_PARM_SIZE	options.h	55;"	d
OPT_P_COMP	options.h	614;"	d
OPT_P_CONFIG	options.h	622;"	d
OPT_P_CONNECTION	options.h	631;"	d
OPT_P_CRYPTO	options.h	616;"	d
OPT_P_DEFAULT	options.h	633;"	d
OPT_P_ECHO	options.h	624;"	d
OPT_P_EXPLICIT_NOTIFY	options.h	623;"	d
OPT_P_GENERAL	options.h	604;"	d
OPT_P_INHERIT	options.h	625;"	d
OPT_P_INSTANCE	options.h	621;"	d
OPT_P_IPWIN32	options.h	607;"	d
OPT_P_MESSAGES	options.h	615;"	d
OPT_P_MTU	options.h	618;"	d
OPT_P_NICE	options.h	619;"	d
OPT_P_PERSIST	options.h	612;"	d
OPT_P_PERSIST_IP	options.h	613;"	d
OPT_P_PLUGIN	options.h	628;"	d
OPT_P_PULL_MODE	options.h	627;"	d
OPT_P_PUSH	options.h	620;"	d
OPT_P_ROUTE	options.h	606;"	d
OPT_P_ROUTE_EXTRAS	options.h	626;"	d
OPT_P_SCRIPT	options.h	608;"	d
OPT_P_SETENV	options.h	609;"	d
OPT_P_SHAPER	options.h	610;"	d
OPT_P_SOCKBUF	options.h	629;"	d
OPT_P_SOCKFLAGS	options.h	630;"	d
OPT_P_TIMER	options.h	611;"	d
OPT_P_TLS_PARMS	options.h	617;"	d
OPT_P_UP	options.h	605;"	d
OS_SPECIFIC_DIRSEP	syshead.h	463;"	d
OS_SPECIFIC_DIRSEP	syshead.h	465;"	d
OTIME_H	otime.h	26;"	d
OTOOL	Makefile	/^OTOOL = $/;"	m
OTOOL64	Makefile	/^OTOOL64 = $/;"	m
OUT	httpdigest.h	32;"	d
OUT	httpdigest.h	34;"	d
O_BINARY	syshead.h	456;"	d
P2MP	syshead.h	513;"	d
P2MP	syshead.h	515;"	d
P2MP_SERVER	syshead.h	519;"	d
P2MP_SERVER	syshead.h	521;"	d
P2P_CHECK_SIG	openvpn.c	42;"	d	file:
P2P_ERROR_DELAY_MS	errlevel.h	42;"	d
PACKAGE	Makefile	/^PACKAGE = openvpn$/;"	m
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = openvpn-users@lists.sourceforge.net$/;"	m
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = OpenVPN$/;"	m
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = OpenVPN 2.3.4$/;"	m
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = openvpn$/;"	m
PACKAGE_URL	Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = 2.3.4$/;"	m
PACKET_ID_H	packet_id.h	34;"	d
PACKET_ID_WRAP_TRIGGER	packet_id.h	60;"	d
PACKET_ID_WRAP_TRIGGER	packet_id.h	85;"	d
PARSE_DATA	crypto.c	859;"	d	file:
PARSE_DATA_COMPLETE	crypto.c	860;"	d	file:
PARSE_FINISHED	crypto.c	862;"	d	file:
PARSE_FOOT	crypto.c	861;"	d	file:
PARSE_HEAD	crypto.c	858;"	d	file:
PARSE_INITIAL	crypto.c	857;"	d	file:
PAR_ALL	proxy.h	48;"	d
PAR_NCT	proxy.h	49;"	d
PAR_NO	proxy.h	47;"	d
PASSTOS_CAPABILITY	syshead.h	389;"	d
PASSTOS_CAPABILITY	syshead.h	391;"	d
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
PAYLOAD_ALIGN	mtu.h	87;"	d
PAYLOAD_SIZE	mtu.h	163;"	d
PAYLOAD_SIZE_DYNAMIC	mtu.h	164;"	d
PA_BRACKET	buffer.h	132;"	d
PCT_DEST	pf-inline.h	33;"	d
PCT_SRC	pf-inline.h	32;"	d
PD_SHOW_DATA	ssl.h	486;"	d
PD_TLS	ssl.h	487;"	d
PD_TLS_AUTH_HMAC_SIZE_MASK	ssl.h	485;"	d
PD_VERBOSE	ssl.h	488;"	d
PEDANTIC	syshead.h	374;"	d
PEDANTIC	syshead.h	382;"	d
PERF_BIO_READ_CIPHERTEXT	perf.h	41;"	d
PERF_BIO_READ_PLAINTEXT	perf.h	39;"	d
PERF_BIO_WRITE_CIPHERTEXT	perf.h	42;"	d
PERF_BIO_WRITE_PLAINTEXT	perf.h	40;"	d
PERF_EVENT_LOOP	perf.h	45;"	d
PERF_H	perf.h	32;"	d
PERF_IO_WAIT	perf.h	44;"	d
PERF_MULTI_BCAST	perf.h	49;"	d
PERF_MULTI_CLOSE_INSTANCE	perf.h	47;"	d
PERF_MULTI_CREATE_INSTANCE	perf.h	46;"	d
PERF_MULTI_MCAST	perf.h	50;"	d
PERF_MULTI_SHOW_STATS	perf.h	48;"	d
PERF_N	perf.h	59;"	d
PERF_PROC_IN_LINK	perf.h	53;"	d
PERF_PROC_IN_TUN	perf.h	55;"	d
PERF_PROC_OUT_LINK	perf.h	56;"	d
PERF_PROC_OUT_TUN	perf.h	57;"	d
PERF_PROC_OUT_TUN_MTCP	perf.h	58;"	d
PERF_READ_IN_LINK	perf.h	52;"	d
PERF_READ_IN_TUN	perf.h	54;"	d
PERF_SCRIPT	perf.h	51;"	d
PERF_TLS_MULTI_PROCESS	perf.h	43;"	d
PF_INLINE_H	pf-inline.h	26;"	d
PF_MAX_LINE_LEN	pf.h	33;"	d
PING_EXIT	options.h	262;"	d
PING_H	ping.h	26;"	d
PING_INLINE_H	ping-inline.h	26;"	d
PING_RESTART	options.h	263;"	d
PING_STRING_SIZE	ping.h	39;"	d
PING_UNDEF	options.h	261;"	d
PIPV4_CLIENT_NAT	forward.h	234;"	d
PIPV4_EXTRACT_DHCP_ROUTER	forward.h	233;"	d
PIPV4_OUTGOING	forward.h	232;"	d
PIPV4_PASSTOS	forward.h	230;"	d
PIP_MSSFIX	forward.h	231;"	d
PKCS11_BACKEND_H_	pkcs11_backend.h	31;"	d
PKCS11_HELPER_CFLAGS	Makefile	/^PKCS11_HELPER_CFLAGS = -I\/usr\/local\/include  $/;"	m
PKCS11_HELPER_LIBS	Makefile	/^PKCS11_HELPER_LIBS = -L\/usr\/local\/lib -lpthread -ldl -lcrypto -lgnutls -lpkcs11-helper  $/;"	m
PKG_CONFIG	Makefile	/^PKG_CONFIG = \/usr\/bin\/pkg-config$/;"	m
PKG_CONFIG_LIBDIR	Makefile	/^PKG_CONFIG_LIBDIR = $/;"	m
PKG_CONFIG_PATH	Makefile	/^PKG_CONFIG_PATH = $/;"	m
PLATFORM_H	platform.h	26;"	d
PLUGIN_AUTH_PAM_CFLAGS	Makefile	/^PLUGIN_AUTH_PAM_CFLAGS = $/;"	m
PLUGIN_AUTH_PAM_LIBS	Makefile	/^PLUGIN_AUTH_PAM_LIBS = $/;"	m
PLUGIN_DEF_AUTH	syshead.h	537;"	d
PLUGIN_OPTION_LIST	options.h	663;"	d
PLUGIN_OPTION_LIST	options.h	665;"	d
PLUGIN_PF	syshead.h	570;"	d
PLUGIN_SYM	plugin.c	233;"	d	file:
PLUGIN_SYMBOL_REQUIRED	plugin.c	47;"	d	file:
POLARSSL_CFLAGS	Makefile	/^POLARSSL_CFLAGS = $/;"	m
POLARSSL_LIBS	Makefile	/^POLARSSL_LIBS = $/;"	m
POLL	syshead.h	643;"	d
POLL	syshead.h	645;"	d
POOL_H	pool.h	26;"	d
PORT_SHARE	syshead.h	528;"	d
PORT_SHARE	syshead.h	530;"	d
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_PULL_INITIAL_PING_RESTART	ping.h	34;"	d
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
PRNG_NONCE_RESET_BYTES	crypto.h	299;"	d
PROCESS_SIGNAL_P2P	openvpn.c	107;"	d	file:
PROGRAMS	Makefile	/^PROGRAMS = $(sbin_PROGRAMS)$/;"	m
PROTO_DUMP	openvpn.h	573;"	d
PROTO_DUMP	openvpn.h	580;"	d
PROTO_DUMP_FLAGS	openvpn.h	572;"	d
PROTO_H	proto.h	26;"	d
PROTO_N	socket.h	/^	PROTO_N$/;"	e	enum:proto_num
PROTO_NONE	socket.h	/^	PROTO_NONE, \/* catch for uninitialized *\/$/;"	e	enum:proto_num
PROTO_TCPv4	socket.h	/^	PROTO_TCPv4,$/;"	e	enum:proto_num
PROTO_TCPv4_CLIENT	socket.h	/^	PROTO_TCPv4_CLIENT,$/;"	e	enum:proto_num
PROTO_TCPv4_SERVER	socket.h	/^	PROTO_TCPv4_SERVER,$/;"	e	enum:proto_num
PROTO_TCPv6	socket.h	/^	PROTO_TCPv6,$/;"	e	enum:proto_num
PROTO_TCPv6_CLIENT	socket.h	/^	PROTO_TCPv6_CLIENT,$/;"	e	enum:proto_num
PROTO_TCPv6_SERVER	socket.h	/^	PROTO_TCPv6_SERVER,$/;"	e	enum:proto_num
PROTO_UDPv4	socket.h	/^	PROTO_UDPv4,$/;"	e	enum:proto_num
PROTO_UDPv6	socket.h	/^	PROTO_UDPv6,$/;"	e	enum:proto_num
PROXY_CONNECTION_BUFFER_SIZE	ps.c	46;"	d	file:
PROXY_DIGEST_AUTH	syshead.h	613;"	d
PROXY_DIGEST_AUTH	syshead.h	615;"	d
PROXY_H	proxy.h	26;"	d
PS_DISABLED	socket.h	134;"	d
PS_DONT_SHOW_ADDR	socket.h	348;"	d
PS_ENABLED	socket.h	135;"	d
PS_FOREIGN	socket.h	136;"	d
PS_H	ps.h	26;"	d
PS_INITIAL	perf.c	67;"	d	file:
PS_METER_INTERRUPTED	perf.c	69;"	d	file:
PS_METER_RUNNING	perf.c	68;"	d	file:
PS_SHOW_PKTINFO	socket.h	347;"	d
PS_SHOW_PORT	socket.h	346;"	d
PS_SHOW_PORT_IF_DEFINED	socket.h	345;"	d
PULL_DEFINED	options.h	636;"	d
PULL_DEFINED	options.h	643;"	d
PUSHLIST_H	pushlist.h	26;"	d
PUSH_BUNDLE_SIZE	common.h	87;"	d
PUSH_DEFINED	options.h	638;"	d
PUSH_DEFINED	options.h	647;"	d
PUSH_H	push.h	26;"	d
PUSH_MSG_ALREADY_REPLIED	push.h	38;"	d
PUSH_MSG_AUTH_FAILURE	push.h	36;"	d
PUSH_MSG_CONTINUATION	push.h	37;"	d
PUSH_MSG_ERROR	push.h	32;"	d
PUSH_MSG_REPLY	push.h	34;"	d
PUSH_MSG_REQUEST	push.h	33;"	d
PUSH_MSG_REQUEST_DEFERRED	push.h	35;"	d
PUSH_REQUEST_INTERVAL	common.h	92;"	d
P_ACK_V1	ssl.h	62;"	d
P_CONTROL_HARD_RESET_CLIENT_V1	ssl.h	58;"	d
P_CONTROL_HARD_RESET_CLIENT_V2	ssl.h	66;"	d
P_CONTROL_HARD_RESET_SERVER_V1	ssl.h	59;"	d
P_CONTROL_HARD_RESET_SERVER_V2	ssl.h	67;"	d
P_CONTROL_SOFT_RESET_V1	ssl.h	60;"	d
P_CONTROL_V1	ssl.h	61;"	d
P_DATA_V1	ssl.h	63;"	d
P_FIRST_OPCODE	ssl.h	70;"	d
P_KEY_ID_MASK	ssl.h	54;"	d
P_LAST_OPCODE	ssl.h	71;"	d
P_OPCODE_SHIFT	ssl.h	55;"	d
RANLIB	Makefile	/^RANLIB = arm-none-linux-gnueabi-ranlib$/;"	m
RC	Makefile	/^RC = $/;"	m
RCCOMPILE	Makefile	/^RCCOMPILE = $(RC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\$/;"	m
REAP_DIVISOR	multi.h	453;"	d
REAP_MAX	multi.h	455;"	d
REAP_MAX_WAKEUP	multi.h	452;"	d
REAP_MIN	multi.h	454;"	d
RELIABLE_ACK_SIZE	reliable.h	49;"	d
RELIABLE_CAPACITY	reliable.h	54;"	d
RELIABLE_H	reliable.h	35;"	d
RESOLV_RETRY_INFINITE	socket.h	53;"	d
RESPONSE_INIT_FAILED	ps.c	54;"	d	file:
RESPONSE_INIT_SUCCEEDED	ps.c	53;"	d	file:
RGI_ADDR_DEFINED	route.h	155;"	d
RGI_HWADDR_DEFINED	route.h	157;"	d
RGI_IFACE_DEFINED	route.h	158;"	d
RGI_NETMASK_DEFINED	route.h	156;"	d
RGI_N_ADDRESSES	route.h	177;"	d
RGI_ON_LINK	route.h	160;"	d
RGI_OVERFLOW	route.h	159;"	d
RG_AUTO_LOCAL	route.h	90;"	d
RG_BLOCK_LOCAL	route.h	91;"	d
RG_BYPASS_DHCP	route.h	87;"	d
RG_BYPASS_DNS	route.h	88;"	d
RG_DEF1	route.h	86;"	d
RG_ENABLE	route.h	84;"	d
RG_LOCAL	route.h	85;"	d
RG_REROUTE_GW	route.h	89;"	d
RH_HOST_LEN	options.h	169;"	d
RKF_INLINE	crypto.h	169;"	d
RKF_MUST_SUCCEED	crypto.h	168;"	d
RL_DID_LOCAL	route.h	184;"	d
RL_DID_REDIRECT_DEFAULT_GATEWAY	route.h	183;"	d
RL_ROUTES_ADDED	route.h	185;"	d
ROUNDUP	route.c	2613;"	d	file:
ROUNDUP	route.c	2725;"	d	file:
ROUNDUP	route.c	2933;"	d	file:
ROUTE	Makefile	/^ROUTE = \/sbin\/route$/;"	m
ROUTE_DELETE_FIRST	route.h	51;"	d
ROUTE_H	route.h	30;"	d
ROUTE_METHOD_ADAPTIVE	route.h	42;"	d
ROUTE_METHOD_EXE	route.h	44;"	d
ROUTE_METHOD_IPAPI	route.h	43;"	d
ROUTE_METHOD_MASK	route.h	45;"	d
ROUTE_OPTION_FLAGS	options.h	651;"	d
ROUTE_OPTION_FLAGS	options.h	653;"	d
ROUTE_REF_GW	route.h	52;"	d
RTSA_DEFAULT_METRIC	route.h	66;"	d
RTSA_REMOTE_ENDPOINT	route.h	64;"	d
RTSA_REMOTE_HOST	route.h	65;"	d
RT_ADDED	route.h	115;"	d
RT_DEFINED	route.h	114;"	d
RT_METRIC_DEFINED	route.h	116;"	d
SA_IP_PORT	socket.h	374;"	d
SA_SET_IF_NONZERO	socket.h	375;"	d
SCHEDULE_H	schedule.h	26;"	d
SCRIPT_SECURITY_WARNING	common.h	103;"	d
SC_ECHO	misc.h	234;"	d
SDL_CONSTRAIN	error.h	198;"	d
SED	Makefile	/^SED = \/bin\/sed$/;"	m
SELECT	event.c	53;"	d	file:
SELECT	event.c	55;"	d	file:
SELECT_MAX_FDS	event.c	63;"	d	file:
SELECT_MAX_FDS	event.c	65;"	d	file:
SELECT_PREFERRED_OVER_POLL	event.c	46;"	d	file:
SELINUX_LIBS	Makefile	/^SELINUX_LIBS = $/;"	m
SEQ_EXPIRED	packet_id.c	57;"	d	file:
SEQ_REAP_INTERVAL	packet_id.h	125;"	d
SEQ_UNSEEN	packet_id.c	56;"	d	file:
SESSION_ID_H	session_id.h	36;"	d
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SET_MTU_TUN	mtu.h	217;"	d
SET_MTU_UPPER_BOUND	mtu.h	218;"	d
SF_GETADDRINFO_DGRAM	socket.h	213;"	d
SF_HOST_RANDOMIZE	socket.h	212;"	d
SF_NOPOOL	options.h	392;"	d
SF_NO_PUSH_ROUTE_GATEWAY	options.h	394;"	d
SF_PORT_SHARE	socket.h	211;"	d
SF_TCP_NODELAY	socket.h	210;"	d
SF_TCP_NODELAY_HELPER	options.h	393;"	d
SF_USE_IP_PKTINFO	socket.h	209;"	d
SHAPER_DEFINED	options.h	657;"	d
SHAPER_DEFINED	options.h	659;"	d
SHAPER_H	shaper.h	26;"	d
SHAPER_MAX	shaper.h	44;"	d
SHAPER_MAX_TIMEOUT	shaper.h	46;"	d
SHAPER_MIN	shaper.h	43;"	d
SHAPER_USE_FP	shaper.h	48;"	d
SHA_DIGEST_LENGTH	crypto_polarssl.h	72;"	d
SHELL	Makefile	/^SHELL = \/bin\/bash$/;"	m
SHOW_BOOL	options.c	1671;"	d	file:
SHOW_BOOL	options.c	891;"	d	file:
SHOW_INT	options.c	1670;"	d	file:
SHOW_INT	options.c	888;"	d	file:
SHOW_PARM	options.c	1668;"	d	file:
SHOW_PARM	options.c	886;"	d	file:
SHOW_STR	options.c	1669;"	d	file:
SHOW_STR	options.c	887;"	d	file:
SHOW_UINT	options.c	889;"	d	file:
SHOW_UNSIGNED	options.c	890;"	d	file:
SID_SIZE	session_id.h	48;"	d
SIG_H	sig.h	26;"	d
SIZE	basic.h	31;"	d
SM_POST_INIT	sig.c	201;"	d	file:
SM_PRE_INIT	sig.c	200;"	d	file:
SM_UNDEF	sig.c	199;"	d	file:
SOCKETS_LIBS	Makefile	/^SOCKETS_LIBS =  -lnsl -lresolv$/;"	m
SOCKET_H	socket.h	26;"	d
SOCKET_READ	openvpn.h	241;"	d
SOCKET_SND_RCV_BUF_MAX	socket.h	47;"	d
SOCKET_UNDEFINED	syshead.h	482;"	d
SOCKET_UNDEFINED	syshead.h	485;"	d
SOCKET_WRITE	openvpn.h	242;"	d
SOCKS_H	socks.h	31;"	d
SOL_IP	syshead.h	432;"	d
SOURCES	Makefile	/^SOURCES = $(openvpn_SOURCES)$/;"	m
SSEC_BUILT_IN	misc.h	319;"	d
SSEC_NONE	misc.h	318;"	d
SSEC_PW_ENV	misc.h	321;"	d
SSEC_SCRIPTS	misc.h	320;"	d
SSLAPI	ssl_backend.h	39;"	d
SSLAPI	ssl_backend.h	44;"	d
SSLAPI	ssl_backend.h	49;"	d
SSLF_AUTH_USER_PASS_OPTIONAL	ssl_common.h	291;"	d
SSLF_CLIENT_CERT_NOT_REQUIRED	ssl_common.h	289;"	d
SSLF_CRL_VERIFY_DIR	ssl_common.h	293;"	d
SSLF_OPT_VERIFY	ssl_common.h	292;"	d
SSLF_TLS_VERSION_MASK	ssl_common.h	295;"	d
SSLF_TLS_VERSION_SHIFT	ssl_common.h	294;"	d
SSLF_USERNAME_AS_COMMON_NAME	ssl_common.h	290;"	d
SSL_BACKEND_H_	ssl_backend.h	32;"	d
SSL_COMMON_H_	ssl_common.h	31;"	d
SSL_CTX_use_CryptoAPI_certificate	cryptoapi.c	/^int SSL_CTX_use_CryptoAPI_certificate(SSL_CTX *ssl_ctx, const char *cert_prop)$/;"	f
SSL_OPENSSL_H_	ssl_openssl.h	31;"	d
SSL_OP_NO_TICKET	ssl_openssl.h	43;"	d
SSL_POLARSSL_H_	ssl_polarssl.h	31;"	d
SSL_SIG_LENGTH	cryptoapi.c	69;"	d	file:
SSL_VERIFY_BACKEND_H_	ssl_verify_backend.h	31;"	d
SSL_VERIFY_H_	ssl_verify.h	31;"	d
SSL_VERIFY_OPENSSL_H_	ssl_verify_openssl.h	32;"	d
SSL_VERIFY_POLARSSL_H_	ssl_verify_polarssl.h	31;"	d
STACK_N	perf.h	68;"	d
STATUS_H	status.h	26;"	d
STATUS_OUTPUT_READ	status.h	51;"	d
STATUS_OUTPUT_WRITE	status.h	52;"	d
STATUS_PRINTF_MAXLEN	status.c	208;"	d	file:
STRIP	Makefile	/^STRIP = arm-none-linux-gnueabi-strip$/;"	m
SUB_CHECKSUM_32	proto.h	205;"	d
SUCCESS	ssl_verify_backend.h	/^typedef enum { SUCCESS=0, FAILURE=1 } result_t;$/;"	e	enum:__anon5
SWAP	error.c	198;"	d	file:
SWAP_BUF_SIZE	ssl.c	1162;"	d	file:
SWAP_BUF_SIZE	ssl.c	1212;"	d	file:
SYSHEAD_H	syshead.h	26;"	d
SYSLOG_CAPABILITY	syshead.h	447;"	d
SYSLOG_CAPABILITY	syshead.h	449;"	d
SYS_PATH_ENV_VAR_NAME	win32.h	32;"	d
S_ACTIVE	ssl_common.h	94;"	d
S_ERROR	ssl_common.h	78;"	d
S_ERROR	syshead.h	251;"	d
S_FATAL	misc.h	90;"	d
S_GOT_KEY	ssl_common.h	91;"	d
S_INITIAL	ssl_common.h	81;"	d
S_NORMAL_OP	ssl_common.h	99;"	d
S_PRE_START	ssl_common.h	84;"	d
S_SCRIPT	misc.h	89;"	d
S_SENT_KEY	ssl_common.h	89;"	d
S_START	ssl_common.h	87;"	d
S_UNDEF	ssl_common.h	79;"	d
TAP_CFLAGS	Makefile	/^TAP_CFLAGS = $/;"	m
TAP_MTU_EXTRA_DEFAULT	mtu.h	76;"	d
TAP_WIN_COMPONENT_ID	Makefile	/^TAP_WIN_COMPONENT_ID = tap0901$/;"	m
TAP_WIN_MIN_MAJOR	Makefile	/^TAP_WIN_MIN_MAJOR = 9$/;"	m
TAP_WIN_MIN_MINOR	Makefile	/^TAP_WIN_MIN_MINOR = 9$/;"	m
TA_INITIAL	mtcp.c	51;"	d	file:
TA_SOCKET_READ	mtcp.c	44;"	d	file:
TA_SOCKET_READ_RESIDUAL	mtcp.c	45;"	d	file:
TA_SOCKET_WRITE	mtcp.c	46;"	d	file:
TA_SOCKET_WRITE_DEFERRED	mtcp.c	48;"	d	file:
TA_SOCKET_WRITE_READY	mtcp.c	47;"	d	file:
TA_TIMEOUT	mtcp.c	52;"	d	file:
TA_TUN_READ	mtcp.c	49;"	d	file:
TA_TUN_WRITE	mtcp.c	50;"	d	file:
TA_TUN_WRITE_TIMEOUT	mtcp.c	53;"	d	file:
TA_UNDEF	mtcp.c	43;"	d	file:
TIME_BACKTRACK_PROTECTION	syshead.h	677;"	d
TLA_LOCAL	route.h	290;"	d
TLA_NONLOCAL	route.h	289;"	d
TLA_NOT_IMPLEMENTED	route.h	288;"	d
TLSMP_ACTIVE	ssl.h	239;"	d
TLSMP_INACTIVE	ssl.h	238;"	d
TLSMP_KILL	ssl.h	240;"	d
TLS_AGGREGATE_ACK	ssl.h	76;"	d
TLS_AUTHENTICATION_DEFERRED	ssl_verify.h	74;"	d
TLS_AUTHENTICATION_FAILED	ssl_verify.h	73;"	d
TLS_AUTHENTICATION_SUCCEEDED	ssl_verify.h	72;"	d
TLS_AUTHENTICATION_UNDEFINED	ssl_verify.h	75;"	d
TLS_CHANNEL_BUF_SIZE	common.h	81;"	d
TLS_CLIENT	options.c	2997;"	d	file:
TLS_CLIENT	options.c	3076;"	d	file:
TLS_MODE	openvpn.h	571;"	d
TLS_MODE	openvpn.h	579;"	d
TLS_MULTI_AUTH_STATUS_INTERVAL	ssl.h	107;"	d
TLS_MULTI_HORIZON	ssl.h	96;"	d
TLS_MULTI_REFRESH	ssl.h	95;"	d
TLS_MULTI_THREAD_SEND_TIMEOUT	ssl.h	104;"	d
TLS_OPTIONS_LEN	ssl.h	114;"	d
TLS_RELIABLE_N_REC_BUFFERS	ssl.h	90;"	d
TLS_RELIABLE_N_SEND_BUFFERS	ssl.h	89;"	d
TLS_REMOTE_SUBJECT_DN	ssl_verify.h	69;"	d
TLS_REMOTE_SUBJECT_RDN_PREFIX	ssl_verify.h	70;"	d
TLS_SERVER	options.c	2998;"	d	file:
TLS_SERVER	options.c	3077;"	d	file:
TLS_USERNAME_LEN	ssl_verify.c	50;"	d	file:
TLS_VER_1_0	ssl_backend.h	114;"	d
TLS_VER_1_1	ssl_backend.h	115;"	d
TLS_VER_1_2	ssl_backend.h	116;"	d
TLS_VER_BAD	ssl_backend.h	112;"	d
TLS_VER_UNSPEC	ssl_backend.h	113;"	d
TM_ACTIVE	ssl_common.h	398;"	d
TM_LAME_DUCK	ssl_common.h	401;"	d
TM_SIZE	ssl_common.h	402;"	d
TM_UNTRUSTED	ssl_common.h	399;"	d
TOP_NET30	proto.h	44;"	d
TOP_P2P	proto.h	45;"	d
TOP_SUBNET	proto.h	46;"	d
TOP_UNDEF	proto.h	43;"	d
TO_LINK_DEF	forward.h	49;"	d
TO_LINK_FRAG	forward.h	44;"	d
TO_LINK_FRAG	forward.h	46;"	d
TUNNEL_TOPOLOGY	tun.h	131;"	d
TUNNEL_TYPE	tun.h	128;"	d
TUNSETGROUP	tun.c	1606;"	d	file:
TUNSETOWNER	tun.c	1603;"	d	file:
TUN_ADAPTER_INDEX_INVALID	tun.h	43;"	d
TUN_H	tun.h	26;"	d
TUN_LINK_DELTA	mtu.h	149;"	d
TUN_MTU_DEFAULT	mtu.h	71;"	d
TUN_MTU_MIN	mtu.h	61;"	d
TUN_MTU_SIZE	mtu.h	154;"	d
TUN_MTU_SIZE_DYNAMIC	mtu.h	155;"	d
TUN_OUT	forward.h	39;"	d
TUN_PASS_BUFFER	tun.h	305;"	d
TUN_READ	openvpn.h	243;"	d
TUN_WRITE	openvpn.h	244;"	d
TV_WITHIN_SIGMA_MAX_SEC	otime.h	235;"	d
TV_WITHIN_SIGMA_MAX_USEC	otime.h	236;"	d
UINT64	ntlm.c	51;"	d	file:
UINT64	ntlm.c	55;"	d	file:
UINT8_MAX	socket.c	2335;"	d	file:
UINTEGER64	ntlm.c	50;"	d	file:
UINTEGER64	ntlm.c	54;"	d	file:
UNDEFINED_EVENT	event.h	49;"	d
UNDEFINED_EVENT	event.h	55;"	d
UNIX_SOCK_SUPPORT	syshead.h	583;"	d
UNIX_SOCK_SUPPORT	syshead.h	585;"	d
UP_QUERY_DISABLED	manage.h	236;"	d
UP_QUERY_NEED_OK	manage.h	239;"	d
UP_QUERY_NEED_STR	manage.h	240;"	d
UP_QUERY_PASS	manage.h	238;"	d
UP_QUERY_USER_PASS	manage.h	237;"	d
UP_TYPE_AUTH	ssl_common.h	42;"	d
UP_TYPE_PRIVATE_KEY	ssl_common.h	43;"	d
UP_TYPE_PROXY	proxy.c	47;"	d	file:
UP_TYPE_SOCKS	socks.c	53;"	d	file:
USEC_TIMER_MAX	interval.h	209;"	d
USEC_TIMER_MAX_USEC	interval.h	211;"	d
USER_PASS_LEN	misc.h	206;"	d
USER_PASS_LEN	misc.h	208;"	d
USE_64_BIT_COUNTERS	syshead.h	498;"	d
VALGRIND_MAKE_READABLE	memdbg.h	50;"	d
VALGRIND_MAKE_READABLE	memdbg.h	54;"	d
VERIFY_PERMISSION	options.c	3988;"	d	file:
VERIFY_PERMISSION	options.c	4029;"	d	file:
VERIFY_X509_NONE	ssl_verify.h	65;"	d
VERIFY_X509_SUBJECT_DN	ssl_verify.h	66;"	d
VERIFY_X509_SUBJECT_RDN	ssl_verify.h	67;"	d
VERIFY_X509_SUBJECT_RDN_PREFIX	ssl_verify.h	68;"	d
VERSION	Makefile	/^VERSION = 2.3.4$/;"	m
WEXITSTATUS	syshead.h	64;"	d
WIFEXITED	syshead.h	67;"	d
WIN32_0_1	syshead.h	473;"	d
WIN32_0_1	syshead.h	475;"	d
WIN_IPCONFIG_PATH_SUFFIX	win32.h	35;"	d
WIN_NET_PATH_SUFFIX	win32.h	36;"	d
WIN_ROUTE_PATH_SUFFIX	win32.h	34;"	d
WSO_FORCE_CONSOLE	win32.h	156;"	d
WSO_FORCE_SERVICE	win32.h	155;"	d
WSO_MODE_CONSOLE	win32.h	141;"	d
WSO_MODE_SERVICE	win32.h	140;"	d
WSO_MODE_UNDEF	win32.h	139;"	d
WSO_NOFORCE	win32.h	154;"	d
X509_NAME_CHAR_CLASS	ssl_verify.c	53;"	d	file:
X509_USERNAME_FIELD_DEFAULT	ssl.h	117;"	d
XT_FULL_CHAIN	ssl_verify.h	220;"	d
YES_COMPRESS	lzo.h	115;"	d
_BASE64_H_	base64.h	35;"	d
_CAPI_DATA	cryptoapi.c	/^typedef struct _CAPI_DATA {$/;"	s	file:
_CRYPTOAPI_H_	cryptoapi.h	2;"	d
_P1003_1B_VISIBLE	syshead.h	364;"	d
__APPLE_USE_RFC_3542	syshead.h	50;"	d
__OPENVPN_X509_CERT_T_DECLARED	ssl_verify_openssl.h	37;"	d
__OPENVPN_X509_CERT_T_DECLARED	ssl_verify_polarssl.h	39;"	d
__mygettimeofday	pkcs11.c	/^__mygettimeofday (struct timeval *tv) {$/;"	f	file:
__mysleep	pkcs11.c	/^__mysleep (const unsigned long usec) {$/;"	f	file:
__mytime	pkcs11.c	/^__mytime (void) {$/;"	f	file:
_buffer_entry	ssl_polarssl.h	/^struct _buffer_entry {$/;"	s
_pkcs11_msg_openvpn2pkcs11	pkcs11.c	/^_pkcs11_msg_openvpn2pkcs11 ($/;"	f	file:
_pkcs11_msg_pkcs112openvpn	pkcs11.c	/^_pkcs11_msg_pkcs112openvpn ($/;"	f	file:
_pkcs11_openvpn_log	pkcs11.c	/^_pkcs11_openvpn_log ($/;"	f	file:
_pkcs11_openvpn_pin_prompt	pkcs11.c	/^_pkcs11_openvpn_pin_prompt ($/;"	f	file:
_pkcs11_openvpn_show_pkcs11_ids_pin_prompt	pkcs11.c	/^_pkcs11_openvpn_show_pkcs11_ids_pin_prompt ($/;"	f	file:
_pkcs11_openvpn_token_prompt	pkcs11.c	/^_pkcs11_openvpn_token_prompt ($/;"	f	file:
abort	plugin.h	/^  openvpn_plugin_abort_v1 abort;$/;"	m	struct:plugin
abs_builddir	Makefile	/^abs_builddir = \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/src\/openvpn$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/src\/openvpn$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4$/;"	m
absolute_pathname	misc.c	/^absolute_pathname (const char *pathname)$/;"	f
ac	lzo.h	/^  struct lzo_adaptive_compress ac;$/;"	m	struct:lzo_compress_workspace	typeref:struct:lzo_compress_workspace::lzo_adaptive_compress
ac_ct_AR	Makefile	/^ac_ct_AR = $/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = $/;"	m
ac_ct_DUMPBIN	Makefile	/^ac_ct_DUMPBIN = $/;"	m
accept_from	openvpn.h	/^  const struct link_socket *accept_from; \/* possibly do accept() on a parent link_socket *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket
acf_last_mod	ssl_common.h	/^  time_t acf_last_mod;$/;"	m	struct:key_state
ack_seq	proto.h	/^  uint32_t      ack_seq;   \/* acknowledgement number *\/$/;"	m	struct:openvpn_tcphdr
ack_write_buf	ssl_common.h	/^  struct buffer ack_write_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer
active	reliable.h	/^  bool active;$/;"	m	struct:reliable_entry
actual	socket.h	/^  struct link_socket_actual actual; \/* reply to this address *\/$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::link_socket_actual
actual_name	tun.h	/^  char *actual_name; \/* actual name of TUN\/TAP dev, usually including unit number *\/$/;"	m	struct:tuntap
adapter_index	route.h	/^  DWORD adapter_index;  \/* interface or ~0 if undefined *\/$/;"	m	struct:route_gateway_info
adapter_index	tun.h	/^  DWORD adapter_index;$/;"	m	struct:tuntap
adapter_index_of_ip	tun.c	/^adapter_index_of_ip (const IP_ADAPTER_INFO *list,$/;"	f
adapter_netmask	tun.h	/^  in_addr_t adapter_netmask;$/;"	m	struct:tuntap
add_block_local	route.c	/^add_block_local (struct route_list *rl)$/;"	f	file:
add_block_local_item	route.c	/^add_block_local_item (struct route_list *rl,$/;"	f	file:
add_bypass_address	route.c	/^add_bypass_address (struct route_bypass *rb, const in_addr_t a)$/;"	f	file:
add_bypass_routes	route.c	/^add_bypass_routes (struct route_bypass *rb,$/;"	f	file:
add_client	pf.c	/^add_client (const char *line, const char *prefix, const int line_num, struct pf_cn_elem ***next, const bool exclude)$/;"	f	file:
add_client_nat_to_option_list	clinat.c	/^add_client_nat_to_option_list (struct client_nat_option_list *dest,$/;"	f
add_entry	clinat.c	/^add_entry(struct client_nat_option_list *dest,$/;"	f	file:
add_env_item	misc.c	/^add_env_item (char *str, const bool do_alloc, struct env_item **list, struct gc_arena *gc)$/;"	f	file:
add_host_route_array	route.c	/^add_host_route_array (struct route_bypass *rb, const IP_ADDR_STRING *iplist)$/;"	f	file:
add_host_route_if_nonlocal	route.c	/^add_host_route_if_nonlocal (struct route_bypass *rb, const in_addr_t addr)$/;"	f	file:
add_in6_addr	socket.c	/^struct in6_addr add_in6_addr( struct in6_addr base, uint32_t add )$/;"	f
add_option	options.c	/^add_option (struct options *options,$/;"	f	file:
add_route	route.c	/^add_route (struct route_ipv4 *r,$/;"	f
add_route3	route.c	/^add_route3 (in_addr_t network,$/;"	f	file:
add_route_connected_v6_net	tun.c	/^void add_route_connected_v6_net(struct tuntap * tt,$/;"	f
add_route_ipapi	route.c	/^add_route_ipapi (const struct route_ipv4 *r, const struct tuntap *tt, DWORD adapter_index)$/;"	f
add_route_ipv6	route.c	/^add_route_ipv6 (struct route_ipv6 *r6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f
add_route_ipv6_to_option_list	route.c	/^add_route_ipv6_to_option_list (struct route_ipv6_option_list *l,$/;"	f
add_route_to_option_list	route.c	/^add_route_to_option_list (struct route_option_list *l,$/;"	f
add_routes	route.c	/^add_routes (struct route_list *rl, struct route_ipv6_list *rl6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f
add_security_buffer	ntlm.c	/^add_security_buffer(int sb_offset, void *data, int length, unsigned char *msg_buf, int *msg_bufpos)$/;"	f	file:
add_subnet	pf.c	/^add_subnet (const char *line, const char *prefix, const int line_num, struct pf_subnet ***next, const bool exclude)$/;"	f	file:
addr	mroute.h	/^  uint8_t addr[MR_MAX_ADDR_LEN];  \/* actual address *\/$/;"	m	struct:mroute_addr
addr	multi.h	/^  struct mroute_addr addr;$/;"	m	struct:multi_route	typeref:struct:multi_route::mroute_addr
addr	route.h	/^  in_addr_t addr;$/;"	m	struct:route_gateway_address
addr	socket.h	/^  } addr;$/;"	m	struct:openvpn_sockaddr	typeref:union:openvpn_sockaddr::__anon8
addr	win32.h	/^    struct sockaddr_in addr;$/;"	m	union:overlapped_io::__anon11	typeref:struct:overlapped_io::__anon11::sockaddr_in
addr6	win32.h	/^    struct sockaddr_in6 addr6;$/;"	m	union:overlapped_io::__anon11	typeref:struct:overlapped_io::__anon11::sockaddr_in6
addr_copy_host	socket.h	/^addr_copy_host(struct openvpn_sockaddr *dst, const struct openvpn_sockaddr *src)$/;"	f
addr_copy_sa	socket.h	/^addr_copy_sa(struct openvpn_sockaddr *dst, const struct openvpn_sockaddr *src)$/;"	f
addr_defined	socket.h	/^addr_defined (const struct openvpn_sockaddr *addr)$/;"	f
addr_defined	win32.h	/^  bool addr_defined;$/;"	m	struct:overlapped_io
addr_defined_ipi	socket.h	/^addr_defined_ipi (const struct link_socket_actual *lsa)$/;"	f
addr_family_name	socket.c	/^addr_family_name (int af) $/;"	f
addr_guess_family	socket.c	/^addr_guess_family(int proto, const char *name) $/;"	f
addr_host	socket.h	/^addr_host (const struct openvpn_sockaddr *addr)$/;"	f
addr_inet4or6	socket.h	/^addr_inet4or6(struct sockaddr *addr)$/;"	f
addr_match	socket.h	/^addr_match (const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2)$/;"	f
addr_match_proto	socket.h	/^addr_match_proto (const struct openvpn_sockaddr *a1,$/;"	f
addr_port_match	socket.h	/^addr_port_match (const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2)$/;"	f
addr_zero_host	socket.h	/^addr_zero_host(struct openvpn_sockaddr *addr)$/;"	f
addrlen	win32.h	/^  int addrlen;$/;"	m	struct:overlapped_io
addrs	route.h	/^  struct route_gateway_address addrs[RGI_N_ADDRESSES]; \/* local addresses attached to iface *\/$/;"	m	struct:route_gateway_info	typeref:struct:route_gateway_info::route_gateway_address
adjust_power_of_2	misc.c	/^adjust_power_of_2 (size_t u)$/;"	f
af_addr_size	socket.h	/^af_addr_size(unsigned short af)$/;"	f
ageable_ttl_secs	mroute.h	/^  int ageable_ttl_secs;          \/* host route cache entry time-to-live*\/$/;"	m	struct:mroute_helper
align_adjust	mtu.h	/^  int align_adjust;$/;"	m	struct:frame
align_flags	mtu.h	/^  unsigned int align_flags;$/;"	m	struct:frame
alloc_buf	buffer.h	141;"	d
alloc_buf_debug	buffer.c	/^alloc_buf_debug (size_t size, const char *file, int line)$/;"	f
alloc_buf_gc	buffer.h	142;"	d
alloc_buf_gc_debug	buffer.c	/^alloc_buf_gc_debug (size_t size, struct gc_arena *gc, const char *file, int line)$/;"	f
alloc_buf_sock_tun	mtu.c	/^alloc_buf_sock_tun (struct buffer *buf,$/;"	f
alloc_connection_entry	options.c	/^alloc_connection_entry (struct options *options, const int msglevel)$/;"	f	file:
alloc_connection_list_if_undef	options.c	/^alloc_connection_list_if_undef (struct options *options)$/;"	f	file:
alloc_remote_entry	options.c	/^alloc_remote_entry (struct options *options, const int msglevel)$/;"	f	file:
alloc_remote_list_if_undef	options.c	/^alloc_remote_list_if_undef (struct options *options)$/;"	f	file:
allow_pull_fqdn	options.h	/^  bool allow_pull_fqdn; \/* as a client, allow server to push a FQDN for certain parameters *\/$/;"	m	struct:options
allowed_ciphers	ssl_polarssl.h	/^    int * allowed_ciphers;	\/**< List of allowed ciphers for this connection *\/$/;"	m	struct:tls_root_ctx
am__DEPENDENCIES_1	Makefile	/^am__DEPENDENCIES_1 =$/;"	m
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ax_emptyarray.m4 \\$/;"	m
am__can_run_installinfo	Makefile	/^am__can_run_installinfo = \\$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__define_uniq_tagged_files	Makefile	/^am__define_uniq_tagged_files = \\$/;"	m
am__depfiles_maybe	Makefile	/^am__depfiles_maybe = depfiles$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__installdirs	Makefile	/^am__installdirs = "$(DESTDIR)$(sbindir)"$/;"	m
am__is_gnu_make	Makefile	/^am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__make_dryrun	Makefile	/^am__make_dryrun = (target_option=n; $(am__make_running_with_option))$/;"	m
am__make_keepgoing	Makefile	/^am__make_keepgoing = (target_option=k; $(am__make_running_with_option))$/;"	m
am__make_running_with_option	Makefile	/^am__make_running_with_option = \\$/;"	m
am__mv	Makefile	/^am__mv = mv -f$/;"	m
am__openvpn_SOURCES_DIST	Makefile	/^am__openvpn_SOURCES_DIST = base64.c base64.h basic.h buffer.c buffer.h \\$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__tagged_files	Makefile	/^am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)$/;"	m
am__tar	Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__uniquify_input	Makefile	/^am__uniquify_input = $(AWK) '\\$/;"	m
am__untar	Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__v_CCLD_	Makefile	/^am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CCLD_0	Makefile	/^am__v_CCLD_0 = @echo "  CCLD    " $@;$/;"	m
am__v_CCLD_1	Makefile	/^am__v_CCLD_1 = $/;"	m
am__v_CC_	Makefile	/^am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CC_0	Makefile	/^am__v_CC_0 = @echo "  CC      " $@;$/;"	m
am__v_CC_1	Makefile	/^am__v_CC_1 = $/;"	m
am__v_GEN_	Makefile	/^am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_GEN_0	Makefile	/^am__v_GEN_0 = @echo "  GEN     " $@;$/;"	m
am__v_GEN_1	Makefile	/^am__v_GEN_1 = $/;"	m
am__v_P_	Makefile	/^am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_P_0	Makefile	/^am__v_P_0 = false$/;"	m
am__v_P_1	Makefile	/^am__v_P_1 = :$/;"	m
am__v_at_	Makefile	/^am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_at_0	Makefile	/^am__v_at_0 = @$/;"	m
am__v_at_1	Makefile	/^am__v_at_1 = $/;"	m
am__v_lt_	Makefile	/^am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_lt_0	Makefile	/^am__v_lt_0 = --silent$/;"	m
am__v_lt_1	Makefile	/^am__v_lt_1 = $/;"	m
am_openvpn_OBJECTS	Makefile	/^am_openvpn_OBJECTS = base64.$(OBJEXT) buffer.$(OBJEXT) \\$/;"	m
apply_push_options	options.c	/^apply_push_options (struct options *options,$/;"	f
arg	event.h	/^  void *arg;$/;"	m	struct:event_set_return
arg	manage.h	/^  void *arg;$/;"	m	struct:management_callback
arg	status.h	/^  void *arg;$/;"	m	struct:virtual_output
argc	misc.h	/^  size_t argc;$/;"	m	struct:argv
args	event.c	/^  void **args;  \/* allocated to capacity size *\/$/;"	m	struct:se_set	file:
args	event.c	/^  void **args;$/;"	m	struct:po_set	file:
argv	misc.h	/^  char **argv;$/;"	m	struct:argv
argv	misc.h	/^struct argv {$/;"	s
argv	plugin.h	/^  const char **argv;$/;"	m	struct:plugin_option
argv_append	misc.c	/^argv_append (struct argv *a, char *str) \/* str must have been malloced or be NULL *\/$/;"	f	file:
argv_clone	misc.c	/^argv_clone (const struct argv *a, const size_t headroom)$/;"	f
argv_extend	misc.c	/^argv_extend (struct argv *a, const size_t newcap)$/;"	f	file:
argv_extract_cmd_name	misc.c	/^argv_extract_cmd_name (const char *path)$/;"	f	file:
argv_grow	misc.c	/^argv_grow (struct argv *a, const size_t add)$/;"	f	file:
argv_init	misc.c	/^argv_init (struct argv *a)$/;"	f
argv_insert_head	misc.c	/^argv_insert_head (const struct argv *a, const char *head)$/;"	f
argv_msg	misc.c	/^argv_msg (const int msglev, const struct argv *a)$/;"	f
argv_msg_prefix	misc.c	/^argv_msg_prefix (const int msglev, const struct argv *a, const char *prefix)$/;"	f
argv_new	misc.c	/^argv_new (void)$/;"	f
argv_printf	misc.c	/^argv_printf (struct argv *a, const char *format, ...)$/;"	f
argv_printf_arglist	misc.c	/^argv_printf_arglist (struct argv *a, const char *format, const unsigned int flags, va_list arglist)$/;"	f
argv_printf_cat	misc.c	/^argv_printf_cat (struct argv *a, const char *format, ...)$/;"	f
argv_reset	misc.c	/^argv_reset (struct argv *a)$/;"	f
argv_str	misc.c	/^argv_str (const struct argv *a, struct gc_arena *gc, const unsigned int flags)$/;"	f
argv_system_str	misc.c	/^argv_system_str (const struct argv *a)$/;"	f
argv_system_str_append	misc.c	/^argv_system_str_append (struct argv *a, const char *str, const bool enquote)$/;"	f	file:
argv_term	misc.c	/^argv_term (const char **f)$/;"	f
argv_test	misc.c	/^argv_test (void)$/;"	f
arp_command	proto.h	/^  uint16_t arp_command;         \/* 0x0001 for ARP request, 0x0002 for ARP reply *\/$/;"	m	struct:openvpn_arp
array	manage.h	/^  struct log_entry *array;$/;"	m	struct:log_history	typeref:struct:log_history::log_entry
array	mbuf.h	/^  struct mbuf_item *array;$/;"	m	struct:mbuf_set	typeref:struct:mbuf_set::mbuf_item
array	options.h	/^  struct connection_entry *array[CONNECTION_LIST_SIZE];$/;"	m	struct:connection_list	typeref:struct:connection_list::connection_entry
array	options.h	/^  struct remote_entry *array[CONNECTION_LIST_SIZE];$/;"	m	struct:remote_list	typeref:struct:remote_list::remote_entry
array	reliable.h	/^  struct reliable_entry array[RELIABLE_CAPACITY];$/;"	m	struct:reliable	typeref:struct:reliable::reliable_entry
array_mult_safe	buffer.c	/^array_mult_safe (const size_t m1, const size_t m2, const size_t extra)$/;"	f
ascii2ipset	tun.c	/^ascii2ipset (const char* name)$/;"	f
ascii2keydirection	crypto.c	/^ascii2keydirection (int msglevel, const char *str)$/;"	f
ascii2proto	socket.c	/^ascii2proto (const char* proto_name)$/;"	f
ask_gremlin	gremlin.c	/^ask_gremlin (int flags)$/;"	f
assert_failed	error.c	/^assert_failed (const char *filename, int line)$/;"	f
at_least_one_tap_win	tun.c	/^at_least_one_tap_win (const struct tap_reg *tap_reg)$/;"	f	file:
atou	options.c	/^atou (const char *str)$/;"	f	file:
auth_challenge	ssl.c	/^static char *auth_challenge; \/* GLOBAL *\/$/;"	v	file:
auth_challenge_info	misc.h	/^struct auth_challenge_info {$/;"	s
auth_challenge_info	misc.h	/^struct auth_challenge_info {};$/;"	s
auth_control_file	ssl_common.h	/^  char *auth_control_file;$/;"	m	struct:key_state
auth_control_status	ssl_common.h	/^  unsigned int auth_control_status;$/;"	m	struct:key_state
auth_deferred	ssl_common.h	/^  bool auth_deferred;$/;"	m	struct:key_state
auth_deferred_expire	ssl_common.h	/^  time_t auth_deferred_expire;$/;"	m	struct:key_state
auth_deferred_expire_window	ssl.c	/^auth_deferred_expire_window (const struct tls_options *o)$/;"	f	file:
auth_file	proxy.h	/^  const char *auth_file;$/;"	m	struct:http_proxy_options
auth_method	proxy.h	/^  int auth_method;$/;"	m	struct:http_proxy_info
auth_method_string	proxy.h	/^  const char *auth_method_string;$/;"	m	struct:http_proxy_options
auth_retry	proxy.h	/^  int auth_retry;$/;"	m	struct:http_proxy_options
auth_retry	proxy.h	/^  int auth_retry;$/;"	m	struct:http_proxy_options_simple
auth_retry_get	options.c	/^auth_retry_get (void)$/;"	f
auth_retry_print	options.c	/^auth_retry_print (void)$/;"	f
auth_retry_set	options.c	/^auth_retry_set (const int msglevel, const char *option)$/;"	f
auth_user_pass	openvpn.h	/^  struct user_pass *auth_user_pass;$/;"	m	struct:context_1	typeref:struct:context_1::user_pass
auth_user_pass	ssl.c	/^static struct user_pass auth_user_pass; \/* GLOBAL *\/$/;"	v	typeref:struct:user_pass	file:
auth_user_pass_enabled	ssl.c	/^static bool auth_user_pass_enabled;     \/* GLOBAL *\/$/;"	v	file:
auth_user_pass_file	options.h	/^  const char *auth_user_pass_file;$/;"	m	struct:options
auth_user_pass_setup	ssl.c	/^auth_user_pass_setup (const char *auth_file, const struct static_challenge_info *sci)$/;"	f
auth_user_pass_verify_script	options.h	/^  const char *auth_user_pass_verify_script;$/;"	m	struct:options
auth_user_pass_verify_script	ssl_common.h	/^  const char *auth_user_pass_verify_script;$/;"	m	struct:tls_options
auth_user_pass_verify_script_via_file	options.h	/^  bool auth_user_pass_verify_script_via_file;$/;"	m	struct:options
auth_user_pass_verify_script_via_file	ssl_common.h	/^  bool auth_user_pass_verify_script_via_file;$/;"	m	struct:tls_options
authenticated	ssl_common.h	/^  bool authenticated;$/;"	m	struct:key_state
authfile	socks.h	/^  char authfile[256];$/;"	m	struct:socks_proxy_info
authname	options.h	/^  const char *authname;$/;"	m	struct:options
authname_defined	options.h	/^  bool authname_defined;$/;"	m	struct:options
aux_buf	openvpn.h	/^  struct buffer aux_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
backend_x509_get_serial	ssl_verify_openssl.c	/^backend_x509_get_serial (openvpn_x509_cert_t *cert, struct gc_arena *gc)$/;"	f
backend_x509_get_serial	ssl_verify_polarssl.c	/^backend_x509_get_serial (openvpn_x509_cert_t *cert, struct gc_arena *gc)$/;"	f
backend_x509_get_serial_hex	ssl_verify_openssl.c	/^backend_x509_get_serial_hex (openvpn_x509_cert_t *cert, struct gc_arena *gc)$/;"	f
backend_x509_get_serial_hex	ssl_verify_polarssl.c	/^backend_x509_get_serial_hex (openvpn_x509_cert_t *cert, struct gc_arena *gc)$/;"	f
background_pid	ps.h	/^  pid_t background_pid;$/;"	m	struct:port_share
bad_address_length	socket.c	/^bad_address_length (int actual, int expected)$/;"	f
base	manage.h	/^  int base;$/;"	m	struct:log_history
base	pool.h	/^  in_addr_t base;$/;"	m	struct:ifconfig_pool
base64_chars	base64.c	/^static char base64_chars[] = $/;"	v	file:
base_ipv6	pool.h	/^  struct in6_addr base_ipv6;$/;"	m	struct:ifconfig_pool	typeref:struct:ifconfig_pool::in6_addr
bind_defined	options.h	/^  bool bind_defined;$/;"	m	struct:connection_entry
bind_local	options.h	/^  bool bind_local;$/;"	m	struct:connection_entry
bind_local	socket.h	/^  bool bind_local;$/;"	m	struct:link_socket
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bio_debug_data	ssl_openssl.c	/^bio_debug_data (const char *mode, BIO *bio, const uint8_t *buf, int len, const char *desc)$/;"	f	file:
bio_debug_oc	ssl_openssl.c	/^bio_debug_oc (const char *mode, BIO *bio)$/;"	f	file:
bio_read	ssl_openssl.c	/^bio_read (BIO *bio, struct buffer *buf, int maxlen, const char *desc)$/;"	f	file:
bio_write	ssl_openssl.c	/^bio_write (BIO *bio, const uint8_t *data, int size, const char *desc)$/;"	f	file:
bio_write_post	ssl_openssl.c	/^bio_write_post (const int status, struct buffer *buf)$/;"	f	file:
biofp	ssl_openssl.c	/^static FILE *biofp;                            \/* GLOBAL *\/$/;"	v	file:
biofp_last_open	ssl_openssl.c	/^static time_t biofp_last_open;                 \/* GLOBAL *\/$/;"	v	file:
biofp_reopen_interval	ssl_openssl.c	/^static const int biofp_reopen_interval = 600;  \/* GLOBAL *\/$/;"	v	file:
biofp_toggle	ssl_openssl.c	/^static bool biofp_toggle;                      \/* GLOBAL *\/$/;"	v	file:
blank_up	manage.c	/^static const char blank_up[] = "[[BLANK]]";$/;"	v	file:
broadcast	tun.h	/^  in_addr_t broadcast;$/;"	m	struct:tuntap
bucket	list.h	/^  struct hash_bucket *bucket;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_bucket
bucket_base	multi.h	/^  int bucket_base;$/;"	m	struct:multi_reap
bucket_index	list.h	/^  int bucket_index;$/;"	m	struct:hash_iterator
bucket_index_end	list.h	/^  int bucket_index_end;$/;"	m	struct:hash_iterator
bucket_index_start	list.h	/^  int bucket_index_start;$/;"	m	struct:hash_iterator
bucket_marked	list.h	/^  bool bucket_marked;$/;"	m	struct:hash_iterator
buckets	list.h	/^  struct hash_bucket *buckets;$/;"	m	struct:hash	typeref:struct:hash::hash_bucket
buckets_per_pass	multi.h	/^  int buckets_per_pass;$/;"	m	struct:multi_reap
buf	buffer.h	/^  struct buffer buf;$/;"	m	struct:buffer_entry	typeref:struct:buffer_entry::buffer
buf	fragment.h	/^  struct buffer buf;            \/**< Buffer in which received datagrams$/;"	m	struct:fragment	typeref:struct:fragment::buffer
buf	manage.h	/^  struct buffer buf;$/;"	m	struct:command_line	typeref:struct:command_line::buffer
buf	mbuf.h	/^  struct buffer buf;$/;"	m	struct:mbuf_buffer	typeref:struct:mbuf_buffer::buffer
buf	openvpn.h	/^  struct buffer buf;$/;"	m	struct:context_2	typeref:struct:context_2::buffer
buf	ps.c	/^  struct buffer buf;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::buffer	file:
buf	reliable.h	/^  struct buffer buf;$/;"	m	struct:reliable_entry	typeref:struct:reliable_entry::buffer
buf	socket.h	/^  struct buffer buf;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer
buf	win32.h	/^  struct buffer buf;$/;"	m	struct:overlapped_io	typeref:struct:overlapped_io::buffer
buf_advance	buffer.h	/^buf_advance (struct buffer *buf, int size)$/;"	f
buf_assign	buffer.c	/^buf_assign (struct buffer *dest, const struct buffer *src)$/;"	f
buf_bend	buffer.h	/^buf_bend (const struct buffer *buf)$/;"	f
buf_blast	buffer.h	/^buf_blast (const struct buffer *buf)$/;"	f
buf_bptr	buffer.h	/^buf_bptr (const struct buffer *buf)$/;"	f
buf_catrunc	buffer.c	/^buf_catrunc (struct buffer *buf, const char *str)$/;"	f
buf_chomp	buffer.c	/^buf_chomp (struct buffer *buf)$/;"	f
buf_clear	buffer.c	/^buf_clear (struct buffer *buf)$/;"	f
buf_copy	buffer.h	/^buf_copy (struct buffer *dest, const struct buffer *src)$/;"	f
buf_copy_excess	buffer.h	/^buf_copy_excess (struct buffer *dest,$/;"	f
buf_copy_n	buffer.h	/^buf_copy_n (struct buffer *dest, struct buffer *src, int n)$/;"	f
buf_copy_range	buffer.h	/^buf_copy_range (struct buffer *dest,$/;"	f
buf_debug_file	buffer.c	/^buf_debug_file (const struct buffer *buf)$/;"	f	file:
buf_debug_file	buffer.c	150;"	d	file:
buf_debug_line	buffer.c	/^buf_debug_line (const struct buffer *buf)$/;"	f	file:
buf_debug_line	buffer.c	149;"	d	file:
buf_defined	buffer.h	/^buf_defined (const struct buffer *buf)$/;"	f
buf_forward_capacity	buffer.h	/^buf_forward_capacity (const struct buffer *buf)$/;"	f
buf_forward_capacity_total	buffer.h	/^buf_forward_capacity_total (const struct buffer *buf)$/;"	f
buf_free_entries	ssl_polarssl.c	/^static void buf_free_entries(endless_buffer *buf)$/;"	f	file:
buf_free_entry	ssl_polarssl.c	/^static inline void buf_free_entry(buffer_entry *entry)$/;"	f	file:
buf_inc_len	buffer.h	/^buf_inc_len (struct buffer *buf, int inc)$/;"	f
buf_init	buffer.h	167;"	d
buf_init	buffer.h	170;"	d
buf_init	socket.h	/^  struct buffer buf_init;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer
buf_init	win32.h	/^  struct buffer buf_init;$/;"	m	struct:overlapped_io	typeref:struct:overlapped_io::buffer
buf_init_debug	buffer.c	/^buf_init_debug (struct buffer *buf, int offset, const char *file, int line)$/;"	f
buf_init_dowork	buffer.h	/^buf_init_dowork (struct buffer *buf, int offset)$/;"	f
buf_len	buffer.h	/^buf_len (const struct buffer *buf)$/;"	f
buf_null_terminate	buffer.c	/^buf_null_terminate (struct buffer *buf)$/;"	f
buf_parse	buffer.c	/^buf_parse (struct buffer *buf, const int delim, char *line, const int size)$/;"	f
buf_prepend	buffer.h	/^buf_prepend (struct buffer *buf, int size)$/;"	f
buf_printf	buffer.c	/^buf_printf (struct buffer *buf, const char *format, ...)$/;"	f
buf_puts	buffer.c	/^buf_puts(struct buffer *buf, const char *str)$/;"	f
buf_read	buffer.h	/^buf_read (struct buffer *src, void *dest, int size)$/;"	f
buf_read_alloc	buffer.h	/^buf_read_alloc (struct buffer *buf, int size)$/;"	f
buf_read_u16	buffer.h	/^buf_read_u16 (struct buffer *buf)$/;"	f
buf_read_u32	buffer.h	/^buf_read_u32 (struct buffer *buf, bool *good)$/;"	f
buf_read_u8	buffer.h	/^buf_read_u8 (struct buffer *buf)$/;"	f
buf_reset	buffer.h	/^buf_reset (struct buffer *buf)$/;"	f
buf_reset_len	buffer.h	/^buf_reset_len (struct buffer *buf)$/;"	f
buf_reverse_capacity	buffer.h	/^buf_reverse_capacity (const struct buffer *buf)$/;"	f
buf_rmtail	buffer.c	/^buf_rmtail (struct buffer *buf, uint8_t remove)$/;"	f
buf_safe	buffer.h	/^buf_safe (const struct buffer *buf, int len)$/;"	f
buf_safe_bidir	buffer.h	/^buf_safe_bidir (const struct buffer *buf, int len)$/;"	f
buf_set_read	buffer.h	/^buf_set_read (struct buffer *buf, const uint8_t *data, int size)$/;"	f
buf_set_write	buffer.h	/^buf_set_write (struct buffer *buf, uint8_t *data, int size)$/;"	f
buf_size_error	buffer.c	/^buf_size_error (const size_t size)$/;"	f
buf_size_valid	buffer.h	/^buf_size_valid (const size_t size)$/;"	f
buf_size_valid_signed	buffer.h	/^buf_size_valid_signed (const int size)$/;"	f
buf_str	buffer.h	/^buf_str (const struct buffer *buf)$/;"	f
buf_string_compare_advance	buffer.c	/^buf_string_compare_advance (struct buffer *src, const char *match)$/;"	f
buf_string_match	buffer.h	/^buf_string_match (const struct buffer *src, const void *match, int size)$/;"	f
buf_string_match_head	buffer.h	/^buf_string_match_head (const struct buffer *src, const void *match, int size)$/;"	f
buf_string_match_head_str	buffer.c	/^buf_string_match_head_str (const struct buffer *src, const char *match)$/;"	f
buf_sub	buffer.c	/^buf_sub (struct buffer *buf, int size, bool prepend)$/;"	f
buf_substring_len	buffer.c	/^buf_substring_len (const struct buffer *buf, int delim)$/;"	f
buf_valid	buffer.h	/^buf_valid (const struct buffer *buf)$/;"	f
buf_write	buffer.h	/^buf_write (struct buffer *dest, const void *src, int size)$/;"	f
buf_write_alloc	buffer.h	/^buf_write_alloc (struct buffer *buf, int size)$/;"	f
buf_write_alloc_prepend	buffer.h	/^buf_write_alloc_prepend (struct buffer *buf, int size, bool prepend)$/;"	f
buf_write_prepend	buffer.h	/^buf_write_prepend (struct buffer *dest, const void *src, int size)$/;"	f
buf_write_string_file	buffer.c	/^buf_write_string_file (const struct buffer *buf, const char *filename, int fd)$/;"	f
buf_write_u16	buffer.h	/^buf_write_u16 (struct buffer *dest, int data)$/;"	f
buf_write_u32	buffer.h	/^buf_write_u32 (struct buffer *dest, int data)$/;"	f
buf_write_u8	buffer.h	/^buf_write_u8 (struct buffer *dest, int data)$/;"	f
buffer	buffer.h	/^struct buffer$/;"	s
buffer	mbuf.h	/^  struct mbuf_buffer *buffer;$/;"	m	struct:mbuf_item	typeref:struct:mbuf_item::mbuf_buffer
buffer_entry	buffer.h	/^struct buffer_entry$/;"	s
buffer_entry	ssl_polarssl.h	/^typedef struct _buffer_entry buffer_entry;$/;"	t	typeref:struct:_buffer_entry
buffer_initial	ps.c	/^  bool buffer_initial;$/;"	m	struct:proxy_connection	file:
buffer_list	buffer.h	/^struct buffer_list$/;"	s
buffer_list_advance	buffer.c	/^buffer_list_advance (struct buffer_list *ol, int n)$/;"	f
buffer_list_aggregate	buffer.c	/^buffer_list_aggregate (struct buffer_list *bl, const size_t max)$/;"	f
buffer_list_defined	buffer.c	/^buffer_list_defined (const struct buffer_list *ol)$/;"	f
buffer_list_file	buffer.c	/^buffer_list_file (const char *fn, int max_line_len)$/;"	f
buffer_list_free	buffer.c	/^buffer_list_free (struct buffer_list *ol)$/;"	f
buffer_list_new	buffer.c	/^buffer_list_new (const int max_size)$/;"	f
buffer_list_peek	buffer.c	/^buffer_list_peek (struct buffer_list *ol)$/;"	f
buffer_list_pop	buffer.c	/^buffer_list_pop (struct buffer_list *ol)$/;"	f
buffer_list_push	buffer.c	/^buffer_list_push (struct buffer_list *ol, const unsigned char *str)$/;"	f
buffer_list_push_data	buffer.c	/^buffer_list_push_data (struct buffer_list *ol, const uint8_t *data, size_t size)$/;"	f
buffer_list_reset	buffer.c	/^buffer_list_reset (struct buffer_list *ol)$/;"	f
buffer_turnover	forward.c	/^buffer_turnover (const uint8_t *orig_buf, struct buffer *dest_stub, struct buffer *src_stub, struct buffer *storage)$/;"	f	file:
buffers	openvpn.h	/^  struct context_buffers *buffers;$/;"	m	struct:context_2	typeref:struct:context_2::context_buffers
buffers_owned	openvpn.h	/^  bool buffers_owned; \/* if true, we should free all buffers on close *\/$/;"	m	struct:context_2
build	Makefile	/^build = x86_64-unknown-linux-gnu$/;"	m
build_alias	Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = x86_64$/;"	m
build_dhcp_options_string	tun.c	/^build_dhcp_options_string (struct buffer *buf, const struct tuntap_options *o)$/;"	f	file:
build_os	Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	Makefile	/^build_triplet = x86_64-unknown-linux-gnu$/;"	m
build_vendor	Makefile	/^build_vendor = unknown$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
burst	ssl_common.h	/^  bool burst;$/;"	m	struct:tls_session
bypass	route.h	/^  in_addr_t bypass[N_ROUTE_BYPASS];$/;"	m	struct:route_bypass
bypass	route.h	/^  struct route_bypass bypass;$/;"	m	struct:route_special_addr	typeref:struct:route_special_addr::route_bypass
bypass_doubledash	options.c	/^bypass_doubledash (char **p)$/;"	f	file:
bytecount_last_update	manage.h	/^  time_t bytecount_last_update;$/;"	m	struct:man_connection
bytecount_last_update	manage.h	/^  time_t bytecount_last_update;$/;"	m	struct:man_def_auth_context
bytecount_update_seconds	manage.h	/^  int bytecount_update_seconds;$/;"	m	struct:man_connection
bytes_in	manage.h	/^  counter_type bytes_in;$/;"	m	struct:man_persist
bytes_out	manage.h	/^  counter_type bytes_out;$/;"	m	struct:man_persist
bytes_per_second	shaper.h	/^  int bytes_per_second;$/;"	m	struct:shaper
c0	openvpn.h	/^  struct context_0 *c0;         \/**< Level 0 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_0
c1	openvpn.h	/^  struct context_1 c1;          \/**< Level 1 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_1
c2	openvpn.h	/^  struct context_2 c2;          \/**< Level 2 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_2
ca_chain	ssl_polarssl.h	/^    x509_cert *ca_chain;	\/**< CA chain for remote verification *\/$/;"	m	struct:tls_root_ctx
ca_file	options.h	/^  const char *ca_file;$/;"	m	struct:options
ca_file_inline	options.h	/^  const char *ca_file_inline;$/;"	m	struct:options
ca_path	options.h	/^  const char *ca_path;$/;"	m	struct:options
cache_generation	mroute.h	/^  unsigned int cache_generation; \/* incremented when route added *\/$/;"	m	struct:mroute_helper
cache_generation	multi.h	/^  unsigned int cache_generation;$/;"	m	struct:multi_route
callback	manage.h	/^  struct management_callback callback;$/;"	m	struct:man_persist	typeref:struct:man_persist::management_callback
callbacks	plugin.c	/^static struct openvpn_plugin_callbacks callbacks = {$/;"	v	typeref:struct:openvpn_plugin_callbacks	file:
capacity	buffer.h	/^  int capacity;                 \/**< Size in bytes of memory allocated by$/;"	m	struct:buffer
capacity	event.c	/^  int capacity; \/* fixed largest fd + 1 *\/$/;"	m	struct:se_set	file:
capacity	event.c	/^  int capacity;$/;"	m	struct:po_set	file:
capacity	event.c	/^  int capacity;$/;"	m	struct:we_set	file:
capacity	manage.h	/^  int capacity;$/;"	m	struct:log_history
capacity	mbuf.h	/^  unsigned int capacity;$/;"	m	struct:mbuf_set
capacity	misc.h	/^  size_t capacity;$/;"	m	struct:argv
capacity	route.h	/^  int capacity;$/;"	m	struct:route_ipv6_list
capacity	route.h	/^  int capacity;$/;"	m	struct:route_ipv6_option_list
capacity	route.h	/^  int capacity;$/;"	m	struct:route_list
capacity	route.h	/^  int capacity;$/;"	m	struct:route_option_list
cc_config	multi.h	/^  struct buffer_list *cc_config;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::buffer_list
ccd_exclusive	options.h	/^  bool ccd_exclusive;$/;"	m	struct:options
cd_dir	options.h	/^  const char *cd_dir;$/;"	m	struct:options
ce	options.h	/^  struct connection_entry ce;$/;"	m	struct:options	typeref:struct:options::connection_entry
ce_management_query_proxy	init.c	/^ce_management_query_proxy (struct context *c)$/;"	f	file:
ce_management_query_remote	init.c	/^ce_management_query_remote (struct context *c, const char *remote_ip_hint)$/;"	f	file:
cert_context	cryptoapi.c	/^    const CERT_CONTEXT *cert_context;$/;"	m	struct:_CAPI_DATA	file:
cert_file	options.h	/^  const char *cert_file;$/;"	m	struct:options
cert_file_inline	options.h	/^  const char *cert_file_inline;$/;"	m	struct:options
cert_hash	ssl_verify.h	/^struct cert_hash {$/;"	s
cert_hash_compare	ssl_verify.c	/^cert_hash_compare (const struct cert_hash_set *chs1, const struct cert_hash_set *chs2)$/;"	f	file:
cert_hash_copy	ssl_verify.c	/^cert_hash_copy (const struct cert_hash_set *chs)$/;"	f	file:
cert_hash_free	ssl_verify.c	/^cert_hash_free (struct cert_hash_set *chs)$/;"	f
cert_hash_remember	ssl_verify.c	/^cert_hash_remember (struct tls_session *session, const int error_depth, const unsigned char *sha1_hash)$/;"	f
cert_hash_set	ssl_common.h	/^  struct cert_hash_set *cert_hash_set;$/;"	m	struct:tls_session	typeref:struct:tls_session::cert_hash_set
cert_hash_set	ssl_verify.h	/^struct cert_hash_set {$/;"	s
cf_max	options.h	/^  int cf_max;$/;"	m	struct:options
cf_per	options.h	/^  int cf_per;$/;"	m	struct:options
cfb_ofb_mode	crypto.c	/^cfb_ofb_mode (const struct key_type* kt)$/;"	f
ch	ssl_verify.h	/^  struct cert_hash *ch[MAX_CERT_DEPTH]; \/**< Array of certificate hashes *\/$/;"	m	struct:cert_hash_set	typeref:struct:cert_hash_set::cert_hash
chaddr	dhcp.h	/^  uint8_t  chaddr[16]; \/* client hardware address *\/$/;"	m	struct:dhcp
challenge_text	misc.h	/^  const char *challenge_text;$/;"	m	struct:auth_challenge_info
challenge_text	misc.h	/^  const char *challenge_text;$/;"	m	struct:static_challenge_info
char_class	buffer.c	/^char_class (const unsigned char c, const unsigned int flags)$/;"	f
char_inc_exc	buffer.c	/^char_inc_exc (const char c, const unsigned int inclusive, const unsigned int exclusive)$/;"	f	file:
character_class_debug	buffer.c	/^character_class_debug (void)$/;"	f
check	proto.h	/^  uint16_t      check;$/;"	m	struct:openvpn_tcphdr
check	proto.h	/^  uint16_t   check;$/;"	m	struct:openvpn_iphdr
check	proto.h	/^  uint16_t   check;$/;"	m	struct:openvpn_udphdr
check_add_routes	forward-inline.h	/^check_add_routes (struct context *c)$/;"	f
check_add_routes_action	forward.c	/^check_add_routes_action (struct context *c, const bool errors)$/;"	f	file:
check_add_routes_dowork	forward.c	/^check_add_routes_dowork (struct context *c)$/;"	f
check_addr_clash	tun.c	/^check_addr_clash (const char *name,$/;"	f	file:
check_cmd_access	options.c	/^check_cmd_access(const char *command, const char *opt, const char *chroot)$/;"	f	file:
check_coarse_timers	forward.c	/^check_coarse_timers (struct context *c)$/;"	f	file:
check_coarse_timers_dowork	forward.c	/^check_coarse_timers_dowork (struct context *c)$/;"	f	file:
check_connection_established	forward-inline.h	/^check_connection_established (struct context *c)$/;"	f
check_connection_established_dowork	forward.c	/^check_connection_established_dowork (struct context *c)$/;"	f
check_debug_level	error.h	/^check_debug_level (unsigned int level)$/;"	f
check_file_access	options.c	/^check_file_access(const int type, const char *file, const int mode, const char *opt)$/;"	f	file:
check_file_access_chroot	options.c	/^check_file_access_chroot(const char *chroot, const int type, const char *file, const int mode, const char *opt)$/;"	f	file:
check_fragment	forward-inline.h	/^check_fragment (struct context *c)$/;"	f
check_fragment_dowork	forward.c	/^check_fragment_dowork (struct context *c)$/;"	f
check_inactivity_timeout	forward-inline.h	/^check_inactivity_timeout (struct context *c)$/;"	f
check_inactivity_timeout_dowork	forward.c	/^check_inactivity_timeout_dowork (struct context *c)$/;"	f
check_incoming_control_channel	forward-inline.h	/^check_incoming_control_channel (struct context *c)$/;"	f
check_incoming_control_channel_dowork	forward.c	/^check_incoming_control_channel_dowork (struct context *c)$/;"	f
check_inline_file	options.c	/^check_inline_file (struct in_src *is, char *p[], struct gc_arena *gc)$/;"	f	file:
check_inline_file_via_buf	options.c	/^check_inline_file_via_buf (struct buffer *multiline, char *p[], struct gc_arena *gc)$/;"	f	file:
check_inline_file_via_fp	options.c	/^check_inline_file_via_fp (FILE *fp, char *p[], struct gc_arena *gc)$/;"	f	file:
check_key	crypto.c	/^check_key (struct key *key, const struct key_type *kt)$/;"	f
check_malloc_return	buffer.h	/^check_malloc_return (void *p)$/;"	f
check_packet_id_persist_flush	forward-inline.h	/^check_packet_id_persist_flush (struct context *c)$/;"	f
check_ping_restart	ping-inline.h	/^check_ping_restart (struct context *c)$/;"	f
check_ping_restart_dowork	ping.c	/^check_ping_restart_dowork (struct context *c)$/;"	f
check_ping_send	ping-inline.h	/^check_ping_send (struct context *c)$/;"	f
check_ping_send_dowork	ping.c	/^check_ping_send_dowork (struct context *c)$/;"	f
check_push_request	forward-inline.h	/^check_push_request (struct context *c)$/;"	f
check_push_request_dowork	forward.c	/^check_push_request_dowork (struct context *c)$/;"	f
check_replay_iv_consistency	crypto.c	/^check_replay_iv_consistency (const struct key_type *kt, bool packet_id, bool use_iv)$/;"	f
check_scheduled_exit	forward-inline.h	/^check_scheduled_exit (struct context *c)$/;"	f
check_scheduled_exit_dowork	forward.c	/^check_scheduled_exit_dowork (struct context *c)$/;"	f
check_send_occ_load_test	occ-inline.h	/^check_send_occ_load_test (struct context *c)$/;"	f
check_send_occ_load_test_dowork	occ.c	/^check_send_occ_load_test_dowork (struct context *c)$/;"	f
check_send_occ_msg	occ-inline.h	/^check_send_occ_msg (struct context *c)$/;"	f
check_send_occ_msg_dowork	occ.c	/^check_send_occ_msg_dowork (struct context *c)$/;"	f
check_send_occ_req	occ-inline.h	/^check_send_occ_req (struct context *c)$/;"	f
check_send_occ_req_dowork	occ.c	/^check_send_occ_req_dowork (struct context *c)$/;"	f
check_server_poll_timeout	forward-inline.h	/^check_server_poll_timeout (struct context *c)$/;"	f
check_server_poll_timeout_dowork	forward.c	/^check_server_poll_timeout_dowork (struct context *c)$/;"	f
check_stale_routes	multi.c	/^check_stale_routes (struct multi_context *m)$/;"	f	file:
check_status	error.h	/^check_status (int status, const char *description, struct link_socket *sock, struct tuntap *tt)$/;"	f
check_status_file	forward-inline.h	/^check_status_file (struct context *c)$/;"	f
check_status_file_dowork	forward.c	/^check_status_file_dowork (struct context *c)$/;"	f
check_subnet_conflict	tun.c	/^check_subnet_conflict (const in_addr_t ip,$/;"	f
check_systemd_running	console.c	/^check_systemd_running ()$/;"	f	file:
check_timeout_random_component	forward.c	/^check_timeout_random_component (struct context *c)$/;"	f	file:
check_timeout_random_component_dowork	forward.c	/^check_timeout_random_component_dowork (struct context *c)$/;"	f	file:
check_timestamp_delta	packet_id.h	/^check_timestamp_delta (time_t remote, unsigned int max_delta)$/;"	f
check_tls	forward-inline.h	/^check_tls (struct context *c)$/;"	f
check_tls_dowork	forward.c	/^check_tls_dowork (struct context *c)$/;"	f
check_tls_errors	forward-inline.h	/^check_tls_errors (struct context *c)$/;"	f
check_tls_errors_co	forward.c	/^check_tls_errors_co (struct context *c)$/;"	f
check_tls_errors_nco	forward.c	/^check_tls_errors_nco (struct context *c)$/;"	f
chomp	buffer.c	/^chomp (char *str)$/;"	f
chroot_dir	options.h	/^  const char *chroot_dir;$/;"	m	struct:options
ciaddr	dhcp.h	/^  uint32_t ciaddr;     \/* client IP address, client sets if known *\/$/;"	m	struct:dhcp
cid	manage.h	/^  unsigned long cid;$/;"	m	struct:man_def_auth_context
cid_compare_function	multi.c	/^cid_compare_function (const void *key1, const void *key2)$/;"	f	file:
cid_counter	multi.h	/^  unsigned long cid_counter;$/;"	m	struct:multi_context
cid_hash	multi.h	/^  struct hash *cid_hash;$/;"	m	struct:multi_context	typeref:struct:multi_context::hash
cid_hash_function	multi.c	/^cid_hash_function (const void *key, uint32_t iv)$/;"	f	file:
cipher	crypto.h	/^  cipher_ctx_t *cipher;      	\/**< Generic cipher %context. *\/$/;"	m	struct:key_ctx
cipher	crypto.h	/^  const cipher_kt_t *cipher;	\/**< Cipher static parameters *\/$/;"	m	struct:key_type
cipher	crypto.h	/^  uint8_t cipher[MAX_CIPHER_KEY_LENGTH];$/;"	m	struct:key
cipher_ctx_block_size	crypto_openssl.c	/^cipher_ctx_block_size(const EVP_CIPHER_CTX *ctx)$/;"	f
cipher_ctx_block_size	crypto_polarssl.c	/^int cipher_ctx_block_size(const cipher_context_t *ctx)$/;"	f
cipher_ctx_cleanup	crypto_openssl.c	/^cipher_ctx_cleanup (EVP_CIPHER_CTX *ctx)$/;"	f
cipher_ctx_cleanup	crypto_polarssl.c	/^void cipher_ctx_cleanup (cipher_context_t *ctx)$/;"	f
cipher_ctx_final	crypto_openssl.c	/^cipher_ctx_final (EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len)$/;"	f
cipher_ctx_final	crypto_polarssl.c	/^int cipher_ctx_final (cipher_context_t *ctx, uint8_t *dst, int *dst_len)$/;"	f
cipher_ctx_init	crypto_openssl.c	/^cipher_ctx_init (EVP_CIPHER_CTX *ctx, uint8_t *key, int key_len,$/;"	f
cipher_ctx_init	crypto_polarssl.c	/^cipher_ctx_init (cipher_context_t *ctx, uint8_t *key, int key_len,$/;"	f
cipher_ctx_iv_length	crypto_openssl.c	/^cipher_ctx_iv_length (const EVP_CIPHER_CTX *ctx)$/;"	f
cipher_ctx_iv_length	crypto_polarssl.c	/^int cipher_ctx_iv_length (const cipher_context_t *ctx)$/;"	f
cipher_ctx_mode	crypto_openssl.c	/^cipher_ctx_mode (const EVP_CIPHER_CTX *ctx)$/;"	f
cipher_ctx_mode	crypto_polarssl.c	/^int cipher_ctx_mode (const cipher_context_t *ctx)$/;"	f
cipher_ctx_reset	crypto_openssl.c	/^cipher_ctx_reset (EVP_CIPHER_CTX *ctx, uint8_t *iv_buf)$/;"	f
cipher_ctx_reset	crypto_polarssl.c	/^int cipher_ctx_reset (cipher_context_t *ctx, uint8_t *iv_buf)$/;"	f
cipher_ctx_t	crypto_openssl.h	/^typedef EVP_CIPHER_CTX cipher_ctx_t;$/;"	t
cipher_ctx_t	crypto_polarssl.h	/^typedef cipher_context_t cipher_ctx_t;$/;"	t
cipher_ctx_update	crypto_openssl.c	/^cipher_ctx_update (EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len,$/;"	f
cipher_ctx_update	crypto_polarssl.c	/^int cipher_ctx_update (cipher_context_t *ctx, uint8_t *dst, int *dst_len,$/;"	f
cipher_des_encrypt_ecb	crypto_openssl.c	/^cipher_des_encrypt_ecb (const unsigned char key[DES_KEY_LENGTH],$/;"	f
cipher_des_encrypt_ecb	crypto_polarssl.c	/^cipher_des_encrypt_ecb (const unsigned char key[DES_KEY_LENGTH],$/;"	f
cipher_kt_block_size	crypto_openssl.c	/^cipher_kt_block_size (const EVP_CIPHER *cipher_kt)$/;"	f
cipher_kt_block_size	crypto_polarssl.c	/^cipher_kt_block_size (const cipher_info_t *cipher_kt)$/;"	f
cipher_kt_get	crypto_openssl.c	/^cipher_kt_get (const char *ciphername)$/;"	f
cipher_kt_get	crypto_polarssl.c	/^cipher_kt_get (const char *ciphername)$/;"	f
cipher_kt_iv_size	crypto_openssl.c	/^cipher_kt_iv_size (const EVP_CIPHER *cipher_kt)$/;"	f
cipher_kt_iv_size	crypto_polarssl.c	/^cipher_kt_iv_size (const cipher_info_t *cipher_kt)$/;"	f
cipher_kt_key_size	crypto_openssl.c	/^cipher_kt_key_size (const EVP_CIPHER *cipher_kt)$/;"	f
cipher_kt_key_size	crypto_polarssl.c	/^cipher_kt_key_size (const cipher_info_t *cipher_kt)$/;"	f
cipher_kt_mode	crypto_openssl.c	/^cipher_kt_mode (const EVP_CIPHER *cipher_kt)$/;"	f
cipher_kt_mode	crypto_polarssl.c	/^cipher_kt_mode (const cipher_info_t *cipher_kt)$/;"	f
cipher_kt_name	crypto_openssl.c	/^cipher_kt_name (const EVP_CIPHER *cipher_kt)$/;"	f
cipher_kt_name	crypto_polarssl.c	/^cipher_kt_name (const cipher_info_t *cipher_kt)$/;"	f
cipher_kt_t	crypto_openssl.h	/^typedef EVP_CIPHER cipher_kt_t;$/;"	t
cipher_kt_t	crypto_polarssl.h	/^typedef cipher_info_t cipher_kt_t;$/;"	t
cipher_length	crypto.h	/^  uint8_t cipher_length; 	\/**< Cipher length, in bytes *\/$/;"	m	struct:key_type
cipher_list	options.h	/^  const char *cipher_list;$/;"	m	struct:options
cipher_name_pair	crypto_polarssl.c	/^typedef struct { const char * openvpn_name; const char * polarssl_name; } cipher_name_pair;$/;"	t	typeref:struct:__anon4	file:
cipher_name_translation_table	crypto_polarssl.c	/^cipher_name_pair cipher_name_translation_table[] = {$/;"	v
cipher_ok	crypto_openssl.c	/^cipher_ok (const char* name)$/;"	f	file:
ciphername	options.h	/^  const char *ciphername;$/;"	m	struct:options
ciphername_defined	options.h	/^  bool ciphername_defined;$/;"	m	struct:options
clear_buf	buffer.c	/^clear_buf ()$/;"	f
clear_prefix	multi.h	/^clear_prefix (void)$/;"	f
clear_route_ipv6_list	route.c	/^clear_route_ipv6_list (struct route_ipv6_list *rl6)$/;"	f
clear_route_list	route.c	/^clear_route_list (struct route_list *rl)$/;"	f
clear_tuntap	tun.c	/^clear_tuntap (struct tuntap *tuntap)$/;"	f	file:
clear_user_pass_http	proxy.c	/^clear_user_pass_http (void)$/;"	f	file:
client	options.h	/^  bool client;$/;"	m	struct:options
client	ssl_common.h	/^  struct key_source client;     \/**< Random provided by client. *\/$/;"	m	struct:key_source2	typeref:struct:key_source2::key_source
client_auth	manage.h	/^  bool (*client_auth) (void *arg,$/;"	m	struct:management_callback
client_config_dir	options.h	/^  const char *client_config_dir;$/;"	m	struct:options
client_config_dir_exclusive	ssl_common.h	/^  const char *client_config_dir_exclusive;$/;"	m	struct:tls_options
client_connect_script	options.h	/^  const char *client_connect_script;$/;"	m	struct:options
client_constructor	plugin.h	/^  openvpn_plugin_client_constructor_v1 client_constructor;$/;"	m	struct:plugin
client_destructor	plugin.h	/^  openvpn_plugin_client_destructor_v1 client_destructor;$/;"	m	struct:plugin
client_disconnect_script	options.h	/^  const char *client_disconnect_script;$/;"	m	struct:options
client_gid	manage.h	/^  int client_gid;$/;"	m	struct:man_settings
client_nat	options.h	/^  struct client_nat_option_list *client_nat;$/;"	m	struct:options	typeref:struct:options::client_nat_option_list
client_nat	options.h	/^  struct client_nat_option_list *client_nat;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::client_nat_option_list
client_nat_defined	options.h	/^  bool client_nat_defined;$/;"	m	struct:options_pre_pull
client_nat_entry	clinat.h	/^struct client_nat_entry {$/;"	s
client_nat_option_list	clinat.h	/^struct client_nat_option_list {$/;"	s
client_nat_transform	clinat.c	/^client_nat_transform (const struct client_nat_option_list *list,$/;"	f
client_pf	manage.h	/^  bool (*client_pf) (void *arg,$/;"	m	struct:management_callback
client_reason	ssl_common.h	/^  char *client_reason;$/;"	m	struct:tls_multi
client_uid	manage.h	/^  int client_uid;$/;"	m	struct:man_settings
clone_buf	buffer.h	143;"	d
clone_buf_debug	buffer.c	/^clone_buf_debug (const struct buffer* buf, const char *file, int line)$/;"	f
clone_client_nat_option_list	clinat.c	/^clone_client_nat_option_list (const struct client_nat_option_list *src, struct gc_arena *gc)$/;"	f
clone_push_list	push.c	/^clone_push_list (struct options *o)$/;"	f
clone_route_ipv6_option_list	route.c	/^clone_route_ipv6_option_list (const struct route_ipv6_option_list *src, struct gc_arena *a)$/;"	f
clone_route_option_list	route.c	/^clone_route_option_list (const struct route_option_list *src, struct gc_arena *a)$/;"	f
close	plugin.h	/^  openvpn_plugin_close_v1 close;$/;"	m	struct:plugin
close_biofp	ssl_openssl.c	/^close_biofp()$/;"	f	file:
close_context	init.c	/^close_context (struct context *c, int sig, unsigned int flags)$/;"	f
close_fds_except	ps.c	/^close_fds_except (int keep)$/;"	f	file:
close_instance	init.c	/^close_instance (struct context *c)$/;"	f
close_management	init.c	/^close_management (void)$/;"	f
close_net_event_win32	win32.c	/^close_net_event_win32 (struct rw_handle *event, socket_descriptor_t sd, unsigned int flags)$/;"	f
close_port_share	init.c	/^close_port_share (void)$/;"	f	file:
close_socket_if_defined	ps.c	/^close_socket_if_defined (const socket_descriptor_t sd)$/;"	f	file:
close_syslog	error.c	/^close_syslog ()$/;"	f
close_tty	console.c	/^close_tty (FILE *fp)$/;"	f	file:
close_tun	tun.c	/^close_tun (struct tuntap *tt)$/;"	f
close_tun	tun.c	/^close_tun (struct tuntap* tt)$/;"	f
close_tun_generic	tun.c	/^close_tun_generic (struct tuntap *tt)$/;"	f	file:
cmp_prefix	win32.c	/^cmp_prefix (const char *str, const bool n, const char *pre)$/;"	f	file:
cmsg_size	ps.c	/^cmsg_size ()$/;"	f	file:
cmsghdr	socket.c	/^  struct cmsghdr cmsghdr;$/;"	m	struct:openvpn_in4_pktinfo	typeref:struct:openvpn_in4_pktinfo::cmsghdr	file:
cmsghdr	socket.c	/^  struct cmsghdr cmsghdr;$/;"	m	struct:openvpn_in6_pktinfo	typeref:struct:openvpn_in6_pktinfo::cmsghdr	file:
cn	pf.h	/^  char *cn;$/;"	m	struct:pf_cn
cn_compare_function	pf.c	/^cn_compare_function (const void *key1, const void *key2)$/;"	f	file:
cn_hash_function	pf.c	/^cn_hash_function (const void *key, uint32_t iv)$/;"	f	file:
cnol_check_alloc	options.c	/^cnol_check_alloc (struct options *options)$/;"	f	file:
cns	pf.h	/^  struct pf_cn_set cns;$/;"	m	struct:pf_set	typeref:struct:pf_set::pf_cn_set
coarse_timer_wakeup	openvpn.h	/^  time_t coarse_timer_wakeup;$/;"	m	struct:context_2
coll	schedule.c	/^  int coll;$/;"	m	struct:status	file:
command_line	manage.h	/^struct command_line$/;"	s
command_line_add	manage.c	/^command_line_add (struct command_line *cl, const unsigned char *buf, const int len)$/;"	f
command_line_free	manage.c	/^command_line_free (struct command_line *cl)$/;"	f
command_line_get	manage.c	/^command_line_get (struct command_line *cl)$/;"	f
command_line_new	manage.c	/^command_line_new (const int buf_len)$/;"	f
command_line_next	manage.c	/^command_line_next (struct command_line *cl)$/;"	f
command_line_reset	manage.c	/^command_line_reset (struct command_line *cl)$/;"	f
common	plugin.h	/^  struct plugin_common *common;$/;"	m	struct:plugin_list	typeref:struct:plugin_list::plugin_common
common_name	pool.h	/^  char *common_name;$/;"	m	struct:ifconfig_pool_entry
common_name	ssl_common.h	/^  char *common_name;$/;"	m	struct:tls_session
common_name_hashval	ssl_common.h	/^  uint32_t common_name_hashval;$/;"	m	struct:tls_session
common_owned	plugin.h	/^  bool common_owned;$/;"	m	struct:plugin_list
compare_function	list.h	/^  bool (*compare_function)(const void *key1, const void *key2); \/* return true if equal *\/$/;"	m	struct:hash
compat_flag	misc.c	/^compat_flag (unsigned int flag)$/;"	f
compress_state	lzo.h	/^  bool compress_state;$/;"	m	struct:lzo_adaptive_compress
compute_earliest_wakeup	ssl.c	/^compute_earliest_wakeup (interval_t *earliest, interval_t seconds_from_now) {$/;"	f	file:
compute_wakeup_sigma	multi.c	/^compute_wakeup_sigma (const struct timeval *delta)$/;"	f	file:
config	options.h	/^  const char *config;$/;"	m	struct:options
connect_retry_defined	options.h	/^  bool connect_retry_defined;$/;"	m	struct:connection_entry
connect_retry_max	options.h	/^  int connect_retry_max;$/;"	m	struct:connection_entry
connect_retry_max	socket.h	/^  int connect_retry_max;$/;"	m	struct:link_socket
connect_retry_seconds	options.h	/^  int connect_retry_seconds;$/;"	m	struct:connection_entry
connect_retry_seconds	socket.h	/^  int connect_retry_seconds;$/;"	m	struct:link_socket
connect_timeout	options.h	/^  int connect_timeout;$/;"	m	struct:connection_entry
connect_timeout	socket.h	/^  int connect_timeout;$/;"	m	struct:link_socket
connect_timeout_defined	options.h	/^  bool connect_timeout_defined;$/;"	m	struct:connection_entry
connection	manage.h	/^  struct man_connection connection;$/;"	m	struct:management	typeref:struct:management::man_connection
connection_entry	options.h	/^struct connection_entry$/;"	s
connection_entry_load_re	options.c	/^connection_entry_load_re (struct connection_entry *ce, const struct remote_entry *re)$/;"	f
connection_established	socket.h	/^  bool connection_established;$/;"	m	struct:link_socket_info
connection_established_flag	multi.h	/^  bool connection_established_flag;$/;"	m	struct:multi_instance
connection_list	options.h	/^  struct connection_list *connection_list;$/;"	m	struct:options	typeref:struct:options::connection_list
connection_list	options.h	/^struct connection_list$/;"	s
connection_list_defined	options.h	/^connection_list_defined (const struct options *o)$/;"	f
connection_list_set_no_advance	options.h	/^connection_list_set_no_advance (struct options *o)$/;"	f
connection_profiles_defined	socket.h	/^  bool connection_profiles_defined;$/;"	m	struct:link_socket
console_mode_save	win32.h	/^  DWORD console_mode_save;$/;"	m	struct:win32_signal
console_mode_save_defined	win32.h	/^  bool console_mode_save_defined;$/;"	m	struct:win32_signal
constrain_int	integer.h	/^constrain_int (int x, int min, int max)$/;"	f
construct_name_value	misc.c	/^construct_name_value (const char *name, const char *value, struct gc_arena *gc)$/;"	f	file:
context	multi.h	/^  struct context context;       \/**< The context structure storing state$/;"	m	struct:multi_instance	typeref:struct:multi_instance::context
context	openvpn.h	/^struct context$/;"	s
context_0	openvpn.h	/^struct context_0$/;"	s
context_1	openvpn.h	/^struct context_1$/;"	s
context_2	openvpn.h	/^struct context_2$/;"	s
context_auth	openvpn.h	/^  int context_auth;$/;"	m	struct:context_2
context_buffers	multi.h	/^  struct context_buffers *context_buffers;$/;"	m	struct:multi_context	typeref:struct:multi_context::context_buffers
context_buffers	openvpn.h	/^struct context_buffers$/;"	s
context_clear	init.c	/^context_clear (struct context *c)$/;"	f
context_clear_1	init.c	/^context_clear_1 (struct context *c)$/;"	f
context_clear_2	init.c	/^context_clear_2 (struct context *c)$/;"	f
context_clear_all_except_first_time	init.c	/^context_clear_all_except_first_time (struct context *c)$/;"	f
context_gc_free	init.c	/^context_gc_free (struct context *c)$/;"	f
context_immediate_reschedule	forward-inline.h	/^context_immediate_reschedule (struct context *c)$/;"	f
context_init_1	init.c	/^context_init_1 (struct context *c)$/;"	f
context_persist	openvpn.h	/^struct context_persist$/;"	s
context_reschedule_sec	forward-inline.h	/^context_reschedule_sec (struct context *c, int sec)$/;"	f
control_message_from_parent	ps.c	/^control_message_from_parent (const socket_descriptor_t sd_control,$/;"	f	file:
convert_to_one_line	buffer.c	/^convert_to_one_line (struct buffer *buf)$/;"	f
copy_client_nat_option_list	clinat.c	/^copy_client_nat_option_list (struct client_nat_option_list *dest,$/;"	f
copy_route_ipv6_option_list	route.c	/^copy_route_ipv6_option_list (struct route_ipv6_option_list *dest,$/;"	f
copy_route_option_list	route.c	/^copy_route_option_list (struct route_option_list *dest, const struct route_option_list *src)$/;"	f
corrupt_freq	gremlin.c	/^static const int corrupt_freq[] = { 500, 100, 50 };$/;"	v	file:
corrupt_gremlin	gremlin.c	/^void corrupt_gremlin (struct buffer *buf, int flags) {$/;"	f
count	perf.c	/^  double count;$/;"	m	struct:perf	file:
count_bits	misc.c	/^count_bits(unsigned int a)$/;"	f
count_netmask_bits	misc.c	/^count_netmask_bits(const char *dotted_quad)$/;"	f
counter_format	common.h	34;"	d
counter_format	common.h	36;"	d
counter_format	common.h	40;"	d
counter_type	common.h	/^  typedef unsigned int counter_type;$/;"	t
counter_type	common.h	/^  typedef unsigned long long int counter_type;$/;"	t
counterpart	ps.c	/^  struct proxy_connection *counterpart;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::proxy_connection	file:
crash	error.c	/^crash (void)$/;"	f
create_des_keys	ntlm.c	/^create_des_keys(const unsigned char *hash, unsigned char *key)$/;"	f	file:
create_socket	socket.c	/^create_socket (struct link_socket *sock)$/;"	f	file:
create_socket_tcp	socket.c	/^create_socket_tcp (int af)$/;"	f
create_socket_udp	socket.c	/^create_socket_udp (const unsigned int flags)$/;"	f	file:
create_socket_udp6	socket.c	/^create_socket_udp6 (const unsigned int flags)$/;"	f	file:
create_socket_unix	socket.c	/^create_socket_unix (void)$/;"	f
create_temp_file	misc.c	/^create_temp_file (const char *directory, const char *prefix, struct gc_arena *gc)$/;"	f
created	multi.h	/^  time_t created;               \/**< Time at which a VPN tunnel instance$/;"	m	struct:multi_instance
crl_file	options.h	/^  const char *crl_file;$/;"	m	struct:options
crl_file	ssl_common.h	/^  const char *crl_file;$/;"	m	struct:tls_options
crt_chain	ssl_polarssl.h	/^    x509_cert *crt_chain;	\/**< Local Certificate chain *\/$/;"	m	struct:tls_root_ctx
crypt_prov	cryptoapi.c	/^    HCRYPTPROV crypt_prov;$/;"	m	struct:_CAPI_DATA	file:
crypto_adjust_frame_parameters	crypto.c	/^crypto_adjust_frame_parameters(struct frame *frame,$/;"	f
crypto_clear_error	crypto_openssl.c	/^crypto_clear_error (void)$/;"	f
crypto_clear_error	crypto_polarssl.c	/^crypto_clear_error (void)$/;"	f
crypto_flags_and	ssl_common.h	/^  unsigned int crypto_flags_and;$/;"	m	struct:tls_options
crypto_flags_or	ssl_common.h	/^  unsigned int crypto_flags_or;$/;"	m	struct:tls_options
crypto_free	crypto_openssl.c	/^crypto_free (void *ptr)$/;"	f	file:
crypto_init_dmalloc	crypto_openssl.c	/^crypto_init_dmalloc (void)$/;"	f
crypto_init_dmalloc	crypto_polarssl.c	/^crypto_init_dmalloc (void)$/;"	f
crypto_init_lib	crypto_openssl.c	/^crypto_init_lib (void)$/;"	f
crypto_init_lib	crypto_polarssl.c	/^crypto_init_lib (void)$/;"	f
crypto_init_lib_engine	crypto_openssl.c	/^crypto_init_lib_engine (const char *engine_name)$/;"	f
crypto_init_lib_engine	crypto_polarssl.c	/^crypto_init_lib_engine (const char *engine_name)$/;"	f
crypto_malloc	crypto_openssl.c	/^crypto_malloc (size_t size, const char *file, int line)$/;"	f	file:
crypto_options	crypto.h	/^struct crypto_options$/;"	s
crypto_options	openvpn.h	/^  struct crypto_options crypto_options;$/;"	m	struct:context_2	typeref:struct:context_2::crypto_options
crypto_realloc	crypto_openssl.c	/^crypto_realloc (void *ptr, size_t size, const char *file, int line)$/;"	f	file:
crypto_uninit_lib	crypto_openssl.c	/^crypto_uninit_lib (void)$/;"	f
crypto_uninit_lib	crypto_polarssl.c	/^crypto_uninit_lib (void)$/;"	f
cryptoapi_cert	options.h	/^  const char *cryptoapi_cert;$/;"	m	struct:options
ct_in	ssl_openssl.h	/^    BIO *ct_in;			\/* write ciphertext to here *\/$/;"	m	struct:key_state_ssl
ct_in	ssl_polarssl.h	/^        endless_buffer *ct_in;$/;"	m	struct:key_state_ssl
ct_out	ssl_openssl.h	/^    BIO *ct_out;			\/* read ciphertext from here *\/$/;"	m	struct:key_state_ssl
ct_out	ssl_polarssl.h	/^        endless_buffer *ct_out;$/;"	m	struct:key_state_ssl
ctl	event.h	/^  void (*ctl)(struct event_set *es, event_t event, unsigned int rwflags, void *arg);$/;"	m	struct:event_set_functions
ctrl_sd	socket.h	/^  socket_descriptor_t ctrl_sd;  \/* only used for UDP over Socks *\/$/;"	m	struct:link_socket
ctx	crypto.h	/^  md_ctx_t ctx;$/;"	m	struct:md5_state
ctx	ssl_openssl.h	/^    SSL_CTX *ctx;$/;"	m	struct:tls_root_ctx
ctx	ssl_polarssl.h	/^        ssl_context *ctx;$/;"	m	struct:key_state_ssl
current	options.h	/^  int current;$/;"	m	struct:connection_list
daddr	proto.h	/^        struct  in6_addr        daddr;$/;"	m	struct:openvpn_ipv6hdr	typeref:struct:openvpn_ipv6hdr::in6_addr
daddr	proto.h	/^  uint32_t   daddr;$/;"	m	struct:openvpn_iphdr
daemon	options.h	/^  bool daemon;$/;"	m	struct:options
data	buffer.h	/^  uint8_t *data;                \/**< Pointer to the allocated memory. *\/$/;"	m	struct:buffer
data	ssl_polarssl.h	/^    uint8_t *data;$/;"	m	struct:_buffer_entry
data_start	ssl_polarssl.h	/^    size_t data_start;$/;"	m	struct:__anon2
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datagram_overhead	socket.h	/^datagram_overhead (int proto)$/;"	f
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
debug_file	buffer.h	/^  const char *debug_file;$/;"	m	struct:buffer
debug_line	buffer.h	/^  int debug_line;$/;"	m	struct:buffer
deconstruct_name_value	misc.c	/^deconstruct_name_value (const char *str, const char **name, const char **value, struct gc_arena *gc)$/;"	f
decrypt	crypto.h	/^  struct key_ctx decrypt;       \/**< OpenSSL cipher and\/or HMAC contexts$/;"	m	struct:key_ctx_bi	typeref:struct:key_ctx_bi::key_ctx
decrypt_buf	openvpn.h	/^  struct buffer decrypt_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
default_allow	pf.h	/^  bool default_allow;$/;"	m	struct:pf_cn_set
default_allow	pf.h	/^  bool default_allow;$/;"	m	struct:pf_subnet_set
default_err	error.c	/^static FILE *default_err; \/* GLOBAL *\/$/;"	v	file:
default_metric	route.h	/^  int default_metric;$/;"	m	struct:route_ipv6_list
default_metric	route.h	/^  int default_metric;$/;"	m	struct:route_special_addr
default_metric_defined	route.h	/^  bool default_metric_defined;$/;"	m	struct:route_ipv6_list
default_out	error.c	/^static FILE *default_out; \/* GLOBAL *\/$/;"	v	file:
defined	fragment.h	/^  bool defined;                 \/**< Whether reassembly is currently$/;"	m	struct:fragment
defined	interval.h	/^  bool defined;$/;"	m	struct:event_timeout
defined	lzo.h	/^  bool defined;$/;"	m	struct:lzo_compress_workspace
defined	manage.h	/^  bool defined;$/;"	m	struct:man_persist
defined	manage.h	/^  bool defined;$/;"	m	struct:man_settings
defined	misc.h	/^  bool defined;$/;"	m	struct:user_pass
defined	multi.h	/^  bool defined;$/;"	m	struct:multi_instance
defined	proxy.h	/^  bool defined;$/;"	m	struct:http_proxy_info
defined	ps.c	/^  bool defined;$/;"	m	struct:proxy_connection	file:
defined	route.h	/^  bool defined;$/;"	m	struct:route_ipv6
defined	socks.h	/^  bool defined;$/;"	m	struct:socks_proxy_info
defined_net_event_win32	win32.h	/^defined_net_event_win32 (const struct rw_handle *event)$/;"	f
del	event.h	/^  void (*del)(struct event_set *es, event_t event);$/;"	m	struct:event_set_functions
del_bypass_routes	route.c	/^del_bypass_routes (struct route_bypass *rb,$/;"	f	file:
del_route3	route.c	/^del_route3 (in_addr_t network,$/;"	f	file:
del_route_ipapi	route.c	/^del_route_ipapi (const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f
delete_event	manage.h	/^  void (*delete_event) (void *arg, event_t event);$/;"	m	struct:management_callback
delete_route	route.c	/^delete_route (struct route_ipv4 *r,$/;"	f	file:
delete_route_connected_v6_net	tun.c	/^void delete_route_connected_v6_net(struct tuntap * tt,$/;"	f
delete_route_ipv6	route.c	/^delete_route_ipv6 (const struct route_ipv6 *r6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f
delete_routes	route.c	/^delete_routes (struct route_list *rl, struct route_ipv6_list *rl6,$/;"	f
delete_temp_addresses	tun.c	/^delete_temp_addresses (DWORD index)$/;"	f	file:
delta	occ.h	/^  int delta;			\/* determine packet size to send by using$/;"	m	struct:mtu_load_test
depcomp	Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
dest	proto.h	/^  uint16_t      dest;      \/* destination port *\/$/;"	m	struct:openvpn_tcphdr
dest	proto.h	/^  uint16_t   dest;$/;"	m	struct:openvpn_udphdr
dest	proto.h	/^  uint8_t dest[OPENVPN_ETH_ALEN];     \/* destination ethernet addr *\/$/;"	m	struct:openvpn_ethhdr
dest	socket.h	/^  struct openvpn_sockaddr dest;$/;"	m	struct:link_socket_actual	typeref:struct:link_socket_actual::openvpn_sockaddr
dev	options.h	/^  const char *dev;$/;"	m	struct:options
dev_node	options.h	/^  const char *dev_node;$/;"	m	struct:options
dev_type	options.h	/^  const char *dev_type;$/;"	m	struct:options
dev_type_enum	tun.c	/^dev_type_enum (const char *dev, const char *dev_type)$/;"	f
dev_type_string	tun.c	/^dev_type_string (const char *dev, const char *dev_type)$/;"	f
dh_file	options.h	/^  const char *dh_file;$/;"	m	struct:options
dh_file_inline	options.h	/^  const char *dh_file_inline;$/;"	m	struct:options
dhcp	dhcp.h	/^  struct dhcp dhcp;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::dhcp
dhcp	dhcp.h	/^struct dhcp {$/;"	s
dhcp_extract_router_msg	dhcp.c	/^dhcp_extract_router_msg (struct buffer *ipbuf)$/;"	f
dhcp_full	dhcp.h	/^struct dhcp_full {$/;"	s
dhcp_lease_time	tun.h	/^  int dhcp_lease_time;$/;"	m	struct:tuntap_options
dhcp_masq_addr	tun.c	/^dhcp_masq_addr (const in_addr_t local, const in_addr_t netmask, const int offset)$/;"	f	file:
dhcp_masq_custom_offset	tun.h	/^  bool dhcp_masq_custom_offset;$/;"	m	struct:tuntap_options
dhcp_masq_offset	tun.h	/^  int dhcp_masq_offset;$/;"	m	struct:tuntap_options
dhcp_option_address_parse	options.c	/^dhcp_option_address_parse (const char *name, const char *parm, in_addr_t *array, int *len, int msglevel)$/;"	f	file:
dhcp_options	tun.h	/^  bool dhcp_options;$/;"	m	struct:tuntap_options
dhcp_pre_release	tun.h	/^  bool dhcp_pre_release;$/;"	m	struct:tuntap_options
dhcp_release	tun.c	/^dhcp_release (const struct tuntap *tt)$/;"	f	file:
dhcp_release	tun.h	/^  bool dhcp_release;$/;"	m	struct:tuntap_options
dhcp_release_by_adapter_index	tun.c	/^dhcp_release_by_adapter_index(const DWORD adapter_index)$/;"	f
dhcp_renew	tun.c	/^dhcp_renew (const struct tuntap *tt)$/;"	f	file:
dhcp_renew	tun.h	/^  bool dhcp_renew;$/;"	m	struct:tuntap_options
dhcp_renew_by_adapter_index	tun.c	/^dhcp_renew_by_adapter_index (const DWORD adapter_index)$/;"	f
dhcp_status	tun.c	/^dhcp_status (DWORD index)$/;"	f	file:
dhm_ctx	ssl_polarssl.h	/^    dhm_context *dhm_ctx;	\/**< Diffie-Helmann-Merkle context *\/$/;"	m	struct:tls_root_ctx
did_cid_hash	multi.h	/^  bool did_cid_hash;$/;"	m	struct:multi_instance
did_ifconfig	tun.h	/^  bool did_ifconfig;$/;"	m	struct:tuntap
did_ifconfig_ipv6_setup	tun.h	/^  bool did_ifconfig_ipv6_setup;$/;"	m	struct:tuntap
did_ifconfig_setup	tun.h	/^  bool did_ifconfig_setup;$/;"	m	struct:tuntap
did_iroutes	multi.h	/^  bool did_iroutes;$/;"	m	struct:multi_instance
did_iter	multi.h	/^  bool did_iter;$/;"	m	struct:multi_instance
did_local	route.h	/^  bool did_local;					\/* TODO (?) *\/$/;"	m	struct:route_ipv6_list
did_open_context	multi.h	/^  bool did_open_context;$/;"	m	struct:multi_instance
did_open_tun	openvpn.h	/^  bool did_open_tun;$/;"	m	struct:context_2
did_pre_pull_restore	openvpn.h	/^  bool did_pre_pull_restore;$/;"	m	struct:context_2
did_real_hash	multi.h	/^  bool did_real_hash;$/;"	m	struct:multi_instance
did_redirect_default_gateway	route.h	/^  bool did_redirect_default_gateway;			\/* TODO (?) *\/$/;"	m	struct:route_ipv6_list
did_resolve_remote	socket.h	/^  bool did_resolve_remote;$/;"	m	struct:link_socket
did_we_daemonize	openvpn.h	/^  bool did_we_daemonize;        \/**< Whether demonization has already$/;"	m	struct:context
digest	crypto.h	/^  const md_kt_t *digest;	\/**< Message digest static parameters *\/$/;"	m	struct:key_type
digest	crypto.h	/^  uint8_t digest [MD5_DIGEST_LENGTH];$/;"	m	struct:md5_digest
disable	options.h	/^  bool disable;$/;"	m	struct:options
disable_nbt	tun.h	/^  bool disable_nbt;$/;"	m	struct:tuntap_options
disable_occ	ssl_common.h	/^  bool disable_occ;$/;"	m	struct:tls_options
display_form	socket.c	/^  const char *display_form;$/;"	m	struct:proto_names	file:
dll_resolve_symbol	plugin.c	/^dll_resolve_symbol (HMODULE module, void **dest, const char *symbol, const char *plugin_name, const unsigned int flags)$/;"	f	file:
dmsg	error.h	151;"	d
dmsg	error.h	153;"	d
dmsg	error.h	159;"	d
dmsg	error.h	161;"	d
dmsg	error.h	172;"	d
dns	tun.h	/^  in_addr_t dns[N_DHCP_ADDR];$/;"	m	struct:tuntap_options
dns_addr_safe	socket.c	/^dns_addr_safe (const char *addr)$/;"	f	file:
dns_len	tun.h	/^  int dns_len;$/;"	m	struct:tuntap_options
do_alloc_route_list	init.c	/^do_alloc_route_list (struct context *c)$/;"	f	file:
do_close_check_if_restart_permitted	init.c	/^do_close_check_if_restart_permitted (struct context *c)$/;"	f	file:
do_close_event_set	init.c	/^do_close_event_set (struct context *c)$/;"	f	file:
do_close_fragment	init.c	/^do_close_fragment (struct context *c)$/;"	f	file:
do_close_free_buf	init.c	/^do_close_free_buf (struct context *c)$/;"	f	file:
do_close_free_key_schedule	init.c	/^do_close_free_key_schedule (struct context *c, bool free_ssl_ctx)$/;"	f	file:
do_close_ifconfig_pool_persist	init.c	/^do_close_ifconfig_pool_persist (struct context *c)$/;"	f	file:
do_close_link_socket	init.c	/^do_close_link_socket (struct context *c)$/;"	f	file:
do_close_packet_id	init.c	/^do_close_packet_id (struct context *c)$/;"	f	file:
do_close_plugins	init.c	/^do_close_plugins (struct context *c)$/;"	f	file:
do_close_status_output	init.c	/^do_close_status_output (struct context *c)$/;"	f	file:
do_close_tls	init.c	/^do_close_tls (struct context *c)$/;"	f	file:
do_close_tun	init.c	/^do_close_tun (struct context *c, bool force)$/;"	f	file:
do_close_tun_simple	init.c	/^do_close_tun_simple (struct context *c)$/;"	f	file:
do_compute_occ_strings	init.c	/^do_compute_occ_strings (struct context *c)$/;"	f	file:
do_deferred_options	init.c	/^do_deferred_options (struct context *c, const unsigned int found)$/;"	f
do_env_set_destroy	init.c	/^do_env_set_destroy (struct context *c)$/;"	f	file:
do_event_set_init	init.c	/^do_event_set_init (struct context *c,$/;"	f	file:
do_extract	dhcp.c	/^do_extract (struct dhcp *dhcp, int optlen)$/;"	f	file:
do_genkey	init.c	/^do_genkey (const struct options * options)$/;"	f
do_hold	init.c	/^do_hold (struct context *c)$/;"	f	file:
do_ifconfig	tun.c	/^do_ifconfig (struct tuntap *tt,$/;"	f
do_inherit_env	init.c	/^do_inherit_env (struct context *c, const struct env_set *src)$/;"	f	file:
do_inherit_plugins	init.c	/^do_inherit_plugins (struct context *c, const struct context *src)$/;"	f	file:
do_init_buffers	init.c	/^do_init_buffers (struct context *c)$/;"	f	file:
do_init_crypto	init.c	/^do_init_crypto (struct context *c, const unsigned int flags)$/;"	f	file:
do_init_crypto_none	init.c	/^do_init_crypto_none (const struct context *c)$/;"	f	file:
do_init_crypto_static	init.c	/^do_init_crypto_static (struct context *c, const unsigned int flags)$/;"	f	file:
do_init_crypto_tls	init.c	/^do_init_crypto_tls (struct context *c, const unsigned int flags)$/;"	f	file:
do_init_crypto_tls_c1	init.c	/^do_init_crypto_tls_c1 (struct context *c)$/;"	f	file:
do_init_finalize_tls_frame	init.c	/^do_init_finalize_tls_frame (struct context *c)$/;"	f	file:
do_init_first_time	init.c	/^do_init_first_time (struct context *c)$/;"	f	file:
do_init_fragment	init.c	/^do_init_fragment (struct context *c)$/;"	f	file:
do_init_frame	init.c	/^do_init_frame (struct context *c)$/;"	f	file:
do_init_frame_tls	init.c	/^do_init_frame_tls (struct context *c)$/;"	f	file:
do_init_mssfix	init.c	/^do_init_mssfix (struct context *c)$/;"	f	file:
do_init_route_ipv6_list	init.c	/^do_init_route_ipv6_list (const struct options *options,$/;"	f	file:
do_init_route_list	init.c	/^do_init_route_list (const struct options *options,$/;"	f	file:
do_init_socket_1	init.c	/^do_init_socket_1 (struct context *c, const int mode)$/;"	f	file:
do_init_socket_2	init.c	/^do_init_socket_2 (struct context *c)$/;"	f	file:
do_init_timers	init.c	/^do_init_timers (struct context *c, bool deferred)$/;"	f	file:
do_init_traffic_shaper	init.c	/^do_init_traffic_shaper (struct context *c)$/;"	f	file:
do_init_tun	init.c	/^do_init_tun (struct context *c)$/;"	f	file:
do_link_socket_new	init.c	/^do_link_socket_new (struct context *c)$/;"	f	file:
do_open_ifconfig_pool_persist	init.c	/^do_open_ifconfig_pool_persist (struct context *c)$/;"	f	file:
do_open_status_output	init.c	/^do_open_status_output (struct context *c)$/;"	f	file:
do_open_tun	init.c	/^do_open_tun (struct context *c)$/;"	f	file:
do_option_warnings	init.c	/^do_option_warnings (struct context *c)$/;"	f	file:
do_persist_tuntap	init.c	/^do_persist_tuntap (const struct options *options)$/;"	f
do_print_data_channel_mtu_parms	init.c	/^do_print_data_channel_mtu_parms (struct context *c)$/;"	f	file:
do_route	init.c	/^do_route (const struct options *options,$/;"	f
do_setenv_x509	ssl_verify_openssl.c	/^do_setenv_x509 (struct env_set *es, const char *name, char *value, int depth)$/;"	f	file:
do_setup_fast_io	init.c	/^do_setup_fast_io (struct context *c)$/;"	f	file:
do_signal_on_tls_errors	init.c	/^do_signal_on_tls_errors (struct context *c)$/;"	f	file:
do_startup_pause	init.c	/^do_startup_pause (struct context *c)$/;"	f	file:
do_test_crypto	init.c	/^do_test_crypto (const struct options *o)$/;"	f
do_uid_gid_chroot	init.c	/^do_uid_gid_chroot (struct context *c, bool no_delay)$/;"	f	file:
do_up	init.c	/^do_up (struct context *c, bool pulled_options, unsigned int option_types_found)$/;"	f
do_up_ran	openvpn.h	/^  bool do_up_ran;$/;"	m	struct:context_2
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE_TARNAME}$/;"	m
doff_res	proto.h	/^  uint8_t       doff_res;$/;"	m	struct:openvpn_tcphdr
domain	tun.h	/^  const char *domain;        \/* DOMAIN (15) *\/$/;"	m	struct:tuntap_options
dont_mute	error.c	/^dont_mute (unsigned int flags)$/;"	f
down_high	gremlin.c	/^static const int down_high[] = { 10, 60, 120 };$/;"	v	file:
down_low	gremlin.c	/^static const int down_low[] =  {  5, 10,  10 };$/;"	v	file:
down_pre	options.h	/^  bool down_pre;$/;"	m	struct:options
down_script	options.h	/^  const char *down_script;$/;"	m	struct:options
dragonfly_modify_read_write_return	tun.c	/^dragonfly_modify_read_write_return (int len)$/;"	f	file:
drop_accept	pf.c	/^drop_accept (const bool accept)$/;"	f	file:
drop_freq	gremlin.c	/^static const int drop_freq[] = { 500, 100, 50 };$/;"	v	file:
dummy	base64.c	/^static void dummy(void) {}$/;"	f	file:
dummy	cryptoapi.c	/^static void dummy (void) {}$/;"	f	file:
dummy	fragment.c	/^static void dummy(void) {}$/;"	f	file:
dummy	gremlin.c	/^static void dummy(void) {}$/;"	f	file:
dummy	list.c	/^static void dummy(void) {}$/;"	f	file:
dummy	lzo.c	/^static void dummy(void) {}$/;"	f	file:
dummy	manage.c	/^static void dummy(void) {}$/;"	f	file:
dummy	mbuf.c	/^static void dummy(void) {}$/;"	f	file:
dummy	mroute.c	/^static void dummy(void) {}$/;"	f	file:
dummy	multi.c	/^static void dummy(void) {}$/;"	f	file:
dummy	ntlm.c	/^static void dummy(void) {}$/;"	f	file:
dummy	occ.c	/^static void dummy(void) {}$/;"	f	file:
dummy	openvpn.h	/^  int dummy;$/;"	m	struct:packet_id_persist
dummy	perf.c	/^static void dummy(void) {}$/;"	f	file:
dummy	pkcs11.c	/^static void dummy (void) {}$/;"	f	file:
dummy	plugin.c	/^static void dummy(void) {}$/;"	f	file:
dummy	plugin.h	/^struct plugin_list { int dummy; };$/;"	m	struct:plugin_list
dummy	plugin.h	/^struct plugin_return { int dummy; };$/;"	m	struct:plugin_return
dummy	proxy.c	/^static void dummy(void) {}$/;"	f	file:
dummy	reliable.c	/^static void dummy(void) {}$/;"	f	file:
dummy	session_id.c	/^static void dummy(void) {}$/;"	f	file:
dummy	shaper.c	/^static void dummy(void) {}$/;"	f	file:
dummy	socks.c	/^static void dummy(void) {}$/;"	f	file:
dummy	ssl.c	/^static void dummy(void) {}$/;"	f	file:
dummy	tun.h	/^  int dummy; \/* not used *\/$/;"	m	struct:tuntap_options
dump_residual	proxy.c	/^dump_residual (socket_descriptor_t sd,$/;"	f	file:
duplicate_cn	options.h	/^  bool duplicate_cn;$/;"	m	struct:options
duplicate_cn	pool.h	/^  bool duplicate_cn;$/;"	m	struct:ifconfig_pool
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
earliest_wakeup	multi.h	/^  struct multi_instance *earliest_wakeup;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance
earliest_wakeup	schedule.h	/^  struct schedule_entry *earliest_wakeup; \/* cached earliest wakeup *\/$/;"	m	struct:schedule	typeref:struct:schedule::schedule_entry
echo	manage.h	/^  struct log_history *echo; \/* saved --echo strings *\/$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history
echo_buffer_size	manage.h	/^  int echo_buffer_size;$/;"	m	struct:man_settings
echo_realtime	manage.h	/^  bool echo_realtime;$/;"	m	struct:man_connection
elem	list.h	/^  struct hash_element *elem;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_element
enable	pushlist.h	/^  bool enable;$/;"	m	struct:push_entry
enable_c2c	multi.h	/^  bool enable_c2c;$/;"	m	struct:multi_context
enable_c2c	options.h	/^  bool enable_c2c;$/;"	m	struct:options
enabled	pf.h	/^  bool enabled;$/;"	m	struct:pf_context
encrypt	crypto.h	/^  struct key_ctx encrypt;       \/**< OpenSSL cipher and\/or HMAC contexts$/;"	m	struct:key_ctx_bi	typeref:struct:key_ctx_bi::key_ctx
encrypt_buf	openvpn.h	/^  struct buffer encrypt_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
encrypt_sign	forward.c	/^encrypt_sign (struct context *c, bool comp_frag)$/;"	f
end	interval.h	/^  struct timeval end;$/;"	m	struct:usec_timer	typeref:struct:usec_timer::timeval
endless_buf_read	ssl_polarssl.c	/^static int endless_buf_read( void * ctx, unsigned char * out, size_t out_len )$/;"	f	file:
endless_buf_write	ssl_polarssl.c	/^static int endless_buf_write( void *ctx, const unsigned char *in, size_t len )$/;"	f	file:
endless_buffer	ssl_polarssl.h	/^} endless_buffer;$/;"	t	typeref:struct:__anon2
endpoint	ssl_polarssl.h	/^    int endpoint; 		\/**< Whether or not this is a server or a client *\/$/;"	m	struct:tls_root_ctx
engine	options.h	/^  const char *engine;$/;"	m	struct:options
engine_initialized	crypto_openssl.c	/^static bool engine_initialized = false; \/* GLOBAL *\/$/;"	v	file:
engine_persist	crypto_openssl.c	/^static ENGINE *engine_persist = NULL;   \/* GLOBAL *\/$/;"	v	file:
entries	clinat.h	/^  struct client_nat_entry entries[MAX_CLIENT_NAT];$/;"	m	struct:client_nat_option_list	typeref:struct:client_nat_option_list::client_nat_entry
env_allowed	misc.c	/^env_allowed (const char *str)$/;"	f
env_block	win32.c	/^env_block (const struct env_set *es)$/;"	f	file:
env_filter_level	manage.h	/^  int env_filter_level;$/;"	m	struct:man_connection
env_filter_match	manage.c	/^env_filter_match (const char *env_str, const int env_filter_level)$/;"	f	file:
env_item	misc.h	/^struct env_item {$/;"	s
env_safe_to_print	misc.c	/^env_safe_to_print (const char *str)$/;"	f
env_set	misc.h	/^struct env_set {$/;"	s
env_set_add	misc.c	/^env_set_add (struct env_set *es, const char *str)$/;"	f
env_set_add_nolock	misc.c	/^env_set_add_nolock (struct env_set *es, const char *str)$/;"	f	file:
env_set_add_to_environment	misc.c	/^env_set_add_to_environment (const struct env_set *es)$/;"	f
env_set_create	misc.c	/^env_set_create (struct gc_arena *gc)$/;"	f
env_set_del	misc.c	/^env_set_del (struct env_set *es, const char *str)$/;"	f
env_set_del_nolock	misc.c	/^env_set_del_nolock (struct env_set *es, const char *str)$/;"	f	file:
env_set_destroy	misc.c	/^env_set_destroy (struct env_set *es)$/;"	f
env_set_inherit	misc.c	/^env_set_inherit (struct env_set *es, const struct env_set *src)$/;"	f
env_set_print	misc.c	/^env_set_print (int msglevel, const struct env_set *es)$/;"	f
env_set_remove_from_environment	misc.c	/^env_set_remove_from_environment (const struct env_set *es)$/;"	f
env_string_equal	misc.c	/^env_string_equal (const char *s1, const char *s2)$/;"	f	file:
ep_ctl	event.c	/^ep_ctl (struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
ep_del	event.c	/^ep_del (struct event_set *es, event_t event)$/;"	f	file:
ep_free	event.c	/^ep_free (struct event_set *es)$/;"	f	file:
ep_init	event.c	/^ep_init (int *maxevents, unsigned int flags)$/;"	f	file:
ep_reset	event.c	/^ep_reset (struct event_set *es)$/;"	f	file:
ep_set	event.c	/^struct ep_set$/;"	s	file:
ep_wait	event.c	/^ep_wait (struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:
epfd	event.c	/^  int epfd;$/;"	m	struct:ep_set	file:
err_put_ms_error	cryptoapi.c	/^static void err_put_ms_error(DWORD ms_err, int func, const char *file, int line)$/;"	f	file:
error	socket.h	/^  bool error;  \/* if true, fatal TCP error has occurred,$/;"	m	struct:stream_buf
error_reset	error.c	/^error_reset ()$/;"	f
errors	status.h	/^  bool errors;$/;"	m	struct:status_output
errors_to_stderr	error.c	/^errors_to_stderr (void)$/;"	f
es	manage.h	/^  struct event_set *es;$/;"	m	struct:man_connection	typeref:struct:man_connection::event_set
es	mtcp.h	/^  struct event_set *es;$/;"	m	struct:multi_tcp	typeref:struct:multi_tcp::event_set
es	openvpn.h	/^  struct env_set *es;           \/**< Set of environment variables. *\/$/;"	m	struct:context	typeref:struct:context::env_set
es	openvpn.h	/^  struct env_set *es;$/;"	m	struct:context_2	typeref:struct:context_2::env_set
es	ssl_common.h	/^  struct env_set *es;$/;"	m	struct:tls_options	typeref:struct:tls_options::env_set
es_owned	openvpn.h	/^  bool es_owned;$/;"	m	struct:context_2
esr	event.c	/^  struct event_set_return *esr;$/;"	m	struct:we_set	typeref:struct:we_set::event_set_return	file:
esr	mtcp.h	/^  struct event_set_return *esr;$/;"	m	struct:multi_tcp	typeref:struct:multi_tcp::event_set_return
establish_http_proxy_passthru	proxy.c	/^establish_http_proxy_passthru (struct http_proxy_info *p,$/;"	f
establish_socks_proxy_passthru	socks.c	/^establish_socks_proxy_passthru (struct socks_proxy_info *p,$/;"	f
establish_socks_proxy_udpassoc	socks.c	/^establish_socks_proxy_udpassoc (struct socks_proxy_info *p,$/;"	f
established	ssl_common.h	/^  time_t established;		\/* when our state went S_ACTIVE *\/$/;"	m	struct:key_state
et	status.h	/^  struct event_timeout et;$/;"	m	struct:status_output	typeref:struct:status_output::event_timeout
event_ctl	event.h	/^event_ctl (struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f
event_del	event.h	/^event_del (struct event_set *es, event_t event)$/;"	f
event_free	event.h	/^event_free (struct event_set *es)$/;"	f
event_mask	win32.h	/^  long event_mask;$/;"	m	struct:net_event_win32
event_reset	event.h	/^event_reset (struct event_set *es)$/;"	f
event_set	event.h	/^struct event_set$/;"	s
event_set	openvpn.h	/^  struct event_set *event_set;$/;"	m	struct:context_2	typeref:struct:context_2::event_set
event_set_functions	event.h	/^struct event_set_functions$/;"	s
event_set_init	event.c	/^event_set_init (int *maxevents, unsigned int flags)$/;"	f
event_set_init_scalable	event.c	/^event_set_init_scalable (int *maxevents, unsigned int flags)$/;"	f	file:
event_set_init_simple	event.c	/^event_set_init_simple (int *maxevents, unsigned int flags)$/;"	f	file:
event_set_max	openvpn.h	/^  int event_set_max;$/;"	m	struct:context_2
event_set_owned	openvpn.h	/^  bool event_set_owned;$/;"	m	struct:context_2
event_set_return	event.h	/^struct event_set_return$/;"	s
event_set_return_init	event.h	/^event_set_return_init (struct event_set_return *esr)$/;"	f
event_set_status	openvpn.h	/^  unsigned int event_set_status;$/;"	m	struct:context_2
event_t	event.h	/^typedef const struct rw_handle *event_t;$/;"	t	typeref:struct:rw_handle
event_t	event.h	/^typedef int event_t;$/;"	t
event_timeout	interval.h	/^struct event_timeout$/;"	s
event_timeout_clear	interval.h	/^event_timeout_clear (struct event_timeout* et)$/;"	f
event_timeout_clear_ret	interval.h	/^event_timeout_clear_ret ()$/;"	f
event_timeout_defined	interval.h	/^event_timeout_defined (const struct event_timeout* et)$/;"	f
event_timeout_init	interval.h	/^event_timeout_init (struct event_timeout* et, interval_t n, const time_t local_now)$/;"	f
event_timeout_modify_wakeup	interval.h	/^event_timeout_modify_wakeup (struct event_timeout* et, interval_t n)$/;"	f
event_timeout_reset	interval.h	/^event_timeout_reset (struct event_timeout* et)$/;"	f
event_timeout_trigger	interval.c	/^event_timeout_trigger (struct event_timeout *et,$/;"	f
event_wait	event.h	/^event_wait (struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f
events	event.c	/^  HANDLE *events;$/;"	m	struct:we_set	file:
events	event.c	/^  struct epoll_event *events;$/;"	m	struct:ep_set	typeref:struct:ep_set::epoll_event	file:
events	event.c	/^  struct pollfd *events;$/;"	m	struct:po_set	typeref:struct:po_set::pollfd	file:
exclude	pf.h	/^  bool exclude;$/;"	m	struct:ipv4_subnet
exclude	pf.h	/^  bool exclude;$/;"	m	struct:pf_cn
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
exit_event_initial_state	options.h	/^  bool exit_event_initial_state;$/;"	m	struct:options
exit_event_name	options.h	/^  const char *exit_event_name;$/;"	m	struct:options
explicit_exit_notification	options.h	/^  int explicit_exit_notification;  \/* Explicitly tell peer when we are exiting via OCC_EXIT message *\/$/;"	m	struct:connection_entry
explicit_exit_notification_interval	openvpn.h	/^  struct event_timeout explicit_exit_notification_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
explicit_exit_notification_time_wait	openvpn.h	/^  time_t explicit_exit_notification_time_wait;$/;"	m	struct:context_2
ext_key_input	manage.h	/^  struct buffer_list *ext_key_input;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list
ext_key_state	manage.h	/^  int ext_key_state;$/;"	m	struct:man_connection
external_context	ssl_polarssl.c	/^struct external_context {$/;"	s	file:
external_key	ssl_polarssl.h	/^    struct external_context *external_key; \/**< Management external key *\/$/;"	m	struct:tls_root_ctx	typeref:struct:tls_root_ctx::external_context
external_key_len	ssl_polarssl.c	/^static inline size_t external_key_len(void *vctx)$/;"	f	file:
external_pkcs1_sign	ssl_polarssl.c	/^static inline int external_pkcs1_sign( void *ctx_voidptr,$/;"	f	file:
extra_buffer	mtu.h	/^  int extra_buffer;             \/**< Maximum number of bytes that$/;"	m	struct:frame
extra_certs_file	options.h	/^  const char *extra_certs_file;$/;"	m	struct:options
extra_certs_file_inline	options.h	/^  const char *extra_certs_file_inline;$/;"	m	struct:options
extra_frame	mtu.h	/^  int extra_frame;              \/**< Maximum number of bytes that all$/;"	m	struct:frame
extra_link	mtu.h	/^  int extra_link;               \/**< Maximum number of bytes in excess of$/;"	m	struct:frame
extra_tun	mtu.h	/^  int extra_tun;                \/**< Maximum number of bytes in excess of$/;"	m	struct:frame
extract_x509_extension	ssl_verify_openssl.c	/^bool extract_x509_extension(X509 *cert, char *fieldname, char *out, int size)$/;"	f	file:
extract_x509_field_ssl	ssl_verify_openssl.c	/^extract_x509_field_ssl (X509_NAME *x509, const char *field_name, char *out,$/;"	f	file:
factor	shaper.h	/^  double factor;$/;"	m	struct:shaper
factor	shaper.h	/^  int factor;$/;"	m	struct:shaper
fast	event.c	/^  bool fast;$/;"	m	struct:ep_set	file:
fast	event.c	/^  bool fast;$/;"	m	struct:po_set	file:
fast	event.c	/^  bool fast;$/;"	m	struct:se_set	file:
fast	event.c	/^  bool fast;$/;"	m	struct:we_set	file:
fast_io	openvpn.h	/^  bool fast_io;$/;"	m	struct:context_2
fast_io	options.h	/^  bool fast_io;$/;"	m	struct:options
fd	packet_id.h	/^  int fd;$/;"	m	struct:packet_id_persist
fd	status.h	/^  int fd;$/;"	m	struct:status_output
fd	tun.h	/^  int fd;   \/* file descriptor for TUN\/TAP dev *\/$/;"	m	struct:tuntap
file	dhcp.h	/^  uint8_t  file[128];  \/* boot file name *\/$/;"	m	struct:dhcp
file	pool.h	/^  struct status_output *file;$/;"	m	struct:ifconfig_pool_persist	typeref:struct:ifconfig_pool_persist::status_output
file_last_mod	pf.h	/^  time_t file_last_mod;$/;"	m	struct:pf_context
filename	misc.h	/^  const char *filename;$/;"	m	struct:pid_state
filename	packet_id.h	/^  const char *filename;$/;"	m	struct:packet_id_persist
filename	pf.h	/^  char *filename;$/;"	m	struct:pf_context
filename	status.h	/^  char *filename;$/;"	m	struct:status_output
find_certificate_in_store	cryptoapi.c	/^static const CERT_CONTEXT *find_certificate_in_store(const char *cert_prop, HCERTSTORE cert_store)$/;"	f	file:
finish	cryptoapi.c	/^static int finish(RSA *rsa)$/;"	f	file:
first_block	ssl_polarssl.h	/^    buffer_entry *first_block;$/;"	m	struct:__anon2
first_time	openvpn.h	/^  bool first_time;              \/**< True on the first iteration of$/;"	m	struct:context
fixed	pool.h	/^  bool fixed;$/;"	m	struct:ifconfig_pool_entry
fixed	pool.h	/^  bool fixed;$/;"	m	struct:ifconfig_pool_persist
fixup_key	crypto.c	/^fixup_key (struct key *key, const struct key_type *kt)$/;"	f
flags	crypto.h	/^  unsigned int flags;           \/**< Bit-flags determining behavior of$/;"	m	struct:crypto_options
flags	dhcp.h	/^  uint16_t flags;$/;"	m	struct:dhcp
flags	lzo.h	/^  unsigned int flags;$/;"	m	struct:lzo_compress_workspace
flags	manage.h	/^  unsigned int flags; \/* MF_x flags *\/$/;"	m	struct:man_settings
flags	manage.h	/^  unsigned int flags;$/;"	m	struct:man_def_auth_context
flags	manage.h	/^  unsigned int flags;$/;"	m	struct:management_callback
flags	mbuf.h	/^  unsigned int flags;$/;"	m	struct:mbuf_buffer
flags	misc.h	/^  unsigned int flags;$/;"	m	struct:auth_challenge_info
flags	misc.h	/^  unsigned int flags;$/;"	m	struct:static_challenge_info
flags	mtcp.c	/^  unsigned int flags;$/;"	m	struct:ta_iow_flags	file:
flags	multi.h	/^  unsigned int flags;$/;"	m	struct:multi_route
flags	options.h	/^  unsigned int flags;$/;"	m	struct:connection_entry
flags	proto.h	/^  uint8_t       flags;$/;"	m	struct:openvpn_tcphdr
flags	route.h	/^  unsigned int flags;     \/* RG_x flags *\/$/;"	m	struct:route_list
flags	route.h	/^  unsigned int flags;  \/* RG_x flags *\/$/;"	m	struct:route_option_list
flags	route.h	/^  unsigned int flags;$/;"	m	struct:route_gateway_info
flags	route.h	/^  unsigned int flags;$/;"	m	struct:route_ipv4
flags	route.h	/^  unsigned int flags;$/;"	m	struct:route_ipv6_list
flags	route.h	/^  unsigned int flags;$/;"	m	struct:route_ipv6_option_list
flags	route.h	/^  unsigned int flags;$/;"	m	struct:route_special_addr
flags	ssl_verify.h	/^  unsigned int flags;$/;"	m	struct:x509_track
flags	status.h	/^  unsigned int flags;$/;"	m	struct:status_output
flags	win32.h	/^  DWORD flags;$/;"	m	struct:overlapped_io
flags_default	status.h	/^  unsigned int flags_default;$/;"	m	struct:virtual_output
flip	gremlin.c	/^static bool flip(int n) {$/;"	f	file:
flow_lbl	proto.h	/^        uint8_t		flow_lbl[3];$/;"	m	struct:openvpn_ipv6hdr
flush_payload_buffer	ssl.c	/^flush_payload_buffer (struct key_state *ks)$/;"	f	file:
force_connection_list	options.h	/^  bool force_connection_list;$/;"	m	struct:options
foreground_fd	ps.h	/^  socket_descriptor_t foreground_fd;$/;"	m	struct:port_share
foreign_network	clinat.h	/^  in_addr_t foreign_network;$/;"	m	struct:client_nat_entry
foreign_option	options.c	/^foreign_option (struct options *o, char *argv[], int len, struct env_set *es)$/;"	f	file:
foreign_option_index	options.h	/^  int foreign_option_index;$/;"	m	struct:options
foreign_option_index	options.h	/^  int foreign_option_index;$/;"	m	struct:options_pre_pull
fork_dhcp_action	tun.c	/^fork_dhcp_action (struct tuntap *tt)$/;"	f	file:
fork_register_dns_action	tun.c	/^fork_register_dns_action (struct tuntap *tt)$/;"	f
fork_to_self	win32.c	/^fork_to_self (const char *cmdline)$/;"	f
forked	error.c	/^static bool forked;         \/* GLOBAL *\/$/;"	v	file:
format_common_name	init.c	/^format_common_name (struct context *c, struct gc_arena *gc)$/;"	f
format_extended_socket_error	mtu.c	/^format_extended_socket_error (int fd, int *mtu, struct gc_arena *gc)$/;"	f
format_hex	buffer.h	/^format_hex (const uint8_t *data, int size, int maxoutput, struct gc_arena *gc)$/;"	f
format_hex_ex	buffer.c	/^format_hex_ex (const uint8_t *data, int size, int maxoutput,$/;"	f
format_ip_addr_string	tun.c	/^format_ip_addr_string (const IP_ADDR_STRING *ip, struct gc_arena *gc)$/;"	f	file:
format_route_entry	route.c	/^format_route_entry (const MIB_IPFORWARDROW *r, struct gc_arena *gc)$/;"	f	file:
forward_compatible	options.h	/^  bool forward_compatible;$/;"	m	struct:options
fp	misc.h	/^  FILE *fp;$/;"	m	struct:pid_state
fp	options.c	/^    FILE *fp;$/;"	m	union:in_src::__anon3	file:
frag_off	proto.h	/^  uint16_t   frag_off;$/;"	m	struct:openvpn_iphdr
fragment	fragment.h	/^struct fragment {$/;"	s
fragment	openvpn.h	/^  struct fragment_master *fragment;$/;"	m	struct:context_2	typeref:struct:context_2::fragment_master
fragment	options.h	/^  int fragment;          \/* internal fragmentation size *\/$/;"	m	struct:connection_entry
fragment_frame_init	fragment.c	/^fragment_frame_init (struct fragment_master *f, const struct frame *frame)$/;"	f
fragment_free	fragment.c	/^fragment_free (struct fragment_master *f)$/;"	f
fragment_header_format	common.h	62;"	d
fragment_header_type	fragment.h	/^typedef uint32_t fragment_header_type;$/;"	t
fragment_housekeeping	fragment.h	/^fragment_housekeeping (struct fragment_master *f, struct frame *frame, struct timeval *tv)$/;"	f
fragment_incoming	fragment.c	/^fragment_incoming (struct fragment_master *f, struct buffer *buf,$/;"	f
fragment_init	fragment.c	/^fragment_init (struct frame *frame)$/;"	f
fragment_list	fragment.h	/^struct fragment_list {$/;"	s
fragment_list_buf_free	fragment.c	/^fragment_list_buf_free (struct fragment_list *list)$/;"	f	file:
fragment_list_buf_init	fragment.c	/^fragment_list_buf_init (struct fragment_list *list, const struct frame *frame)$/;"	f	file:
fragment_list_get_buf	fragment.c	/^fragment_list_get_buf (struct fragment_list *list, int seq_id)$/;"	f	file:
fragment_master	fragment.h	/^struct fragment_master {$/;"	s
fragment_outgoing	fragment.c	/^fragment_outgoing (struct fragment_master *f, struct buffer *buf,$/;"	f
fragment_outgoing_defined	fragment.h	/^fragment_outgoing_defined (struct fragment_master *f)$/;"	f
fragment_prepend_flags	fragment.c	/^fragment_prepend_flags (struct buffer *buf,$/;"	f	file:
fragment_ready_to_send	fragment.c	/^fragment_ready_to_send (struct fragment_master *f, struct buffer *buf,$/;"	f
fragment_ttl_reap	fragment.c	/^fragment_ttl_reap (struct fragment_master *f)$/;"	f	file:
fragment_wakeup	fragment.c	/^fragment_wakeup (struct fragment_master *f, struct frame *frame)$/;"	f
fragments	fragment.h	/^  struct fragment fragments[N_FRAG_BUF];$/;"	m	struct:fragment_list	typeref:struct:fragment_list::fragment
frame	mtu.h	/^struct frame {$/;"	s
frame	openvpn.h	/^  struct frame frame;$/;"	m	struct:context_2	typeref:struct:context_2::frame
frame	ssl.h	/^  struct frame frame;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::frame
frame	ssl_common.h	/^  struct frame frame;$/;"	m	struct:tls_options	typeref:struct:tls_options::frame
frame_add_to_align_adjust	mtu.h	/^frame_add_to_align_adjust (struct frame *frame, const int increment)$/;"	f
frame_add_to_extra_buffer	mtu.h	/^frame_add_to_extra_buffer (struct frame *frame, const int increment)$/;"	f
frame_add_to_extra_frame	mtu.h	/^frame_add_to_extra_frame (struct frame *frame, const int increment)$/;"	f
frame_add_to_extra_link	mtu.h	/^frame_add_to_extra_link (struct frame *frame, const int increment)$/;"	f
frame_add_to_extra_tun	mtu.h	/^frame_add_to_extra_tun (struct frame *frame, const int increment)$/;"	f
frame_adjust_path_mtu	socket.c	/^frame_adjust_path_mtu (struct frame *frame, int pmtu, int proto)$/;"	f
frame_align_to_extra_frame	mtu.h	/^frame_align_to_extra_frame (struct frame *frame)$/;"	f
frame_defined	mtu.h	/^frame_defined (const struct frame *frame)$/;"	f
frame_finalize	mtu.c	/^frame_finalize (struct frame *frame,$/;"	f
frame_finalize_options	init.c	/^frame_finalize_options (struct context *c, const struct options *o)$/;"	f	file:
frame_fragment	openvpn.h	/^  struct frame frame_fragment;$/;"	m	struct:context_2	typeref:struct:context_2::frame
frame_fragment_omit	openvpn.h	/^  struct frame frame_fragment_omit;$/;"	m	struct:context_2	typeref:struct:context_2::frame
frame_headroom	mtu.h	/^frame_headroom (const struct frame *f, const unsigned int flag_mask)$/;"	f
frame_or_align_flags	mtu.h	/^frame_or_align_flags (struct frame *frame, const unsigned int flag_mask)$/;"	f
frame_print	mtu.c	/^frame_print (const struct frame *frame,$/;"	f
frame_set_mtu_dynamic	mtu.c	/^frame_set_mtu_dynamic (struct frame *frame, int mtu, unsigned int flags)$/;"	f
frame_subtract_extra	mtu.c	/^frame_subtract_extra (struct frame *frame, const struct frame *src)$/;"	f
free	event.h	/^  void (*free)(struct event_set *es);$/;"	m	struct:event_set_functions
free_buf	buffer.c	/^free_buf (struct buffer *buf)$/;"	f
free_context_buffers	init.c	/^free_context_buffers (struct context_buffers *b)$/;"	f
free_crypt_prov	cryptoapi.c	/^    BOOL free_crypt_prov;$/;"	m	struct:_CAPI_DATA	file:
free_key_ctx	crypto.c	/^free_key_ctx (struct key_ctx *ctx)$/;"	f
free_key_ctx_bi	crypto.c	/^free_key_ctx_bi (struct key_ctx_bi *ctx)$/;"	f
free_ssl_lib	crypto.c	/^free_ssl_lib (void)$/;"	f
free_ssl_lib	ssl.c	/^free_ssl_lib ()$/;"	f
freebsd_modify_read_write_return	tun.c	/^freebsd_modify_read_write_return (int len)$/;"	f	file:
frequency_limit	otime.h	/^struct frequency_limit$/;"	s
frequency_limit_event_allowed	otime.c	/^frequency_limit_event_allowed (struct frequency_limit *f)$/;"	f
frequency_limit_free	otime.c	/^frequency_limit_free (struct frequency_limit *f)$/;"	f
frequency_limit_init	otime.c	/^frequency_limit_init (int max, int per)$/;"	f
from	openvpn.h	/^  struct link_socket_actual from;               \/* address of incoming datagram *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_actual
func	event.c	/^  struct event_set_functions func;$/;"	m	struct:ep_set	typeref:struct:ep_set::event_set_functions	file:
func	event.c	/^  struct event_set_functions func;$/;"	m	struct:po_set	typeref:struct:po_set::event_set_functions	file:
func	event.c	/^  struct event_set_functions func;$/;"	m	struct:se_set	typeref:struct:se_set::event_set_functions	file:
func	event.c	/^  struct event_set_functions func;$/;"	m	struct:we_set	typeref:struct:we_set::event_set_functions	file:
func	event.h	/^  struct event_set_functions func;$/;"	m	struct:event_set	typeref:struct:event_set::event_set_functions
func	status.h	/^  void (*func) (void *arg, const unsigned int flags, const char *str);$/;"	m	struct:virtual_output
func1	plugin.h	/^  openvpn_plugin_func_v1 func1;$/;"	m	struct:plugin
func2	plugin.h	/^  openvpn_plugin_func_v2 func2;$/;"	m	struct:plugin
func3	plugin.h	/^  openvpn_plugin_func_v3 func3;$/;"	m	struct:plugin
future_trigger	interval.h	/^  time_t future_trigger;$/;"	m	struct:interval
gateway	route.h	/^  const char *gateway;		\/* e.g. "2001:db8:0::2" *\/$/;"	m	struct:route_ipv6_option
gateway	route.h	/^  const char *gateway;$/;"	m	struct:route_option
gateway	route.h	/^  in_addr_t gateway;$/;"	m	struct:route_ipv4
gateway	route.h	/^  struct in6_addr gateway;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::in6_addr
gateway	route.h	/^  struct route_gateway_address gateway;$/;"	m	struct:route_gateway_info	typeref:struct:route_gateway_info::route_gateway_address
gc	misc.h	/^  struct gc_arena *gc;$/;"	m	struct:env_set	typeref:struct:env_set::gc_arena
gc	multi.h	/^  struct gc_arena gc;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::gc_arena
gc	openvpn.h	/^  struct gc_arena gc;           \/**< Garbage collection arena for$/;"	m	struct:context	typeref:struct:context::gc_arena
gc	openvpn.h	/^  struct gc_arena gc;           \/**< Garbage collection arena for$/;"	m	struct:context_2	typeref:struct:context_2::gc_arena
gc	options.h	/^  struct gc_arena gc;$/;"	m	struct:options	typeref:struct:options::gc_arena
gc_arena	buffer.h	/^struct gc_arena$/;"	s
gc_defined	buffer.h	/^gc_defined (struct gc_arena *a)$/;"	f
gc_detach	buffer.h	/^gc_detach (struct gc_arena *a)$/;"	f
gc_entry	buffer.h	/^struct gc_entry$/;"	s
gc_free	buffer.h	/^gc_free (struct gc_arena *a)$/;"	f
gc_init	buffer.h	/^gc_init (struct gc_arena *a)$/;"	f
gc_malloc	buffer.h	144;"	d
gc_malloc_debug	buffer.c	/^gc_malloc_debug (size_t size, bool clear, struct gc_arena *a, const char *file, int line)$/;"	f
gc_new	buffer.h	/^gc_new (void)$/;"	f
gc_owned	options.h	/^  bool gc_owned;$/;"	m	struct:options
gc_reset	buffer.h	/^gc_reset (struct gc_arena *a)$/;"	f
gc_transfer	buffer.c	/^gc_transfer (struct gc_arena *dest, struct gc_arena *src)$/;"	f
gen_hmac_md5	ntlm.c	/^gen_hmac_md5 (const char* data, int data_len, const char* key, int key_len,char *result)$/;"	f	file:
gen_md4_hash	ntlm.c	/^gen_md4_hash (const char* data, int data_len, char *result)$/;"	f	file:
gen_nonce	ntlm.c	/^gen_nonce (unsigned char *nonce)$/;"	f	file:
gen_path	misc.c	/^gen_path (const char *directory, const char *filename, struct gc_arena *gc)$/;"	f
gen_timestamp	ntlm.c	/^gen_timestamp (unsigned char *timestamp)$/;"	f	file:
generate_ifconfig_broadcast_addr	tun.c	/^generate_ifconfig_broadcast_addr (in_addr_t local,$/;"	f	file:
generate_key_expansion	ssl.c	/^generate_key_expansion (struct key_ctx_bi *key,$/;"	f	file:
generate_key_random	crypto.c	/^generate_key_random (struct key *key, const struct key_type *kt)$/;"	f
generate_prefix	multi.c	/^generate_prefix (struct multi_instance *mi)$/;"	f
genhash	pf.c	/^genhash (struct pf_cn_set *cns, const char *prefix, const int n_clients)$/;"	f	file:
genkey	options.h	/^  bool genkey;$/;"	m	struct:options
get_adapter	tun.c	/^get_adapter (const IP_ADAPTER_INFO *ai, DWORD index)$/;"	f
get_adapter_index	tun.c	/^get_adapter_index (const char *guid)$/;"	f	file:
get_adapter_index_flexible	tun.c	/^get_adapter_index_flexible (const char *name) \/* actual name or GUID *\/$/;"	f	file:
get_adapter_index_method_1	tun.c	/^get_adapter_index_method_1 (const char *guid)$/;"	f	file:
get_adapter_index_method_2	tun.c	/^get_adapter_index_method_2 (const char *guid)$/;"	f	file:
get_adapter_info	tun.c	/^get_adapter_info (DWORD index, struct gc_arena *gc)$/;"	f
get_adapter_info_list	tun.c	/^get_adapter_info_list (struct gc_arena *gc)$/;"	f
get_adapter_ip_netmask	tun.c	/^get_adapter_ip_netmask (const IP_ADAPTER_INFO *ai, const int n, in_addr_t *ip, in_addr_t *netmask)$/;"	f	file:
get_adapter_n_ip_netmask	tun.c	/^get_adapter_n_ip_netmask (const IP_ADAPTER_INFO *ai)$/;"	f	file:
get_auth_challenge	misc.c	/^get_auth_challenge (const char *auth_challenge, struct gc_arena *gc)$/;"	f
get_bypass_addresses	route.c	/^get_bypass_addresses (struct route_bypass *rb, const unsigned int flags)  \/* PLATFORM-SPECIFIC *\/$/;"	f	file:
get_bypass_addresses	route.c	/^get_bypass_addresses (struct route_bypass *rb, const unsigned int flags)$/;"	f	file:
get_cipher_name_pair	crypto_polarssl.c	/^get_cipher_name_pair(const char *cipher_name) {$/;"	f
get_console_input	console.c	/^get_console_input (const char *prompt, const bool echo, char *input, const int capacity)$/;"	f
get_console_input_systemd	console.c	/^get_console_input_systemd (const char *prompt, const bool echo, char *input, const int capacity)$/;"	f	file:
get_console_input_win32	console.c	/^get_console_input_win32 (const char *prompt, const bool echo, char *input, const int capacity)$/;"	f	file:
get_debug_level	error.c	/^get_debug_level (void)$/;"	f
get_default_gateway	route.c	/^get_default_gateway (struct route_gateway_info *rgi)$/;"	f
get_default_gateway_row	route.c	/^get_default_gateway_row (const MIB_IPFORWARDTABLE *routes)$/;"	f	file:
get_device_guid	tun.c	/^get_device_guid (const char *name,$/;"	f	file:
get_dhcp_message_type	dhcp.c	/^get_dhcp_message_type (const struct dhcp *dhcp, const int optlen)$/;"	f	file:
get_highest_preference_tls_cipher	ssl_openssl.c	/^get_highest_preference_tls_cipher (char *buf, int size)$/;"	f
get_highest_preference_tls_cipher	ssl_polarssl.c	/^get_highest_preference_tls_cipher (char *buf, int size)$/;"	f
get_interface_info	tun.c	/^get_interface_info (DWORD index, struct gc_arena *gc)$/;"	f	file:
get_interface_info_list	tun.c	/^get_interface_info_list (struct gc_arena *gc)$/;"	f	file:
get_ip_addr	options.c	/^get_ip_addr (const char *ip_string, int msglevel, bool *error)$/;"	f	file:
get_ipv6_addr	options.c	/^get_ipv6_addr( const char * prefix_str, struct in6_addr *network,$/;"	f
get_key_value	proxy.c	/^get_key_value(const char *str,       \/* source string *\/$/;"	f	file:
get_link_socket_info	forward-inline.h	/^get_link_socket_info (struct context *c)$/;"	f
get_mute_cutoff	error.c	/^get_mute_cutoff (void)$/;"	f
get_orig_stderr	error.c	/^get_orig_stderr (void)$/;"	f
get_pa_var	proxy.c	/^get_pa_var (const char *key, const char *pa, struct gc_arena *gc)$/;"	f	file:
get_packet_flood_parms	gremlin.c	/^get_packet_flood_parms (int level)$/;"	f
get_panel_reg	tun.c	/^get_panel_reg (struct gc_arena *gc)$/;"	f
get_peer_info	manage.h	/^  char *(*get_peer_info) (void *arg, const unsigned long cid);$/;"	m	struct:management_callback
get_per_adapter_info	tun.c	/^get_per_adapter_info (const DWORD index, struct gc_arena *gc)$/;"	f
get_perf	perf.c	/^get_perf (int sdelta)$/;"	f	file:
get_perf_index	perf.c	/^get_perf_index (int sdelta)$/;"	f	file:
get_pid_file	misc.c	/^get_pid_file (const char* filename, struct pid_state *state)$/;"	f
get_proxy_authenticate	proxy.c	/^get_proxy_authenticate (socket_descriptor_t sd,$/;"	f	file:
get_random	crypto.c	/^get_random()$/;"	f
get_random	misc.h	177;"	d
get_signal	sig.h	/^get_signal (volatile int *sig)$/;"	f
get_special_addr	route.c	/^get_special_addr (const struct route_list *rl,$/;"	f	file:
get_ssl_library_version	ssl_openssl.c	/^get_ssl_library_version(void)$/;"	f
get_ssl_library_version	ssl_polarssl.c	/^get_ssl_library_version(void)$/;"	f
get_stack_index	perf.c	/^get_stack_index (int sdelta)$/;"	f	file:
get_tap_reg	tun.c	/^get_tap_reg (struct gc_arena *gc)$/;"	f
get_tls_handshake_key	crypto.c	/^get_tls_handshake_key (const struct key_type *key_type,$/;"	f
get_tun_adapter	tun.c	/^get_tun_adapter (const struct tuntap *tt, const IP_ADAPTER_INFO *list)$/;"	f
get_unspecified_device_guid	tun.c	/^get_unspecified_device_guid (const int device_number,$/;"	f	file:
get_user_pass	misc.h	/^get_user_pass (struct user_pass *up,$/;"	f
get_user_pass_auto_userid	misc.c	/^get_user_pass_auto_userid (struct user_pass *up, const char *tag)$/;"	f
get_user_pass_cr	misc.c	/^get_user_pass_cr (struct user_pass *up,$/;"	f
get_user_pass_http	proxy.c	/^get_user_pass_http (struct http_proxy_info *p, const bool force)$/;"	f	file:
get_win_sys_path	win32.c	/^get_win_sys_path (void)$/;"	f
get_windows_routing_table	route.c	/^get_windows_routing_table (struct gc_arena *gc)$/;"	f	file:
getaddr	socket.c	/^getaddr (unsigned int flags,$/;"	f
getbio	ssl_openssl.c	/^getbio (BIO_METHOD * type, const char *desc)$/;"	f	file:
giaddr	dhcp.h	/^  uint32_t giaddr;     \/* relay agent IP address *\/$/;"	m	struct:dhcp
global_auth_retry	options.c	/^static int global_auth_retry; \/* GLOBAL *\/$/;"	v	file:
global_env	misc.c	/^static struct env_item *global_env = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:env_item	file:
gr	platform.h	/^  struct group *gr;$/;"	m	struct:platform_state_group	typeref:struct:platform_state_group::group
gremlin	options.h	/^  int gremlin;$/;"	m	struct:options
gremlin	socket.h	/^  int gremlin; \/* --gremlin bits *\/$/;"	m	struct:link_socket
gremlin	ssl_common.h	/^  int gremlin;$/;"	m	struct:tls_options
gremlin_flood_clients	multi.c	/^gremlin_flood_clients (struct multi_context *m)$/;"	f	file:
groupname	options.h	/^  const char *groupname;$/;"	m	struct:options
groupname	platform.h	/^  const char *groupname;$/;"	m	struct:platform_state_group
gt	schedule.h	/^  struct schedule_entry *gt;$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry
guess_tuntap_dev	tun.c	/^guess_tuntap_dev (const char *dev,$/;"	f
guid	tun.h	/^  const char *guid;$/;"	m	struct:panel_reg
guid	tun.h	/^  const char *guid;$/;"	m	struct:tap_reg
guid_to_name	tun.c	/^guid_to_name (const char *guid, const struct panel_reg *panel_reg)$/;"	f	file:
h_errno_msg	socket.c	/^h_errno_msg(int h_errno_err)$/;"	f	file:
halt	manage.h	/^  bool halt;$/;"	m	struct:man_connection
halt	multi.h	/^  bool halt;$/;"	m	struct:multi_instance
halt_non_edge_triggered_signals	sig.h	/^halt_non_edge_triggered_signals (void)$/;"	f
hand	tun.h	/^  HANDLE hand;$/;"	m	struct:tuntap
hand	win32.h	/^  HANDLE hand;$/;"	m	struct:semaphore
handle	plugin.h	/^  void *handle;$/;"	m	struct:plugin
handle	win32.h	/^  struct rw_handle handle;$/;"	m	struct:net_event_win32	typeref:struct:net_event_win32::rw_handle
handshake_window	options.h	/^  int handshake_window;$/;"	m	struct:options
handshake_window	ssl_common.h	/^  int handshake_window;$/;"	m	struct:tls_options
hard	sig.h	/^  volatile bool hard;$/;"	m	struct:signal_info
has_digit	buffer.h	/^has_digit (const unsigned char* src)$/;"	f
hash	list.h	/^  struct hash *hash;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash
hash	list.h	/^struct hash$/;"	s
hash	multi.h	/^  struct hash *hash;            \/**< VPN tunnel instances indexed by real$/;"	m	struct:multi_context	typeref:struct:multi_context::hash
hash_add	list.c	/^hash_add (struct hash *hash, const void *key, void *value, bool replace)$/;"	f
hash_add_fast	list.h	/^hash_add_fast (struct hash *hash,$/;"	f
hash_bucket	list.h	/^hash_bucket (struct hash *hash, uint32_t hv)$/;"	f
hash_bucket	list.h	/^struct hash_bucket$/;"	s
hash_element	list.h	/^struct hash_element$/;"	s
hash_free	list.c	/^hash_free (struct hash *hash)$/;"	f
hash_func	list.c	/^hash_func (const uint8_t *k, uint32_t length, uint32_t initval)$/;"	f
hash_function	list.h	/^  uint32_t (*hash_function)(const void *key, uint32_t iv);$/;"	m	struct:hash
hash_init	list.c	/^hash_init (const int n_buckets,$/;"	f
hash_iterator	list.h	/^struct hash_iterator$/;"	s
hash_iterator_advance	list.c	/^hash_iterator_advance (struct hash_iterator *hi)$/;"	f	file:
hash_iterator_delete_element	list.c	/^hash_iterator_delete_element (struct hash_iterator *hi)$/;"	f
hash_iterator_free	list.c	/^hash_iterator_free (struct hash_iterator *hi)$/;"	f
hash_iterator_init	list.c	/^hash_iterator_init (struct hash *hash,$/;"	f
hash_iterator_init_range	list.c	/^hash_iterator_init_range (struct hash *hash,$/;"	f
hash_iterator_lock	list.c	/^hash_iterator_lock (struct hash_iterator *hi, struct hash_bucket *b)$/;"	f	file:
hash_iterator_next	list.c	/^hash_iterator_next (struct hash_iterator *hi)$/;"	f
hash_iterator_unlock	list.c	/^hash_iterator_unlock (struct hash_iterator *hi)$/;"	f	file:
hash_lookup	list.h	/^hash_lookup (struct hash *hash, const void *key)$/;"	f
hash_lookup_fast	list.c	/^hash_lookup_fast (struct hash *hash,$/;"	f
hash_n_buckets	list.h	/^hash_n_buckets (const struct hash *hash)$/;"	f
hash_n_elements	list.h	/^hash_n_elements (const struct hash *hash)$/;"	f
hash_remove	list.h	/^hash_remove (struct hash *hash, const void *key)$/;"	f
hash_remove_by_value	list.c	/^hash_remove_by_value (struct hash *hash, void *value)$/;"	f
hash_remove_fast	list.c	/^hash_remove_fast (struct hash *hash,$/;"	f
hash_remove_marked	list.c	/^hash_remove_marked (struct hash *hash, struct hash_bucket *bucket)$/;"	f	file:
hash_table	pf.h	/^  struct hash *hash_table;$/;"	m	struct:pf_cn_set	typeref:struct:pf_cn_set::hash
hash_value	list.h	/^  unsigned int hash_value;$/;"	m	struct:hash_element
hash_value	list.h	/^hash_value (const struct hash *hash, const void *key)$/;"	f
hashmask	list.h	46;"	d
hashsize	list.h	45;"	d
head	buffer.h	/^  struct buffer_entry *head; \/* next item to pop\/peek *\/$/;"	m	struct:buffer_list	typeref:struct:buffer_list::buffer_entry
head	mbuf.h	/^  unsigned int head;$/;"	m	struct:mbuf_set
head	pushlist.h	/^  struct push_entry *head;$/;"	m	struct:push_list	typeref:struct:push_list::push_entry
header_modify_read_write_return	tun.c	/^header_modify_read_write_return (int len)$/;"	f	file:
helper_add_route	helper.c	/^helper_add_route (const in_addr_t network, const in_addr_t netmask, struct options *o)$/;"	f	file:
helper_client_server	helper.c	/^helper_client_server (struct options *o)$/;"	f
helper_keepalive	helper.c	/^helper_keepalive (struct options *o)$/;"	f
helper_tcp_nodelay	helper.c	/^helper_tcp_nodelay (struct options *o)$/;"	f
hlen	dhcp.h	/^  uint8_t  hlen;       \/* hardware address length (e.g. '6' for 10Mb Ethernet) *\/$/;"	m	struct:dhcp
hmac	crypto.h	/^  hmac_ctx_t *hmac;               \/**< Generic HMAC %context. *\/$/;"	m	struct:key_ctx
hmac	crypto.h	/^  uint8_t hmac[MAX_HMAC_KEY_LENGTH];$/;"	m	struct:key
hmac_ctx_cleanup	crypto_openssl.c	/^hmac_ctx_cleanup(HMAC_CTX *ctx)$/;"	f
hmac_ctx_cleanup	crypto_polarssl.c	/^hmac_ctx_cleanup(md_context_t *ctx)$/;"	f
hmac_ctx_final	crypto_openssl.c	/^hmac_ctx_final (HMAC_CTX *ctx, uint8_t *dst)$/;"	f
hmac_ctx_final	crypto_polarssl.c	/^hmac_ctx_final (md_context_t *ctx, uint8_t *dst)$/;"	f
hmac_ctx_init	crypto_openssl.c	/^hmac_ctx_init (HMAC_CTX *ctx, const uint8_t *key, int key_len,$/;"	f
hmac_ctx_init	crypto_polarssl.c	/^hmac_ctx_init (md_context_t *ctx, const uint8_t *key, int key_len, const md_info_t *kt)$/;"	f
hmac_ctx_reset	crypto_openssl.c	/^hmac_ctx_reset (HMAC_CTX *ctx)$/;"	f
hmac_ctx_reset	crypto_polarssl.c	/^hmac_ctx_reset (md_context_t *ctx)$/;"	f
hmac_ctx_size	crypto_openssl.c	/^hmac_ctx_size (const HMAC_CTX *ctx)$/;"	f
hmac_ctx_size	crypto_polarssl.c	/^hmac_ctx_size (const md_context_t *ctx)$/;"	f
hmac_ctx_t	crypto_openssl.h	/^typedef HMAC_CTX hmac_ctx_t;$/;"	t
hmac_ctx_t	crypto_polarssl.h	/^typedef md_context_t hmac_ctx_t;$/;"	t
hmac_ctx_update	crypto_openssl.c	/^hmac_ctx_update (HMAC_CTX *ctx, const uint8_t *src, int src_len)$/;"	f
hmac_ctx_update	crypto_polarssl.c	/^hmac_ctx_update (md_context_t *ctx, const uint8_t *src, int src_len)$/;"	f
hmac_length	crypto.h	/^  uint8_t hmac_length;		\/**< HMAC length, in bytes *\/$/;"	m	struct:key_type
hold	reliable.h	/^  bool hold; \/* don't xmit until reliable_schedule_now is called *\/$/;"	m	struct:reliable
hold_release	manage.h	/^  bool hold_release;$/;"	m	struct:man_persist
hop_limit	proto.h	/^        uint8_t		hop_limit;$/;"	m	struct:openvpn_ipv6hdr
hops	dhcp.h	/^  uint8_t  hops;       \/* client sets to 0, may be used by relay agents *\/$/;"	m	struct:dhcp
horizon	interval.h	/^  interval_t horizon;$/;"	m	struct:interval
host	Makefile	/^host = arm-none-linux-gnueabi$/;"	m
host	options.h	/^  char host[RH_HOST_LEN];$/;"	m	struct:remote_host_store
host_alias	Makefile	/^host_alias = arm-none-linux-gnueabi$/;"	m
host_cpu	Makefile	/^host_cpu = arm$/;"	m
host_os	Makefile	/^host_os = linux-gnueabi$/;"	m
host_triplet	Makefile	/^host_triplet = arm-none-linux-gnueabi$/;"	m
host_vendor	Makefile	/^host_vendor = none$/;"	m
hostname_randomize	misc.c	/^hostname_randomize(const char *hostname, struct gc_arena *gc)$/;"	f
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
hton_fragment_header_type	fragment.h	195;"	d
htonpid	packet_id.h	63;"	d
htonpid	packet_id.h	87;"	d
htonps	socket.h	64;"	d
htontime	packet_id.h	69;"	d
htontime	packet_id.h	89;"	d
http_proxy	openvpn.h	/^  struct http_proxy_info *http_proxy;$/;"	m	struct:context_1	typeref:struct:context_1::http_proxy_info
http_proxy	socket.h	/^  struct http_proxy_info *http_proxy;$/;"	m	struct:link_socket	typeref:struct:link_socket::http_proxy_info
http_proxy_close	proxy.c	/^http_proxy_close (struct http_proxy_info *hp)$/;"	f
http_proxy_info	proxy.h	/^struct http_proxy_info {$/;"	s
http_proxy_new	proxy.c	/^http_proxy_new (const struct http_proxy_options *o)$/;"	f
http_proxy_options	options.h	/^  struct http_proxy_options *http_proxy_options;$/;"	m	struct:connection_entry	typeref:struct:connection_entry::http_proxy_options
http_proxy_options	proxy.h	/^struct http_proxy_options {$/;"	s
http_proxy_options_simple	proxy.h	/^struct http_proxy_options_simple {$/;"	s
http_proxy_override	options.h	/^  struct http_proxy_options *http_proxy_override;$/;"	m	struct:options	typeref:struct:options::http_proxy_options
http_proxy_owned	openvpn.h	/^  bool http_proxy_owned;$/;"	m	struct:context_1
http_version	proxy.h	/^  const char *http_version;$/;"	m	struct:http_proxy_options
htype	dhcp.h	/^  uint8_t  htype;      \/* hardware address type (e.g. '1' = 10Mb Ethernet) *\/$/;"	m	struct:dhcp
hwaddr	route.h	/^  uint8_t hwaddr[6];$/;"	m	struct:route_gateway_info
iana_name	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	m	struct:__anon10
id	multi.c	/^id (struct multi_instance *mi)$/;"	f	file:
id	packet_id.h	/^  packet_id_type id;          \/* highest sequence number received *\/$/;"	m	struct:packet_id_rec
id	packet_id.h	/^  packet_id_type id;       \/* sequence number *\/$/;"	m	struct:packet_id_persist
id	packet_id.h	/^  packet_id_type id;       \/* sequence number *\/$/;"	m	struct:packet_id_persist_file_image
id	packet_id.h	/^  packet_id_type id;$/;"	m	struct:packet_id_net
id	packet_id.h	/^  packet_id_type id;$/;"	m	struct:packet_id_send
id	proto.h	/^  uint16_t   id;$/;"	m	struct:openvpn_iphdr
id	session_id.h	/^  uint8_t id[8];$/;"	m	struct:session_id
id_last_written	packet_id.h	/^  packet_id_type id_last_written;$/;"	m	struct:packet_id_persist
iface	route.h	/^  char iface[16]; \/* interface name (null terminated), may be empty *\/$/;"	m	struct:route_gateway_info
ifconfig_ipv6_local	options.h	/^  const char *ifconfig_ipv6_local;$/;"	m	struct:options
ifconfig_ipv6_netbits	options.h	/^  int         ifconfig_ipv6_netbits;$/;"	m	struct:options
ifconfig_ipv6_pool_base	options.h	/^  struct in6_addr ifconfig_ipv6_pool_base;		\/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr
ifconfig_ipv6_pool_defined	options.h	/^  bool   ifconfig_ipv6_pool_defined;			\/* IPv6 *\/$/;"	m	struct:options
ifconfig_ipv6_pool_netbits	options.h	/^  int    ifconfig_ipv6_pool_netbits;			\/* IPv6 *\/$/;"	m	struct:options
ifconfig_ipv6_remote	options.h	/^  const char *ifconfig_ipv6_remote;$/;"	m	struct:options
ifconfig_local	options.h	/^  const char *ifconfig_local;$/;"	m	struct:options
ifconfig_noexec	options.h	/^  bool ifconfig_noexec;$/;"	m	struct:options
ifconfig_nowarn	options.h	/^  bool ifconfig_nowarn;$/;"	m	struct:options
ifconfig_options_string	tun.c	/^ifconfig_options_string (const struct tuntap* tt, bool remote, bool disable, struct gc_arena *gc)$/;"	f
ifconfig_order	tun.h	/^ifconfig_order(void)$/;"	f
ifconfig_pool	multi.h	/^  struct ifconfig_pool *ifconfig_pool;$/;"	m	struct:multi_context	typeref:struct:multi_context::ifconfig_pool
ifconfig_pool	pool.h	/^struct ifconfig_pool$/;"	s
ifconfig_pool_acquire	pool.c	/^ifconfig_pool_acquire (struct ifconfig_pool *pool, in_addr_t *local, in_addr_t *remote, struct in6_addr *remote_ipv6, const char *common_name)$/;"	f
ifconfig_pool_defined	options.h	/^  bool ifconfig_pool_defined;$/;"	m	struct:options
ifconfig_pool_end	options.h	/^  in_addr_t ifconfig_pool_end;$/;"	m	struct:options
ifconfig_pool_entry	pool.h	/^struct ifconfig_pool_entry$/;"	s
ifconfig_pool_entry_free	pool.c	/^ifconfig_pool_entry_free (struct ifconfig_pool_entry *ipe, bool hard)$/;"	f	file:
ifconfig_pool_find	pool.c	/^ifconfig_pool_find (struct ifconfig_pool *pool, const char *common_name)$/;"	f	file:
ifconfig_pool_free	pool.c	/^ifconfig_pool_free (struct ifconfig_pool *pool)$/;"	f
ifconfig_pool_handle	pool.h	/^typedef int ifconfig_pool_handle;$/;"	t
ifconfig_pool_handle_to_ip_base	pool.c	/^ifconfig_pool_handle_to_ip_base (const struct ifconfig_pool* pool, ifconfig_pool_handle hand)$/;"	f	file:
ifconfig_pool_handle_to_ipv6_base	pool.c	/^ifconfig_pool_handle_to_ipv6_base (const struct ifconfig_pool* pool, ifconfig_pool_handle hand)$/;"	f	file:
ifconfig_pool_init	pool.c	/^ifconfig_pool_init (int type, in_addr_t start, in_addr_t end, $/;"	f
ifconfig_pool_ip_base_to_handle	pool.c	/^ifconfig_pool_ip_base_to_handle (const struct ifconfig_pool* pool, const in_addr_t addr)$/;"	f	file:
ifconfig_pool_list	pool.c	/^ifconfig_pool_list (const struct ifconfig_pool* pool, struct status_output *out)$/;"	f	file:
ifconfig_pool_msg	pool.c	/^ifconfig_pool_msg (const struct ifconfig_pool* pool, int msglevel)$/;"	f	file:
ifconfig_pool_netmask	options.h	/^  in_addr_t ifconfig_pool_netmask;$/;"	m	struct:options
ifconfig_pool_persist	openvpn.h	/^  struct ifconfig_pool_persist *ifconfig_pool_persist;$/;"	m	struct:context_1	typeref:struct:context_1::ifconfig_pool_persist
ifconfig_pool_persist	pool.h	/^struct ifconfig_pool_persist$/;"	s
ifconfig_pool_persist_close	pool.c	/^ifconfig_pool_persist_close (struct ifconfig_pool_persist *persist)$/;"	f
ifconfig_pool_persist_filename	options.h	/^  const char *ifconfig_pool_persist_filename;$/;"	m	struct:options
ifconfig_pool_persist_init	pool.c	/^ifconfig_pool_persist_init (const char *filename, int refresh_freq)$/;"	f
ifconfig_pool_persist_owned	openvpn.h	/^  bool ifconfig_pool_persist_owned;$/;"	m	struct:context_1
ifconfig_pool_persist_refresh_freq	options.h	/^  int ifconfig_pool_persist_refresh_freq;$/;"	m	struct:options
ifconfig_pool_read	pool.c	/^ifconfig_pool_read (struct ifconfig_pool_persist *persist, struct ifconfig_pool *pool)$/;"	f
ifconfig_pool_release	pool.c	/^ifconfig_pool_release (struct ifconfig_pool* pool, ifconfig_pool_handle hand, const bool hard)$/;"	f
ifconfig_pool_set	pool.c	/^ifconfig_pool_set (struct ifconfig_pool* pool, const char *cn, const in_addr_t addr, const bool fixed)$/;"	f	file:
ifconfig_pool_start	options.h	/^  in_addr_t ifconfig_pool_start;$/;"	m	struct:options
ifconfig_pool_test	pool.c	/^ifconfig_pool_test (in_addr_t start, in_addr_t end)$/;"	f
ifconfig_pool_verify_range	pool.c	/^ifconfig_pool_verify_range (const int msglevel, const in_addr_t start, const in_addr_t end)$/;"	f
ifconfig_pool_write	pool.c	/^ifconfig_pool_write (struct ifconfig_pool_persist *persist, const struct ifconfig_pool *pool)$/;"	f
ifconfig_pool_write_trigger	pool.c	/^ifconfig_pool_write_trigger (struct ifconfig_pool_persist *persist)$/;"	f
ifconfig_push_constraint_satisfied	multi.c	/^ifconfig_push_constraint_satisfied (const struct context *c)$/;"	f	file:
ifconfig_remote_netmask	options.h	/^  const char *ifconfig_remote_netmask;$/;"	m	struct:options
ifconfig_sanity_check	tun.c	/^ifconfig_sanity_check (bool tun, in_addr_t addr, int topology)$/;"	f	file:
ifconfig_warn_how_to_silence	tun.c	/^static const char ifconfig_warn_how_to_silence[] = "(silence this warning with --ifconfig-nowarn)";$/;"	v	file:
iflags	route.h	/^  unsigned int iflags;$/;"	m	struct:route_list
ignore_sys_error	error.h	/^ignore_sys_error (const int err)$/;"	f
ignore_unknown_option	options.h	/^  const char **  ignore_unknown_option;$/;"	m	struct:options
in	manage.h	/^  struct command_line *in;$/;"	m	struct:man_connection	typeref:struct:man_connection::command_line
in	win32.h	/^  struct rw_handle in;$/;"	m	struct:win32_signal	typeref:struct:win32_signal::rw_handle
in4	socket.h	/^    struct in_pktinfo in4;$/;"	m	union:link_socket_actual::__anon9	typeref:struct:link_socket_actual::__anon9::in_pktinfo
in4	socket.h	/^    struct sockaddr_in in4;$/;"	m	union:openvpn_sockaddr::__anon8	typeref:struct:openvpn_sockaddr::__anon8::sockaddr_in
in6	socket.h	/^    struct in6_pktinfo in6;$/;"	m	union:link_socket_actual::__anon9	typeref:struct:link_socket_actual::__anon9::in6_pktinfo
in6	socket.h	/^    struct sockaddr_in6 in6;$/;"	m	union:openvpn_sockaddr::__anon8	typeref:struct:openvpn_sockaddr::__anon8::sockaddr_in6
in_addr_t_from_mroute_addr	mroute.h	/^in_addr_t_from_mroute_addr (const struct mroute_addr *addr)$/;"	f
in_extra	manage.h	/^  struct buffer_list *in_extra;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list
in_extra_cid	manage.h	/^  unsigned long in_extra_cid;$/;"	m	struct:man_connection
in_extra_cmd	manage.h	/^  int in_extra_cmd;$/;"	m	struct:man_connection
in_extra_dispatch	manage.c	/^in_extra_dispatch (struct management *man)$/;"	f	file:
in_extra_kid	manage.h	/^  unsigned int in_extra_kid;$/;"	m	struct:man_connection
in_extra_reset	manage.c	/^in_extra_reset (struct man_connection *mc, const int mode)$/;"	f	file:
in_key	crypto.h	/^  int in_key;                   \/**< Index into the \\c key2.keys array for$/;"	m	struct:key_direction_state
in_src	options.c	/^struct in_src {$/;"	s	file:
in_src_get	options.c	/^in_src_get (const struct in_src *is, char *line, const int size)$/;"	f	file:
in_use	pool.h	/^  bool in_use;$/;"	m	struct:ifconfig_pool_entry
inactivity_bytes	openvpn.h	/^  int inactivity_bytes;$/;"	m	struct:context_2
inactivity_interval	openvpn.h	/^  struct event_timeout inactivity_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
inactivity_minimum_bytes	options.h	/^  int inactivity_minimum_bytes;$/;"	m	struct:options
inactivity_timeout	options.h	/^  int inactivity_timeout;       \/* --inactive *\/$/;"	m	struct:options
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
incoming	fragment.h	/^  struct fragment_list incoming;$/;"	m	struct:fragment_master	typeref:struct:fragment_master::fragment_list
incoming_push_message	push.c	/^incoming_push_message (struct context *c, const struct buffer *buffer)$/;"	f
index	fragment.h	/^  int index;                    \/**< Index of the packet being reassembled$/;"	m	struct:fragment_list
index_verify	integer.h	/^index_verify (int index, int size, const char *file, int line)$/;"	f
inetd	options.h	/^  int inetd;$/;"	m	struct:options
inetd	socket.h	/^  int inetd;$/;"	m	struct:link_socket
inetd_socket_descriptor	misc.c	/^int inetd_socket_descriptor = SOCKET_UNDEFINED; \/* GLOBAL *\/$/;"	v
info	socket.h	/^  struct link_socket_info info;$/;"	m	struct:link_socket	typeref:struct:link_socket::link_socket_info
info_callback	ssl_openssl.c	/^info_callback (INFO_CALLBACK_SSL_CONST SSL * s, int where, int ret)$/;"	f	file:
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
inherit_context_child	init.c	/^inherit_context_child (struct context *dest,$/;"	f
inherit_context_top	init.c	/^inherit_context_top (struct context *dest,$/;"	f
init	cryptoapi.c	/^static int init(RSA *rsa)$/;"	f	file:
init_connection_list	init.c	/^init_connection_list (struct context *c)$/;"	f	file:
init_context_buffers	init.c	/^init_context_buffers (const struct frame *frame)$/;"	f
init_crypto_pre	init.c	/^init_crypto_pre (struct context *c, const unsigned int flags)$/;"	f	file:
init_http_proxy_options_once	proxy.c	/^init_http_proxy_options_once (struct http_proxy_options **hpo,$/;"	f
init_instance	init.c	/^init_instance (struct context *c, const struct env_set *env, const unsigned int flags)$/;"	f
init_instance_handle_signals	init.c	/^init_instance_handle_signals (struct context *c, const struct env_set *env, const unsigned int flags)$/;"	f
init_ip_addr_string2	tun.c	/^init_ip_addr_string2 (IP_ADDR_STRING *dest, const IP_ADDR_STRING *src1, const IP_ADDR_STRING *src2)$/;"	f	file:
init_key_ctx	crypto.c	/^init_key_ctx (struct key_ctx *ctx, struct key *key,$/;"	f
init_key_type	crypto.c	/^init_key_type (struct key_type *kt, const char *ciphername,$/;"	f
init_management	init.c	/^init_management (struct context *c)$/;"	f
init_management_callback_multi	multi.c	/^init_management_callback_multi (struct multi_context *m)$/;"	f
init_management_callback_p2p	init.c	/^init_management_callback_p2p (struct context *c)$/;"	f
init_net_event_win32	win32.c	/^init_net_event_win32 (struct rw_handle *event, long network_events, socket_descriptor_t sd, unsigned int flags)$/;"	f
init_options	options.c	/^init_options (struct options *o, const bool init_gc)$/;"	f
init_options_dev	init.c	/^init_options_dev (struct options *options)$/;"	f
init_plugins	init.c	/^init_plugins (struct context *c)$/;"	f
init_port_share	init.c	/^init_port_share (struct context *c)$/;"	f	file:
init_proxy	init.c	/^init_proxy (struct context *c, const int scope)$/;"	f	file:
init_proxy_dowork	init.c	/^init_proxy_dowork (struct context *c)$/;"	f	file:
init_query_passwords	init.c	/^init_query_passwords (struct context *c)$/;"	f	file:
init_random_seed	misc.c	/^init_random_seed(void)$/;"	f
init_route	route.c	/^init_route (struct route_ipv4 *r,$/;"	f	file:
init_route_ipv6	route.c	/^init_route_ipv6 (struct route_ipv6 *r6,$/;"	f	file:
init_route_ipv6_list	route.c	/^init_route_ipv6_list (struct route_ipv6_list *rl6,$/;"	f
init_route_list	route.c	/^init_route_list (struct route_list *rl,$/;"	f
init_security_attributes_allow_all	win32.c	/^init_security_attributes_allow_all (struct security_attributes *obj)$/;"	f
init_ssl	ssl.c	/^init_ssl (const struct options *options, struct tls_root_ctx *new_ctx)$/;"	f
init_ssl_lib	crypto.c	/^init_ssl_lib (void)$/;"	f
init_ssl_lib	ssl.c	/^init_ssl_lib ()$/;"	f
init_static	init.c	/^init_static (void)$/;"	f
init_tun	tun.c	/^init_tun (const char *dev,       \/* --dev option *\/$/;"	f
init_tun_post	tun.c	/^init_tun_post (struct tuntap *tt,$/;"	f
init_verb_mute	init.c	/^init_verb_mute (struct context *c, unsigned int flags)$/;"	f
init_win32	win32.c	/^init_win32 (void)$/;"	f
initial_opcode	ssl_common.h	/^  int initial_opcode;		\/* our initial P_ opcode *\/$/;"	m	struct:key_state
initial_opcode	ssl_common.h	/^  int initial_opcode;		\/* our initial P_ opcode *\/$/;"	m	struct:tls_session
initial_timeout	reliable.h	/^  interval_t initial_timeout;$/;"	m	struct:reliable
initialised	ssl_polarssl.h	/^    bool initialised; 		\/**< True if the context has been initialised *\/$/;"	m	struct:tls_root_ctx
initialization_point	plugin.h	/^  openvpn_plugin_select_initialization_point_v1 initialization_point;$/;"	m	struct:plugin
initialization_sequence_completed	init.c	/^initialization_sequence_completed (struct context *c, const unsigned int flags)$/;"	f
initialized	gremlin.c	/^static bool initialized; \/* GLOBAL *\/$/;"	v	file:
initialized	packet_id.h	/^  bool initialized;           \/* true if packet_id_init was called *\/$/;"	m	struct:packet_id_rec
initialized	plugin.h	/^  bool initialized;$/;"	m	struct:plugin
inline	syshead.h	379;"	d
inline	syshead.h	380;"	d
ins	schedule.c	/^  int ins;$/;"	m	struct:status	file:
install_sh	Makefile	/^install_sh = ${SHELL} \/root\/WORK\/kedaVPN\/arm-vpn\/openvpn-2.3.4\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
instance	mbuf.h	/^  struct multi_instance *instance;$/;"	m	struct:mbuf_item	typeref:struct:mbuf_item::multi_instance
instance	multi.h	/^  struct multi_instance *instance;$/;"	m	struct:multi_route	typeref:struct:multi_route::multi_instance
interval	interval.h	/^struct interval$/;"	s
interval_action	interval.h	/^interval_action (struct interval* top)$/;"	f
interval_earliest_wakeup	otime.h	/^interval_earliest_wakeup (interval_t *wakeup, time_t at, time_t current) {$/;"	f
interval_future_trigger	interval.h	/^interval_future_trigger (struct interval* top, interval_t wakeup) {$/;"	f
interval_init	interval.c	/^interval_init (struct interval *top, int horizon, int refresh)$/;"	f
interval_schedule_wakeup	interval.h	/^interval_schedule_wakeup (struct interval* top, interval_t *wakeup)$/;"	f
interval_t	common.h	/^typedef int interval_t;$/;"	t
interval_test	interval.h	/^interval_test (struct interval* top)$/;"	f
intval	manage.h	/^  int intval;$/;"	m	union:log_entry_union
io_wait	forward-inline.h	/^io_wait (struct context *c, const unsigned int flags)$/;"	f
io_wait_dowork	forward.c	/^io_wait_dowork (struct context *c, const unsigned int flags)$/;"	f
iostate	win32.h	/^  int iostate;$/;"	m	struct:overlapped_io
ip	dhcp.h	/^  struct openvpn_iphdr ip;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::openvpn_iphdr
ip	proto.h	/^  struct openvpn_iphdr ip;$/;"	m	struct:ip_tcp_udp_hdr	typeref:struct:ip_tcp_udp_hdr::openvpn_iphdr
ip_addr_dotted_quad_safe	socket.c	/^ip_addr_dotted_quad_safe (const char *dotted_quad)$/;"	f
ip_addr_member_of	tun.c	/^ip_addr_member_of (const in_addr_t addr, const IP_ADDR_STRING *ias)$/;"	f	file:
ip_addr_one_to_one	tun.c	/^ip_addr_one_to_one (const in_addr_t *a1, const int a1len, const IP_ADDR_STRING *ias)$/;"	f	file:
ip_addr_string_to_array	tun.c	/^ip_addr_string_to_array (in_addr_t *dest, int *dest_len, const IP_ADDR_STRING *src)$/;"	f
ip_dest	proto.h	/^  in_addr_t ip_dest;$/;"	m	struct:openvpn_arp
ip_fd	tun.h	/^  int ip_fd;$/;"	m	struct:tuntap
ip_or_dns_addr_safe	socket.c	/^ip_or_dns_addr_safe (const char *addr, const bool allow_fqdn)$/;"	f
ip_src	proto.h	/^  in_addr_t ip_src;$/;"	m	struct:openvpn_arp
ip_tcp_udp_hdr	proto.h	/^struct ip_tcp_udp_hdr {$/;"	s
ip_win32_defined	tun.h	/^  bool ip_win32_defined;$/;"	m	struct:tuntap_options
ip_win32_type	tun.h	/^  int ip_win32_type;$/;"	m	struct:tuntap_options
ipapi_context	tun.h	/^  ULONG ipapi_context;$/;"	m	struct:tuntap
ipapi_context_defined	tun.h	/^  bool ipapi_context_defined;$/;"	m	struct:tuntap
ipapi_instance	tun.h	/^  ULONG ipapi_instance;$/;"	m	struct:tuntap
ipchange	options.h	/^  const char *ipchange;$/;"	m	struct:options
ipchange_command	socket.h	/^  const char *ipchange_command;$/;"	m	struct:link_socket_info
ipchange_fmt	socket.c	/^ipchange_fmt (const bool include_cmd, struct argv *argv, const struct link_socket_info *info, struct gc_arena *gc)$/;"	f	file:
ipconfig_register_dns	tun.c	/^ipconfig_register_dns (const struct env_set *es)$/;"	f
iproute_path	misc.c	/^const char *iproute_path = IPROUTE_PATH; \/* GLOBAL *\/$/;"	v
ipset2ascii	tun.c	/^ipset2ascii (int index)$/;"	f
ipset2ascii_all	tun.c	/^ipset2ascii_all (struct gc_arena *gc)$/;"	f
ipset_names	tun.c	/^static const struct ipset_names ipset_names[] = {$/;"	v	typeref:struct:ipset_names	file:
ipset_names	tun.c	/^struct ipset_names {$/;"	s	file:
ipv4_packet_size_verify	proto.c	/^ipv4_packet_size_verify (const uint8_t *data,$/;"	f
ipv4_subnet	pf.h	/^struct ipv4_subnet {$/;"	s
ipv4_tun	openvpn.h	/^  bool ipv4_tun;$/;"	m	struct:context_2
ipv6	pool.h	/^  bool ipv6;$/;"	m	struct:ifconfig_pool
ipv6	tun.h	/^  bool ipv6;$/;"	m	struct:tuntap
ipv6_addr_safe	socket.c	/^ipv6_addr_safe (const char *ipv6_text_addr)$/;"	f
ipv6_addr_safe_hexplusbits	options.c	/^static bool ipv6_addr_safe_hexplusbits( const char * ipv6_prefix_spec )$/;"	f	file:
iroute	route.h	/^struct iroute {$/;"	s
iroute_ipv6	route.h	/^struct iroute_ipv6 {$/;"	s
iroutes	options.h	/^  struct iroute *iroutes;$/;"	m	struct:options	typeref:struct:options::iroute
iroutes_ipv6	options.h	/^  struct iroute_ipv6 *iroutes_ipv6;			\/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::iroute_ipv6
is_adapter_up	tun.c	/^is_adapter_up (const struct tuntap *tt, const IP_ADAPTER_INFO *list)$/;"	f
is_dev_type	tun.c	/^is_dev_type (const char *dev, const char *dev_type, const char *match_type)$/;"	f
is_dgram	socket.c	/^  bool	is_dgram;$/;"	m	struct:proto_names	file:
is_hard_reset	ssl.c	/^is_hard_reset (int op, int key_method)$/;"	f	file:
is_ip_in_adapter_subnet	tun.c	/^is_ip_in_adapter_subnet (const IP_ADAPTER_INFO *ai, const in_addr_t ip, in_addr_t *highest_netmask)$/;"	f
is_ipv4	proto.c	/^is_ipv4 (int tunnel_type, struct buffer *buf)$/;"	f
is_ipv6	proto.c	/^is_ipv6 (int tunnel_type, struct buffer *buf)$/;"	f
is_ipv_X	proto.c	/^is_ipv_X ( int tunnel_type, struct buffer *buf, int ip_ver )$/;"	f	file:
is_mac_mcast_addr	mroute.c	/^is_mac_mcast_addr (const uint8_t *mac)$/;"	f	file:
is_mac_mcast_maddr	mroute.c	/^is_mac_mcast_maddr (const struct mroute_addr *addr)$/;"	f	file:
is_net	socket.c	/^  bool	is_net;$/;"	m	struct:proto_names	file:
is_occ_msg	occ.h	/^is_occ_msg (const struct buffer* buf)$/;"	f
is_on_link	route.c	/^is_on_link (const int is_local_route, const unsigned int flags, const struct route_gateway_info *rgi)$/;"	f	file:
is_openvpn_protocol	ps.c	/^is_openvpn_protocol (const struct buffer *buf)$/;"	f
is_password_env_var	misc.c	/^is_password_env_var (const char *str)$/;"	f	file:
is_ping_msg	ping.h	/^is_ping_msg (const struct buffer* buf)$/;"	f
is_route_parm_defined	route.c	/^is_route_parm_defined (const char *parm)$/;"	f	file:
is_special_addr	route.c	/^is_special_addr (const char *addr_str)$/;"	f
is_tap_win	tun.c	/^is_tap_win (const char *guid, const struct tap_reg *tap_reg)$/;"	f	file:
is_tun_p2p	tun.c	/^is_tun_p2p (const struct tuntap *tt)$/;"	f
is_utun	tun.h	/^  bool is_utun;$/;"	m	struct:tuntap
iter	multi.h	/^  struct hash *iter;            \/**< VPN tunnel instances indexed by real$/;"	m	struct:multi_context	typeref:struct:multi_context::hash
iv	list.h	/^  uint32_t iv;$/;"	m	struct:hash
jfn	ps.c	/^  char *jfn;$/;"	m	struct:proxy_connection	file:
journal_add	ps.c	/^journal_add (const char *journal_dir, struct proxy_connection *pc, struct proxy_connection *cp)$/;"	f	file:
keepalive_ping	options.h	/^  int keepalive_ping;           \/* a proxy for ping\/ping-restart *\/$/;"	m	struct:options
keepalive_timeout	options.h	/^  int keepalive_timeout;$/;"	m	struct:options
key	crypto.h	/^struct key$/;"	s
key	list.h	/^  const void *key;$/;"	m	struct:hash_element
key	ssl_common.h	/^  struct key_ctx_bi key;	       \/* data channel keys for encrypt\/decrypt\/hmac *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_ctx_bi
key	ssl_common.h	/^  struct key_state key[KS_SIZE];$/;"	m	struct:tls_session	typeref:struct:tls_session::key_state
key2	crypto.h	/^struct key2$/;"	s
key2_print	crypto.c	/^key2_print (const struct key2* k,$/;"	f
key_ctx	crypto.h	/^struct key_ctx$/;"	s
key_ctx_bi	crypto.h	/^  struct key_ctx_bi *key_ctx_bi;$/;"	m	struct:crypto_options	typeref:struct:crypto_options::key_ctx_bi
key_ctx_bi	crypto.h	/^struct key_ctx_bi$/;"	s
key_ctx_bi_defined	crypto.h	/^key_ctx_bi_defined(const struct key_ctx_bi* key)$/;"	f
key_des_check	crypto_openssl.c	/^key_des_check (uint8_t *key, int key_len, int ndc)$/;"	f
key_des_check	crypto_polarssl.c	/^key_des_check (uint8_t *key, int key_len, int ndc)$/;"	f
key_des_fixup	crypto_openssl.c	/^key_des_fixup (uint8_t *key, int key_len, int ndc)$/;"	f
key_des_fixup	crypto_polarssl.c	/^key_des_fixup (uint8_t *key, int key_len, int ndc)$/;"	f
key_des_num_cblocks	crypto_openssl.c	/^key_des_num_cblocks (const EVP_CIPHER *kt)$/;"	f
key_des_num_cblocks	crypto_polarssl.c	/^key_des_num_cblocks (const cipher_info_t *kt)$/;"	f
key_direction	options.h	/^  int key_direction;$/;"	m	struct:options
key_direction_state	crypto.h	/^struct key_direction_state$/;"	s
key_direction_state_init	crypto.c	/^key_direction_state_init (struct key_direction_state *kds, int key_direction)$/;"	f
key_id	ssl_common.h	/^  int key_id;			\/* increments with each soft reset (for key renegotiation) *\/$/;"	m	struct:tls_session
key_id	ssl_common.h	/^  int key_id;			\/* inherited from struct tls_session below *\/$/;"	m	struct:key_state
key_is_zero	crypto.c	/^key_is_zero (struct key *key, const struct key_type *kt)$/;"	f	file:
key_method	options.h	/^  int key_method;$/;"	m	struct:options
key_method	ssl_common.h	/^  int key_method;$/;"	m	struct:tls_options
key_method_1_read	ssl.c	/^key_method_1_read (struct buffer *buf, struct tls_session *session)$/;"	f	file:
key_method_1_write	ssl.c	/^key_method_1_write (struct buffer *buf, struct tls_session *session)$/;"	f	file:
key_method_2_read	ssl.c	/^key_method_2_read (struct buffer *buf, struct tls_multi *multi, struct tls_session *session)$/;"	f	file:
key_method_2_write	ssl.c	/^key_method_2_write (struct buffer *buf, struct tls_session *session)$/;"	f	file:
key_pass_file	options.h	/^  const char *key_pass_file;$/;"	m	struct:options
key_scan	ssl_common.h	/^  struct key_state* key_scan[KEY_SCAN_SIZE];$/;"	m	struct:tls_multi	typeref:struct:tls_multi::key_state
key_schedule	openvpn.h	/^struct key_schedule$/;"	s
key_schedule_free	init.c	/^key_schedule_free (struct key_schedule *ks, bool free_ssl_ctx)$/;"	f	file:
key_source	ssl_common.h	/^struct key_source {$/;"	s
key_source2	ssl_common.h	/^struct key_source2 {$/;"	s
key_source2_print	ssl.c	/^key_source2_print (const struct key_source2 *k)$/;"	f	file:
key_source2_randomize_write	ssl.c	/^key_source2_randomize_write (struct key_source2 *k2,$/;"	f	file:
key_source2_read	ssl.c	/^key_source2_read (struct key_source2 *k2,$/;"	f	file:
key_source_print	ssl.c	/^key_source_print (const struct key_source *k,$/;"	f	file:
key_spec	cryptoapi.c	/^    DWORD key_spec;$/;"	m	struct:_CAPI_DATA	file:
key_src	ssl_common.h	/^  struct key_source2 *key_src;         \/* source entropy for key expansion *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_source2
key_state	ssl_common.h	/^struct key_state$/;"	s
key_state_free	ssl.c	/^key_state_free (struct key_state *ks, bool clear)$/;"	f	file:
key_state_gen_auth_control_file	ssl_verify.c	/^key_state_gen_auth_control_file (struct key_state *ks, const struct tls_options *opt)$/;"	f	file:
key_state_init	ssl.c	/^key_state_init (struct tls_session *session, struct key_state *ks)$/;"	f	file:
key_state_read_ciphertext	ssl_openssl.c	/^key_state_read_ciphertext (struct key_state_ssl *ks_ssl, struct buffer *buf,$/;"	f
key_state_read_ciphertext	ssl_polarssl.c	/^key_state_read_ciphertext (struct key_state_ssl *ks, struct buffer *buf,$/;"	f
key_state_read_plaintext	ssl_openssl.c	/^key_state_read_plaintext (struct key_state_ssl *ks_ssl, struct buffer *buf,$/;"	f
key_state_read_plaintext	ssl_polarssl.c	/^key_state_read_plaintext (struct key_state_ssl *ks, struct buffer *buf,$/;"	f
key_state_rm_auth_control_file	ssl_verify.c	/^key_state_rm_auth_control_file (struct key_state *ks)$/;"	f
key_state_soft_reset	ssl.c	/^key_state_soft_reset (struct tls_session *session)$/;"	f	file:
key_state_ssl	ssl_openssl.h	/^struct key_state_ssl {$/;"	s
key_state_ssl	ssl_polarssl.h	/^struct key_state_ssl {$/;"	s
key_state_ssl_free	ssl_openssl.c	/^void key_state_ssl_free(struct key_state_ssl *ks_ssl)$/;"	f
key_state_ssl_free	ssl_polarssl.c	/^key_state_ssl_free(struct key_state_ssl *ks_ssl)$/;"	f
key_state_ssl_init	ssl_openssl.c	/^key_state_ssl_init(struct key_state_ssl *ks_ssl, const struct tls_root_ctx *ssl_ctx, bool is_server, struct tls_session *session)$/;"	f
key_state_ssl_init	ssl_polarssl.c	/^void key_state_ssl_init(struct key_state_ssl *ks_ssl,$/;"	f
key_state_test_auth_control_file	ssl_verify.c	/^key_state_test_auth_control_file (struct key_state *ks)$/;"	f	file:
key_state_write_ciphertext	ssl_openssl.c	/^key_state_write_ciphertext (struct key_state_ssl *ks_ssl, struct buffer *buf)$/;"	f
key_state_write_ciphertext	ssl_polarssl.c	/^key_state_write_ciphertext (struct key_state_ssl *ks, struct buffer *buf)$/;"	f
key_state_write_plaintext	ssl_openssl.c	/^key_state_write_plaintext (struct key_state_ssl *ks_ssl, struct buffer *buf)$/;"	f
key_state_write_plaintext	ssl_polarssl.c	/^key_state_write_plaintext (struct key_state_ssl *ks, struct buffer *buf)$/;"	f
key_state_write_plaintext_const	ssl_openssl.c	/^key_state_write_plaintext_const (struct key_state_ssl *ks_ssl, const uint8_t *data, int len)$/;"	f
key_state_write_plaintext_const	ssl_polarssl.c	/^key_state_write_plaintext_const (struct key_state_ssl *ks, const uint8_t *data, int len)$/;"	f
key_type	crypto.h	/^struct key_type$/;"	s
key_type	openvpn.h	/^  struct key_type key_type;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_type
key_type	ssl_common.h	/^  struct key_type key_type;$/;"	m	struct:tls_options	typeref:struct:tls_options::key_type
keyboard_input_available	win32.c	/^keyboard_input_available (struct win32_signal *ws)$/;"	f	file:
keyboard_ir_to_key	win32.c	/^keyboard_ir_to_key (INPUT_RECORD *ir)$/;"	f	file:
keydirection2ascii	crypto.c	/^keydirection2ascii (int kd, bool remote)$/;"	f
keys	crypto.h	/^  struct key keys[2];           \/**< Two unidirectional sets of %key$/;"	m	struct:key2	typeref:struct:key2::key
keysize	options.h	/^  int keysize;$/;"	m	struct:options
kill	pf.h	/^  bool kill;$/;"	m	struct:pf_set
kill_by_addr	manage.h	/^  int (*kill_by_addr) (void *arg, const in_addr_t addr, const int port);$/;"	m	struct:management_callback
kill_by_cid	manage.h	/^  bool (*kill_by_cid) (void *arg, const unsigned long cid, const char *kill_msg);$/;"	m	struct:management_callback
kill_by_cn	manage.h	/^  int (*kill_by_cn) (void *arg, const char *common_name);$/;"	m	struct:management_callback
ks	openvpn.h	/^  struct key_schedule ks;$/;"	m	struct:context_1	typeref:struct:context_1::key_schedule
ks_ssl	ssl_common.h	/^  struct key_state_ssl ks_ssl;	\/* contains SSL object and BIOs for the control channel *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_state_ssl
lame_duck_must_die	ssl.c	/^lame_duck_must_die (const struct tls_session* session, interval_t *wakeup)$/;"	f	file:
last	interval.h	/^  time_t last; \/* time of last event *\/$/;"	m	struct:event_timeout
last	list.h	/^  struct hash_element *last;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_element
last_action	interval.h	/^  time_t last_action;$/;"	m	struct:interval
last_block	ssl_polarssl.h	/^    buffer_entry *last_block;$/;"	m	struct:__anon2
last_call	multi.h	/^  time_t last_call;$/;"	m	struct:multi_reap
last_reap	packet_id.h	/^  time_t last_reap;           \/* last call of packet_id_reap *\/$/;"	m	struct:packet_id_rec
last_reference	multi.h	/^  time_t last_reference;$/;"	m	struct:multi_route
last_release	pool.h	/^  time_t last_release;$/;"	m	struct:ifconfig_pool_entry
last_test_true	interval.h	/^  time_t last_test_true;$/;"	m	struct:interval
learn_address_script	multi.c	/^learn_address_script (const struct multi_context *m,$/;"	f	file:
learn_address_script	options.h	/^  const char *learn_address_script;$/;"	m	struct:options
legal_ipv4_port	socket.h	/^legal_ipv4_port (int port)$/;"	f
len	buffer.h	/^  int len;                      \/**< Length in bytes of the actual content$/;"	m	struct:buffer
len	mbuf.h	/^  unsigned int len;$/;"	m	struct:mbuf_set
len	mroute.h	/^  uint8_t len;      \/* length of address *\/$/;"	m	struct:mroute_addr
len	options.h	/^  int len;$/;"	m	struct:connection_list
len	options.h	/^  int len;$/;"	m	struct:remote_list
len	proto.h	/^  uint16_t   len;$/;"	m	struct:openvpn_udphdr
len	reliable.h	/^  int len;$/;"	m	struct:reliable_ack
len	socket.h	/^  int len;     \/* -1 if not yet known *\/$/;"	m	struct:stream_buf
length	ssl_polarssl.h	/^    size_t length;$/;"	m	struct:_buffer_entry
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdl_resolve_symbol	plugin.c	/^libdl_resolve_symbol (void *handle, void **dest, const char *symbol, const char *plugin_name, const unsigned int flags)$/;"	f	file:
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
likely	syshead.h	33;"	d
likely	syshead.h	36;"	d
limit_next	ssl_common.h	/^  int limit_next;               \/* used for traffic shaping on the control channel *\/$/;"	m	struct:tls_session
link_mtu	mtu.h	/^  int link_mtu;                 \/**< Maximum packet size to be sent over$/;"	m	struct:frame
link_mtu	options.h	/^  int link_mtu;          \/* MTU of device over which tunnel packets pass via TCP\/UDP *\/$/;"	m	struct:connection_entry
link_mtu_defined	options.h	/^  bool link_mtu_defined; \/* true if user overriding parm with command line option *\/$/;"	m	struct:connection_entry
link_mtu_dynamic	mtu.h	/^  int link_mtu_dynamic;         \/**< Dynamic MTU value for the external$/;"	m	struct:frame
link_read_bytes	mstats.h	/^  counter_type link_read_bytes;   \/* counter_type can be assumed to be a uint64_t *\/$/;"	m	struct:mmap_stats
link_read_bytes	openvpn.h	/^  counter_type link_read_bytes;$/;"	m	struct:context_2
link_read_bytes_auth	openvpn.h	/^  counter_type link_read_bytes_auth;$/;"	m	struct:context_2
link_read_bytes_global	forward.c	/^counter_type link_read_bytes_global;  \/* GLOBAL *\/$/;"	v
link_socket	openvpn.h	/^  struct link_socket *link_socket;	 \/* socket used for TCP\/UDP connection to remote *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket
link_socket	socket.h	/^struct link_socket$/;"	s
link_socket_actual	socket.h	/^struct link_socket_actual$/;"	s
link_socket_actual_defined	socket.h	/^link_socket_actual_defined (const struct link_socket_actual *act)$/;"	f
link_socket_actual_match	socket.h	/^link_socket_actual_match (const struct link_socket_actual *a1, const struct link_socket_actual *a2)$/;"	f
link_socket_addr	openvpn.h	/^  struct link_socket_addr link_socket_addr;$/;"	m	struct:context_1	typeref:struct:context_1::link_socket_addr
link_socket_addr	socket.h	/^struct link_socket_addr$/;"	s
link_socket_bad_incoming_addr	socket.c	/^link_socket_bad_incoming_addr (struct buffer *buf,$/;"	f
link_socket_bad_outgoing_addr	socket.c	/^link_socket_bad_outgoing_addr (void)$/;"	f
link_socket_close	socket.c	/^link_socket_close (struct link_socket *sock)$/;"	f
link_socket_connection_initiated	socket.c	/^link_socket_connection_initiated (const struct buffer *buf,$/;"	f
link_socket_connection_oriented	socket.h	/^link_socket_connection_oriented (const struct link_socket *sock)$/;"	f
link_socket_current_remote	socket.c	/^link_socket_current_remote (const struct link_socket_info *info)$/;"	f
link_socket_extract_tos	socket.h	/^link_socket_extract_tos (struct link_socket *ls, const struct buffer *ipbuf)$/;"	f
link_socket_get_outgoing_addr	socket.h	/^link_socket_get_outgoing_addr (struct buffer *buf,$/;"	f
link_socket_info	openvpn.h	/^  struct link_socket_info *link_socket_info;$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_info
link_socket_info	socket.h	/^struct link_socket_info$/;"	s
link_socket_init_phase1	socket.c	/^link_socket_init_phase1 (struct link_socket *sock,$/;"	f
link_socket_init_phase2	socket.c	/^link_socket_init_phase2 (struct link_socket *sock,$/;"	f
link_socket_new	socket.c	/^link_socket_new (void)$/;"	f
link_socket_owned	openvpn.h	/^  bool link_socket_owned;$/;"	m	struct:context_2
link_socket_proto_connection_oriented	socket.h	/^link_socket_proto_connection_oriented (int proto)$/;"	f
link_socket_read	socket.h	/^link_socket_read (struct link_socket *sock,$/;"	f
link_socket_read_tcp	socket.c	/^link_socket_read_tcp (struct link_socket *sock,$/;"	f
link_socket_read_udp_posix	socket.c	/^link_socket_read_udp_posix (struct link_socket *sock,$/;"	f
link_socket_read_udp_posix_recvmsg	socket.c	/^link_socket_read_udp_posix_recvmsg (struct link_socket *sock,$/;"	f	file:
link_socket_read_udp_win32	socket.h	/^link_socket_read_udp_win32 (struct link_socket *sock,$/;"	f
link_socket_set_outgoing_addr	socket.h	/^link_socket_set_outgoing_addr (const struct buffer *buf,$/;"	f
link_socket_set_tos	socket.h	/^link_socket_set_tos (struct link_socket *ls)$/;"	f
link_socket_update_buffer_sizes	socket.c	/^link_socket_update_buffer_sizes (struct link_socket *ls, int rcvbuf, int sndbuf)$/;"	f
link_socket_update_flags	socket.c	/^link_socket_update_flags (struct link_socket *ls, unsigned int sockflags)$/;"	f
link_socket_verify_incoming_addr	socket.h	/^link_socket_verify_incoming_addr (struct buffer *buf,$/;"	f
link_socket_write	socket.h	/^link_socket_write (struct link_socket *sock,$/;"	f
link_socket_write_post_size_adjust	forward.c	/^link_socket_write_post_size_adjust (int *size,$/;"	f	file:
link_socket_write_tcp	socket.c	/^link_socket_write_tcp (struct link_socket *sock,$/;"	f
link_socket_write_tcp_posix	socket.h	/^link_socket_write_tcp_posix (struct link_socket *sock,$/;"	f
link_socket_write_udp	socket.h	/^link_socket_write_udp (struct link_socket *sock,$/;"	f
link_socket_write_udp_posix	socket.h	/^link_socket_write_udp_posix (struct link_socket *sock,$/;"	f
link_socket_write_udp_posix_sendmsg	socket.c	/^link_socket_write_udp_posix_sendmsg (struct link_socket *sock,$/;"	f
link_socket_write_win32	socket.h	/^link_socket_write_win32 (struct link_socket *sock,$/;"	f
link_write_bytes	mstats.h	/^  counter_type link_write_bytes;$/;"	m	struct:mmap_stats
link_write_bytes	openvpn.h	/^  counter_type link_write_bytes;$/;"	m	struct:context_2
link_write_bytes_global	forward.c	/^counter_type link_write_bytes_global; \/* GLOBAL *\/$/;"	v
list	buffer.h	/^  struct gc_entry *list;        \/**< First element of the linked list of$/;"	m	struct:gc_arena	typeref:struct:gc_arena::gc_entry
list	list.h	/^  struct hash_element *list;$/;"	m	struct:hash_bucket	typeref:struct:hash_bucket::hash_element
list	misc.h	/^  struct env_item *list;$/;"	m	struct:env_set	typeref:struct:env_set::env_item
list	pf.h	/^  struct pf_cn_elem *list;$/;"	m	struct:pf_cn_set	typeref:struct:pf_cn_set::pf_cn_elem
list	pf.h	/^  struct pf_subnet *list;$/;"	m	struct:pf_subnet_set	typeref:struct:pf_subnet_set::pf_subnet
list	plugin.h	/^  struct openvpn_plugin_string_list *list[MAX_PLUGINS];$/;"	m	struct:plugin_return	typeref:struct:plugin_return::openvpn_plugin_string_list
list	pool.h	/^  struct ifconfig_pool_entry *list;$/;"	m	struct:ifconfig_pool	typeref:struct:ifconfig_pool::ifconfig_pool_entry
list_test	list.c	/^list_test (void)$/;"	f
listen_handle	socket.h	/^  struct rw_handle listen_handle; \/* For listening on TCP socket in server mode *\/$/;"	m	struct:link_socket	typeref:struct:link_socket::rw_handle
listen_persistent_queued	socket.h	/^  bool listen_persistent_queued;$/;"	m	struct:link_socket
lladdr	options.h	/^  const char *lladdr;$/;"	m	struct:options
local	manage.h	/^  struct openvpn_sockaddr local;$/;"	m	struct:man_settings	typeref:struct:man_settings::openvpn_sockaddr
local	multi.h	/^  struct mroute_addr local;$/;"	m	struct:multi_context	typeref:struct:multi_context::mroute_addr
local	options.h	/^  const char *local;$/;"	m	struct:connection_entry
local	socket.h	/^  struct openvpn_sockaddr local;$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::openvpn_sockaddr
local	tun.h	/^  in_addr_t local;$/;"	m	struct:tuntap
local_host	socket.h	/^  const char *local_host;$/;"	m	struct:link_socket
local_ip	manage.h	/^  in_addr_t local_ip;$/;"	m	struct:log_entry
local_ipv6	tun.h	/^  struct in6_addr local_ipv6;$/;"	m	struct:tuntap	typeref:struct:tuntap::in6_addr
local_options	ssl_common.h	/^  const char *local_options;$/;"	m	struct:tls_options
local_options_string	ssl.c	/^local_options_string (const struct tls_session *session)$/;"	f	file:
local_port	options.h	/^  int local_port;$/;"	m	struct:connection_entry
local_port	socket.h	/^  int local_port;$/;"	m	struct:link_socket
local_port_defined	options.h	/^  bool local_port_defined;$/;"	m	struct:connection_entry
local_route	route.c	/^local_route (in_addr_t network,$/;"	f	file:
local_unix	manage.h	/^  struct sockaddr_un local_unix;$/;"	m	struct:man_settings	typeref:struct:man_settings::sockaddr_un
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
locked	win32.h	/^  bool locked;$/;"	m	struct:semaphore
locked_cert_hash_set	ssl_common.h	/^  struct cert_hash_set *locked_cert_hash_set;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::cert_hash_set
locked_cn	ssl_common.h	/^  char *locked_cn;$/;"	m	struct:tls_multi
locked_username	ssl_common.h	/^  char *locked_username;$/;"	m	struct:tls_multi
log	manage.h	/^  struct log_history *log;$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history
log	options.h	/^  bool log;$/;"	m	struct:options
log_entry	manage.h	/^struct log_entry$/;"	s
log_entry_free_contents	manage.c	/^log_entry_free_contents (struct log_entry *e)$/;"	f	file:
log_entry_print	manage.c	/^log_entry_print (const struct log_entry *e, unsigned int flags, struct gc_arena *gc)$/;"	f
log_entry_union	manage.h	/^union log_entry_union {$/;"	u
log_history	manage.h	/^struct log_history$/;"	s
log_history_add	manage.c	/^log_history_add (struct log_history *h, const struct log_entry *le)$/;"	f
log_history_cache	manage.h	/^  int log_history_cache;$/;"	m	struct:man_settings
log_history_capacity	manage.h	/^log_history_capacity (const struct log_history *h)$/;"	f
log_history_close	manage.c	/^log_history_close (struct log_history *h)$/;"	f
log_history_free_contents	manage.c	/^log_history_free_contents (struct log_history *h)$/;"	f	file:
log_history_init	manage.c	/^log_history_init (const int capacity)$/;"	f
log_history_obj_init	manage.c	/^log_history_obj_init (struct log_history *h, int capacity)$/;"	f	file:
log_history_ref	manage.c	/^log_history_ref (const struct log_history *h, const int index)$/;"	f
log_history_resize	manage.c	/^log_history_resize (struct log_history *h, const int capacity)$/;"	f
log_history_size	manage.h	/^log_history_size (const struct log_history *h)$/;"	f
log_index	manage.c	/^log_index (const struct log_history *h, int i)$/;"	f	file:
log_realtime	manage.h	/^  bool log_realtime;$/;"	m	struct:man_connection
log_rw	openvpn.h	/^  bool log_rw;$/;"	m	struct:context_2
lookup_by_cid	multi.c	/^lookup_by_cid (struct multi_context *m, const unsigned long cid)$/;"	f	file:
lookup_cn_rule	pf.c	/^lookup_cn_rule (struct hash *h, const char *cn, const uint32_t cn_hash)$/;"	f	file:
lower	sig.c	/^  const char *lower;$/;"	m	struct:signame	file:
lsa	socket.h	/^  struct link_socket_addr *lsa;$/;"	m	struct:link_socket_info	typeref:struct:link_socket_info::link_socket_addr
lsteps	schedule.c	/^  int lsteps;$/;"	m	struct:status	file:
lt	schedule.h	/^  struct schedule_entry *lt;$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry
lzo	options.h	/^  unsigned int lzo;$/;"	m	struct:options
lzo_adaptive_compress	lzo.h	/^struct lzo_adaptive_compress {$/;"	s
lzo_adaptive_compress_data	lzo.c	/^lzo_adaptive_compress_data (struct lzo_adaptive_compress *ac, int n_total, int n_comp)$/;"	f	file:
lzo_adaptive_compress_test	lzo.c	/^lzo_adaptive_compress_test (struct lzo_adaptive_compress *ac)$/;"	f	file:
lzo_adjust_frame_parameters	lzo.c	/^void lzo_adjust_frame_parameters (struct frame *frame)$/;"	f
lzo_compress	lzo.c	/^lzo_compress (struct buffer *buf, struct buffer work,$/;"	f
lzo_compress_buf	openvpn.h	/^  struct buffer lzo_compress_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
lzo_compress_init	lzo.c	/^lzo_compress_init (struct lzo_compress_workspace *lzowork, unsigned int flags)$/;"	f
lzo_compress_uninit	lzo.c	/^lzo_compress_uninit (struct lzo_compress_workspace *lzowork)$/;"	f
lzo_compress_workspace	lzo.h	/^struct lzo_compress_workspace$/;"	s
lzo_compression_enabled	lzo.c	/^lzo_compression_enabled (struct lzo_compress_workspace *lzowork)$/;"	f	file:
lzo_compwork	openvpn.h	/^  struct lzo_compress_workspace lzo_compwork;$/;"	m	struct:context_2	typeref:struct:context_2::lzo_compress_workspace
lzo_decompress	lzo.c	/^lzo_decompress (struct buffer *buf, struct buffer work,$/;"	f
lzo_decompress_buf	openvpn.h	/^  struct buffer lzo_decompress_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
lzo_defined	lzo.h	/^lzo_defined (const struct lzo_compress_workspace *lzowork)$/;"	f
lzo_modify_flags	lzo.c	/^lzo_modify_flags (struct lzo_compress_workspace *lzowork, unsigned int flags)$/;"	f
lzo_print_stats	lzo.c	/^void lzo_print_stats (const struct lzo_compress_workspace *lzo_compwork, struct status_output *so)$/;"	f
m_rtm	route.c	/^  struct rt_msghdr m_rtm;$/;"	m	struct:__anon6	typeref:struct:__anon6::rt_msghdr	file:
m_rtm	route.c	/^  struct rt_msghdr m_rtm;$/;"	m	struct:__anon7	typeref:struct:__anon7::rt_msghdr	file:
m_rtm	route.c	/^  struct rt_msghdr m_rtm;$/;"	m	struct:rtmsg	typeref:struct:rtmsg::rt_msghdr	file:
m_rtmsg	route.c	/^} m_rtmsg;$/;"	v	typeref:struct:__anon6
m_rtmsg	route.c	/^} m_rtmsg;$/;"	v	typeref:struct:__anon7
m_space	route.c	/^  char       m_space[512];$/;"	m	struct:__anon6	file:
m_space	route.c	/^  char       m_space[512];$/;"	m	struct:__anon7	file:
m_space	route.c	/^  char       m_space[512];$/;"	m	struct:rtmsg	file:
mac_addr_safe	socket.c	/^mac_addr_safe (const char *mac_addr)$/;"	f
mac_addr_size	proto.h	/^  uint8_t  mac_addr_size;       \/* 0x06 *\/$/;"	m	struct:openvpn_arp
mac_addr_type	proto.h	/^  uint16_t mac_addr_type;       \/* 0x0001 *\/$/;"	m	struct:openvpn_arp
mac_dest	proto.h	/^  uint8_t   mac_dest[OPENVPN_ETH_ALEN];$/;"	m	struct:openvpn_arp
mac_src	proto.h	/^  uint8_t   mac_src[OPENVPN_ETH_ALEN];$/;"	m	struct:openvpn_arp
magic	dhcp.h	/^  uint32_t magic;      \/* must be 0x63825363 (network order) *\/$/;"	m	struct:dhcp
main	openvpn.c	/^main (int argc, char *argv[]) {$/;"	f
make_arg_array	misc.c	/^make_arg_array (const char *first, const char *parms, struct gc_arena *gc)$/;"	f
make_arg_copy	misc.c	/^make_arg_copy (char **p, struct gc_arena *gc)$/;"	f	file:
make_base64_string	proxy.c	/^make_base64_string (const uint8_t *str, struct gc_arena *gc)$/;"	f
make_base64_string2	proxy.c	/^make_base64_string2 (const uint8_t *str, int src_len, struct gc_arena *gc)$/;"	f
make_env_array	misc.c	/^make_env_array (const struct env_set *es,$/;"	f
make_extended_arg_array	misc.c	/^make_extended_arg_array (char **p, struct gc_arena *gc)$/;"	f
make_inline_array	misc.c	/^make_inline_array (const char *str, struct gc_arena *gc)$/;"	f	file:
man_accept	manage.c	/^man_accept (struct management *man)$/;"	f	file:
man_block	manage.c	/^man_block (struct management *man, volatile int *signal_received, const time_t expire)$/;"	f	file:
man_bytecount	manage.c	/^man_bytecount (struct management *man, const int update_seconds)$/;"	f	file:
man_bytecount_output_client	manage.c	/^man_bytecount_output_client (struct management *man)$/;"	f
man_bytecount_output_server	manage.c	/^man_bytecount_output_server (struct management *man,$/;"	f
man_bytecount_possible_output_client	manage.h	/^man_bytecount_possible_output_client (struct management *man)$/;"	f
man_check_for_signals	manage.c	/^man_check_for_signals (volatile int *signal_received)$/;"	f	file:
man_check_password	manage.c	/^man_check_password (struct management *man, const char *line)$/;"	f	file:
man_client_auth	manage.c	/^man_client_auth (struct management *man, const char *cid_str, const char *kid_str, const bool extra)$/;"	f	file:
man_client_deny	manage.c	/^man_client_deny (struct management *man, const char *cid_str, const char *kid_str, const char *reason, const char *client_reason)$/;"	f	file:
man_client_kill	manage.c	/^man_client_kill (struct management *man, const char *cid_str, const char *kill_msg)$/;"	f	file:
man_client_n_clients	manage.c	/^man_client_n_clients (struct management *man)$/;"	f	file:
man_client_pf	manage.c	/^man_client_pf (struct management *man, const char *cid_str)$/;"	f	file:
man_close_socket	manage.c	/^man_close_socket (struct management *man, const socket_descriptor_t sd)$/;"	f	file:
man_connect	manage.c	/^man_connect (struct management *man)$/;"	f	file:
man_connection	manage.h	/^struct man_connection {$/;"	s
man_connection_clear	manage.c	/^man_connection_clear (struct man_connection *mc)$/;"	f	file:
man_connection_close	manage.c	/^man_connection_close (struct management *man)$/;"	f	file:
man_connection_init	manage.c	/^man_connection_init (struct management *man)$/;"	f	file:
man_connection_settings_reset	manage.c	/^man_connection_settings_reset (struct management *man)$/;"	f	file:
man_def_auth_context	manage.h	/^struct man_def_auth_context {$/;"	s
man_def_auth_set_client_reason	ssl_verify.c	/^man_def_auth_set_client_reason (struct tls_multi *multi, const char *client_reason)$/;"	f
man_def_auth_test	ssl_verify.c	/^man_def_auth_test (const struct key_state *ks)$/;"	f	file:
man_delete_unix_socket	manage.c	/^man_delete_unix_socket (struct management *man)$/;"	f	file:
man_dispatch_command	manage.c	/^man_dispatch_command (struct management *man, struct status_output *so, const char **p, const int nparms)$/;"	f	file:
man_echo	manage.c	/^man_echo (struct management *man, const char *parm)$/;"	f	file:
man_env_filter	manage.c	/^man_env_filter (struct management *man, const int level)$/;"	f	file:
man_forget_passwords	manage.c	/^man_forget_passwords (struct management *man)$/;"	f	file:
man_help	manage.c	/^man_help ()$/;"	f	file:
man_history	manage.c	/^man_history (struct management *man,$/;"	f	file:
man_hold	manage.c	/^man_hold (struct management *man, const char *cmd)$/;"	f	file:
man_io_error	manage.c	/^man_io_error (struct management *man, const char *prefix)$/;"	f	file:
man_kill	manage.c	/^man_kill (struct management *man, const char *victim)$/;"	f	file:
man_listen	manage.c	/^man_listen (struct management *man)$/;"	f	file:
man_load_stats	manage.c	/^man_load_stats (struct management *man)$/;"	f	file:
man_log	manage.c	/^man_log (struct management *man, const char *parm)$/;"	f	file:
man_mod_signal	manage.c	/^man_mod_signal (const struct management *man, const int signum)$/;"	f	file:
man_need	manage.c	/^man_need (struct management *man, const char **p, const int n, unsigned int flags)$/;"	f	file:
man_net	manage.c	/^man_net (struct management *man)$/;"	f	file:
man_new_connection_post	manage.c	/^man_new_connection_post (struct management *man, const char *description)$/;"	f	file:
man_output_env	manage.c	/^man_output_env (const struct env_set *es, const bool tail, const int env_filter_level, const char *prefix)$/;"	f	file:
man_output_extra_env	manage.c	/^man_output_extra_env (struct management *man, const char *prefix)$/;"	f	file:
man_output_list_push	manage.c	/^man_output_list_push (struct management *man, const char *str)$/;"	f	file:
man_output_list_push_finalize	manage.c	/^man_output_list_push_finalize (struct management *man)$/;"	f	file:
man_output_list_push_str	manage.c	/^man_output_list_push_str (struct management *man, const char *str)$/;"	f	file:
man_output_peer_info_env	manage.c	/^man_output_peer_info_env (struct management *man, struct man_def_auth_context *mdac)$/;"	f	file:
man_output_standalone	manage.c	/^man_output_standalone (struct management *man, volatile int *signal_received)$/;"	f	file:
man_password_needed	manage.c	/^man_password_needed (struct management *man)$/;"	f	file:
man_persist	manage.h	/^struct man_persist {$/;"	s
man_persist_close	manage.c	/^man_persist_close (struct man_persist *mp)$/;"	f	file:
man_persist_init	manage.c	/^man_persist_init (struct management *man,$/;"	f	file:
man_persist_state	manage.c	/^man_persist_state (unsigned int *persistent, const int n)$/;"	f	file:
man_pkcs11_id_count	manage.c	/^man_pkcs11_id_count (struct management *man)$/;"	f	file:
man_pkcs11_id_get	manage.c	/^man_pkcs11_id_get (struct management *man, const int index)$/;"	f	file:
man_process_command	manage.c	/^man_process_command (struct management *man, const char *line)$/;"	f	file:
man_prompt	manage.c	/^man_prompt (struct management *man)$/;"	f	file:
man_proxy	manage.c	/^man_proxy (struct management *man, const char **p)$/;"	f	file:
man_query_need_ok	manage.c	/^man_query_need_ok (struct management *man, const char *type, const char *action)$/;"	f	file:
man_query_need_str	manage.c	/^man_query_need_str (struct management *man, const char *type, const char *action)$/;"	f	file:
man_query_password	manage.c	/^man_query_password (struct management *man, const char *type, const char *string)$/;"	f	file:
man_query_user_pass	manage.c	/^man_query_user_pass (struct management *man,$/;"	f	file:
man_query_username	manage.c	/^man_query_username (struct management *man, const char *type, const char *string)$/;"	f	file:
man_read	manage.c	/^man_read (struct management *man)$/;"	f	file:
man_record_peer_info	manage.c	/^man_record_peer_info (struct management *man)$/;"	f	file:
man_remote	manage.c	/^man_remote (struct management *man, const char **p)$/;"	f	file:
man_reset_client_socket	manage.c	/^man_reset_client_socket (struct management *man, const bool exiting)$/;"	f	file:
man_rsa_sig	manage.c	/^man_rsa_sig (struct management *man)$/;"	f	file:
man_settings	manage.h	/^struct man_settings {$/;"	s
man_settings_close	manage.c	/^man_settings_close (struct man_settings *ms)$/;"	f	file:
man_settings_init	manage.c	/^man_settings_init (struct man_settings *ms,$/;"	f	file:
man_signal	manage.c	/^man_signal (struct management *man, const char *name)$/;"	f	file:
man_standalone_event_loop	manage.c	/^man_standalone_event_loop (struct management *man, volatile int *signal_received, const time_t expire)$/;"	f	file:
man_standalone_ok	manage.c	/^man_standalone_ok (const struct management *man)$/;"	f	file:
man_start_ne32	manage.c	/^man_start_ne32 (struct management *man)$/;"	f	file:
man_state	manage.c	/^man_state (struct management *man, const char *parm)$/;"	f	file:
man_state_name	manage.c	/^man_state_name (const int state)$/;"	f	file:
man_status	manage.c	/^man_status (struct management *man, const int version, struct status_output *so)$/;"	f	file:
man_stop_ne32	manage.c	/^man_stop_ne32 (struct management *man)$/;"	f	file:
man_up_finalize	manage.c	/^man_up_finalize (struct management *man)$/;"	f	file:
man_update_io_state	manage.c	/^man_update_io_state (struct management *man)$/;"	f	file:
man_verify_unix_peer_uid_gid	manage.c	/^man_verify_unix_peer_uid_gid (struct management *man, const socket_descriptor_t sd)$/;"	f	file:
man_wait_for_client_connection	manage.c	/^man_wait_for_client_connection (struct management *man,$/;"	f	file:
man_welcome	manage.c	/^man_welcome (struct management *man)$/;"	f	file:
man_write	manage.c	/^man_write (struct management *man)$/;"	f	file:
management	manage.c	/^struct management *management; \/* GLOBAL *\/$/;"	v	typeref:struct:management
management	manage.h	/^struct management$/;"	s
management_addr	options.h	/^  const char *management_addr;$/;"	m	struct:options
management_auth_failure	manage.c	/^management_auth_failure (struct management *man, const char *type, const char *reason)$/;"	f
management_auth_token	manage.c	/^management_auth_token (struct management *man, const char *token)$/;"	f
management_bytes_in	manage.h	/^management_bytes_in (struct management *man, const int size)$/;"	f
management_bytes_in_client	manage.h	/^management_bytes_in_client (struct management *man, const int size)$/;"	f
management_bytes_out	manage.h	/^management_bytes_out (struct management *man, const int size)$/;"	f
management_bytes_out_client	manage.h	/^management_bytes_out_client (struct management *man, const int size)$/;"	f
management_bytes_server	manage.h	/^management_bytes_server (struct management *man,$/;"	f
management_callback	manage.h	/^struct management_callback$/;"	s
management_callback_kill_by_addr	multi.c	/^management_callback_kill_by_addr (void *arg, const in_addr_t addr, const int port)$/;"	f	file:
management_callback_kill_by_cn	multi.c	/^management_callback_kill_by_cn (void *arg, const char *del_cn)$/;"	f	file:
management_callback_n_clients	multi.c	/^management_callback_n_clients (void *arg)$/;"	f	file:
management_callback_proxy_cmd	init.c	/^management_callback_proxy_cmd (void *arg, const char **p)$/;"	f	file:
management_callback_remote_cmd	init.c	/^management_callback_remote_cmd (void *arg, const char **p)$/;"	f	file:
management_callback_status	multi.c	/^management_callback_status (void *arg, const int version, struct status_output *so)$/;"	f	file:
management_callback_status_p2p	init.c	/^management_callback_status_p2p (void *arg, const int version, struct status_output *so)$/;"	f	file:
management_clear_callback	manage.c	/^management_clear_callback (struct management *man)$/;"	f
management_client_auth	multi.c	/^management_client_auth (void *arg,$/;"	f	file:
management_client_group	options.h	/^  const char *management_client_group;$/;"	m	struct:options
management_client_pf	multi.c	/^management_client_pf (void *arg,$/;"	f	file:
management_client_user	options.h	/^  const char *management_client_user;$/;"	m	struct:options
management_close	manage.c	/^management_close (struct management *man)$/;"	f
management_connected	manage.h	/^management_connected (const struct management *man)$/;"	f
management_connection_established	manage.c	/^management_connection_established (struct management *management,$/;"	f
management_delete_event	multi.c	/^management_delete_event (void *arg, event_t event)$/;"	f	file:
management_echo	manage.c	/^management_echo (struct management *man, const char *string, const bool pull)$/;"	f
management_echo_buffer_size	options.h	/^  int management_echo_buffer_size;$/;"	m	struct:options
management_enable_def_auth	manage.h	/^management_enable_def_auth (const struct management *man)$/;"	f
management_enable_pf	manage.h	/^management_enable_pf (const struct management *man)$/;"	f
management_event_loop_n_seconds	manage.c	/^management_event_loop_n_seconds (struct management *man, int sec)$/;"	f
management_flags	options.h	/^  unsigned int management_flags;$/;"	m	struct:options
management_get_peer_info	multi.c	/^management_get_peer_info (void *arg, const unsigned long cid)$/;"	f	file:
management_hold	manage.c	/^management_hold (struct management *man)$/;"	f
management_init	manage.c	/^management_init (void)$/;"	f
management_io	manage.c	/^management_io (struct management *man)$/;"	f
management_kill_by_cid	multi.c	/^management_kill_by_cid (void *arg, const unsigned long cid, const char *kill_msg)$/;"	f	file:
management_learn_addr	manage.c	/^management_learn_addr (struct management *management,$/;"	f
management_log_history_cache	options.h	/^  int management_log_history_cache;$/;"	m	struct:options
management_notify	manage.c	/^management_notify(struct management *man, const char *severity, const char *type, const char *text)$/;"	f
management_notify_client_close	manage.c	/^management_notify_client_close (struct management *management,$/;"	f
management_notify_client_needing_auth	manage.c	/^management_notify_client_needing_auth (struct management *management,$/;"	f
management_notify_generic	manage.c	/^management_notify_generic (struct management *man, const char *str)$/;"	f
management_open	manage.c	/^management_open (struct management *man,$/;"	f
management_over_tunnel	manage.h	/^  bool management_over_tunnel;$/;"	m	struct:man_settings
management_persist_flags	mtcp.h	/^  unsigned int management_persist_flags;$/;"	m	struct:multi_tcp
management_port	options.h	/^  int management_port;$/;"	m	struct:options
management_post_tunnel_open	manage.c	/^management_post_tunnel_open (struct management *man, const in_addr_t tun_local_ip)$/;"	f
management_pre_tunnel_close	manage.c	/^management_pre_tunnel_close (struct management *man)$/;"	f
management_query_proxy_enabled	manage.h	/^management_query_proxy_enabled (const struct management *man)$/;"	f
management_query_remote_enabled	manage.h	/^management_query_remote_enabled (const struct management *man)$/;"	f
management_query_rsa_sig	manage.c	/^management_query_rsa_sig (struct management *man,$/;"	f
management_query_user_pass	manage.c	/^management_query_user_pass (struct management *man,$/;"	f
management_query_user_pass_enabled	manage.h	/^management_query_user_pass_enabled (const struct management *man)$/;"	f
management_set_callback	manage.c	/^management_set_callback (struct management *man,$/;"	f
management_set_state	manage.c	/^management_set_state (struct management *man,$/;"	f
management_should_daemonize	manage.c	/^management_should_daemonize (struct management *man)$/;"	f
management_show_net_callback	init.c	/^management_show_net_callback (void *arg, const int msglevel)$/;"	f
management_socket_set	manage.c	/^management_socket_set (struct management *man,$/;"	f
management_state_buffer_size	options.h	/^  int management_state_buffer_size;$/;"	m	struct:options
management_up_down	manage.c	/^management_up_down(struct management *man, const char *updown, const struct env_set *es)$/;"	f
management_user_pass	options.h	/^  const char *management_user_pass;$/;"	m	struct:options
management_would_hold	manage.c	/^management_would_hold (struct management *man)$/;"	f
management_write_peer_info_file	options.h	/^  const char *management_write_peer_info_file;$/;"	m	struct:options
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mansig	manage.h	/^  unsigned int mansig;$/;"	m	struct:man_settings
map	fragment.h	/^  unsigned int map;$/;"	m	struct:fragment
mark	options.h	/^  int mark;$/;"	m	struct:options
mask	list.h	/^  int mask;$/;"	m	struct:hash
max	otime.h	/^  int max;$/;"	m	struct:frequency_limit
max	perf.c	/^  double max;$/;"	m	struct:perf	file:
max	route.c	2735;"	d	file:
max	route.c	2919;"	d	file:
max_backtrack_stat	packet_id.h	/^  int max_backtrack_stat;     \/* maximum backtrack seen so far *\/$/;"	m	struct:packet_id_rec
max_clients	multi.h	/^  int max_clients;$/;"	m	struct:multi_context
max_clients	options.h	/^  int max_clients;$/;"	m	struct:options
max_frag_size	fragment.h	/^  int max_frag_size;		\/**< Maximum size of each %fragment. *\/$/;"	m	struct:fragment
max_int	integer.h	/^max_int (int x, int y)$/;"	f
max_queued	mbuf.h	/^  unsigned int max_queued;$/;"	m	struct:mbuf_set
max_recv_size_local	openvpn.h	/^  int max_recv_size_local;	\/* max packet size received *\/$/;"	m	struct:context_2
max_recv_size_remote	openvpn.h	/^  int max_recv_size_remote;	\/* max packet size received by remote *\/$/;"	m	struct:context_2
max_routes	options.h	/^  int max_routes;$/;"	m	struct:options
max_routes_per_client	options.h	/^  int max_routes_per_client;$/;"	m	struct:options
max_send_size_local	openvpn.h	/^  int max_send_size_local;	\/* max packet size sent *\/$/;"	m	struct:context_2
max_send_size_remote	openvpn.h	/^  int max_send_size_remote;	\/* max packet size sent by remote *\/$/;"	m	struct:context_2
max_size	buffer.h	/^  int max_size;              \/* maximum size list should grow to *\/$/;"	m	struct:buffer_list
maxevents	event.c	/^  int maxevents;$/;"	m	struct:ep_set	file:
maxevents	mtcp.h	/^  int maxevents;$/;"	m	struct:multi_tcp
maxfd	event.c	/^  int maxfd;    \/* largest fd seen so far, always < capacity *\/$/;"	m	struct:se_set	file:
maxlen	socket.h	/^  int maxlen;$/;"	m	struct:stream_buf
mbuf	multi.h	/^  struct mbuf_set *mbuf;        \/**< Set of buffers for passing data$/;"	m	struct:multi_context	typeref:struct:multi_context::mbuf_set
mbuf_add_item	mbuf.c	/^mbuf_add_item (struct mbuf_set *ms, const struct mbuf_item *item)$/;"	f
mbuf_alloc_buf	mbuf.c	/^mbuf_alloc_buf (const struct buffer *buf)$/;"	f
mbuf_buffer	mbuf.h	/^struct mbuf_buffer$/;"	s
mbuf_defined	mbuf.h	/^mbuf_defined (const struct mbuf_set *ms)$/;"	f
mbuf_dereference_instance	mbuf.c	/^mbuf_dereference_instance (struct mbuf_set *ms, struct multi_instance *mi)$/;"	f
mbuf_extract_item	mbuf.c	/^mbuf_extract_item (struct mbuf_set *ms, struct mbuf_item *item)$/;"	f
mbuf_free	mbuf.c	/^mbuf_free (struct mbuf_set *ms)$/;"	f
mbuf_free_buf	mbuf.c	/^mbuf_free_buf (struct mbuf_buffer *mb)$/;"	f
mbuf_init	mbuf.c	/^mbuf_init (unsigned int size)$/;"	f
mbuf_item	mbuf.h	/^struct mbuf_item$/;"	s
mbuf_len	mbuf.h	/^mbuf_len (const struct mbuf_set *ms)$/;"	f
mbuf_maximum_queued	mbuf.h	/^mbuf_maximum_queued (const struct mbuf_set *ms)$/;"	f
mbuf_peek	mbuf.h	/^mbuf_peek (struct mbuf_set *ms)$/;"	f
mbuf_peek_dowork	mbuf.c	/^mbuf_peek_dowork (struct mbuf_set *ms)$/;"	f
mbuf_set	mbuf.h	/^struct mbuf_set$/;"	s
md5_digest	crypto.h	/^struct md5_digest {$/;"	s
md5_digest_clear	crypto.c	/^md5_digest_clear (struct md5_digest *digest)$/;"	f
md5_digest_defined	crypto.c	/^md5_digest_defined (const struct md5_digest *digest)$/;"	f
md5_digest_equal	crypto.c	/^md5_digest_equal (const struct md5_digest *d1, const struct md5_digest *d2)$/;"	f
md5_state	crypto.h	/^struct md5_state {$/;"	s
md5_state_final	crypto.c	/^md5_state_final (struct md5_state *s, struct md5_digest *out)$/;"	f
md5_state_init	crypto.c	/^md5_state_init (struct md5_state *s)$/;"	f
md5_state_update	crypto.c	/^md5_state_update (struct md5_state *s, void *data, size_t len)$/;"	f
md5sum	crypto.c	/^md5sum (uint8_t *buf, int len, int n_print_chars, struct gc_arena *gc)$/;"	f
md_ctx_cleanup	crypto_openssl.c	/^md_ctx_cleanup(EVP_MD_CTX *ctx)$/;"	f
md_ctx_cleanup	crypto_polarssl.c	/^md_ctx_cleanup(md_context_t *ctx)$/;"	f
md_ctx_final	crypto_openssl.c	/^md_ctx_final (EVP_MD_CTX *ctx, uint8_t *dst)$/;"	f
md_ctx_final	crypto_polarssl.c	/^md_ctx_final (md_context_t *ctx, uint8_t *dst)$/;"	f
md_ctx_init	crypto_openssl.c	/^md_ctx_init (EVP_MD_CTX *ctx, const EVP_MD *kt)$/;"	f
md_ctx_init	crypto_polarssl.c	/^md_ctx_init (md_context_t *ctx, const md_info_t *kt)$/;"	f
md_ctx_size	crypto_openssl.c	/^md_ctx_size (const EVP_MD_CTX *ctx)$/;"	f
md_ctx_size	crypto_polarssl.c	/^md_ctx_size (const md_context_t *ctx)$/;"	f
md_ctx_t	crypto_openssl.h	/^typedef EVP_MD_CTX md_ctx_t;$/;"	t
md_ctx_t	crypto_polarssl.h	/^typedef md_context_t md_ctx_t;$/;"	t
md_ctx_update	crypto_openssl.c	/^md_ctx_update (EVP_MD_CTX *ctx, const uint8_t *src, int src_len)$/;"	f
md_ctx_update	crypto_polarssl.c	/^md_ctx_update (md_context_t *ctx, const uint8_t *src, int src_len)$/;"	f
md_full	crypto_openssl.c	/^md_full (const EVP_MD *kt, const uint8_t *src, int src_len, uint8_t *dst)$/;"	f
md_full	crypto_polarssl.c	/^md_full (const md_kt_t *kt, const uint8_t *src, int src_len, uint8_t *dst)$/;"	f
md_kt_get	crypto_openssl.c	/^md_kt_get (const char *digest)$/;"	f
md_kt_get	crypto_polarssl.c	/^md_kt_get (const char *digest)$/;"	f
md_kt_name	crypto_openssl.c	/^md_kt_name (const EVP_MD *kt)$/;"	f
md_kt_name	crypto_polarssl.c	/^md_kt_name (const md_info_t *kt)$/;"	f
md_kt_size	crypto_openssl.c	/^md_kt_size (const EVP_MD *kt)$/;"	f
md_kt_size	crypto_polarssl.c	/^md_kt_size (const md_info_t *kt)$/;"	f
md_kt_t	crypto_openssl.h	/^typedef EVP_MD md_kt_t;$/;"	t
md_kt_t	crypto_polarssl.h	/^typedef md_info_t md_kt_t;$/;"	t
mda_context	openvpn.h	/^  struct man_def_auth_context mda_context;$/;"	m	struct:context_2	typeref:struct:context_2::man_def_auth_context
mda_context	ssl_common.h	/^  struct man_def_auth_context *mda_context;$/;"	m	struct:tls_options	typeref:struct:tls_options::man_def_auth_context
mda_key_id	ssl_common.h	/^  unsigned int mda_key_id;$/;"	m	struct:key_state
mda_key_id_counter	manage.h	/^  unsigned int mda_key_id_counter;$/;"	m	struct:man_def_auth_context
mda_status	ssl_common.h	/^  unsigned int mda_status;$/;"	m	struct:key_state
memcmp_constant_time	crypto.c	/^memcmp_constant_time (const void *a, const void *b, size_t size) {$/;"	f	file:
memstats_fn	options.h	/^  char *memstats_fn;$/;"	m	struct:options
metric	route.h	/^  const char *metric;		\/* e.g. "5" *\/$/;"	m	struct:route_ipv6_option
metric	route.h	/^  const char *metric;$/;"	m	struct:route_option
metric	route.h	/^  int metric;$/;"	m	struct:route_ipv4
metric	route.h	/^  int metric;$/;"	m	struct:route_ipv6
metric_defined	route.h	/^  bool metric_defined;$/;"	m	struct:route_ipv6
metric_names	perf.c	/^static const char *metric_names[] = {$/;"	v	file:
mi_prefix	multi.c	/^mi_prefix (const struct multi_instance *mi)$/;"	f	file:
min_int	integer.h	/^min_int (int x, int y)$/;"	f
min_version_required	plugin.h	/^  openvpn_plugin_min_version_required_v1 min_version_required;$/;"	m	struct:plugin
mix	list.c	573;"	d	file:
mkdir_p	Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mlock	options.h	/^  bool mlock;$/;"	m	struct:options
mmap_fn	mstats.c	/^static char mmap_fn[128];$/;"	v	file:
mmap_stats	mstats.c	/^volatile struct mmap_stats *mmap_stats = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:mmap_stats
mmap_stats	mstats.h	/^struct mmap_stats {$/;"	s
mode	openvpn.h	/^  int mode;                     \/**< Role of this context within the$/;"	m	struct:context
mode	options.h	/^  int mode;$/;"	m	struct:options
mode	socket.h	/^  int mode;$/;"	m	struct:link_socket
mode	win32.h	/^  int mode;$/;"	m	struct:win32_signal
module	plugin.h	/^  HMODULE module;$/;"	m	struct:plugin
modulo_add	integer.h	/^modulo_add(int x, int y, int mod)$/;"	f
modulo_subtract	integer.h	/^modulo_subtract(int x, int y, int mod)$/;"	f
move_session	ssl.c	/^move_session (struct tls_multi* multi, int dest, int src, bool reinit_src)$/;"	f	file:
mpp_touched	multi.h	/^  struct multi_instance **mpp_touched;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance
mroute_addr	mroute.h	/^struct mroute_addr {$/;"	s
mroute_addr_compare_function	mroute.c	/^mroute_addr_compare_function (const void *key1, const void *key2)$/;"	f
mroute_addr_equal	mroute.h	/^mroute_addr_equal (const struct mroute_addr *a1, const struct mroute_addr *a2)$/;"	f
mroute_addr_hash_function	mroute.c	/^mroute_addr_hash_function (const void *key, uint32_t iv)$/;"	f
mroute_addr_hash_len	mroute.h	/^mroute_addr_hash_len (const struct mroute_addr *a)$/;"	f
mroute_addr_hash_ptr	mroute.h	/^mroute_addr_hash_ptr (const struct mroute_addr *a)$/;"	f
mroute_addr_init	mroute.c	/^mroute_addr_init (struct mroute_addr *addr)$/;"	f
mroute_addr_mask_host_bits	mroute.c	/^mroute_addr_mask_host_bits (struct mroute_addr *ma)$/;"	f
mroute_addr_print	mroute.c	/^mroute_addr_print (const struct mroute_addr *ma,$/;"	f
mroute_addr_print_ex	mroute.c	/^mroute_addr_print_ex (const struct mroute_addr *ma,$/;"	f
mroute_addr_reset	mroute.h	/^mroute_addr_reset (struct mroute_addr *ma)$/;"	f
mroute_extract_addr_arp	mroute.c	/^mroute_extract_addr_arp (struct mroute_addr *src,$/;"	f	file:
mroute_extract_addr_ether	mroute.c	/^mroute_extract_addr_ether (struct mroute_addr *src,$/;"	f
mroute_extract_addr_from_packet	mroute.h	/^mroute_extract_addr_from_packet (struct mroute_addr *src,$/;"	f
mroute_extract_addr_ipv4	mroute.c	/^mroute_extract_addr_ipv4 (struct mroute_addr *src,$/;"	f
mroute_extract_in_addr_t	mroute.h	/^mroute_extract_in_addr_t (struct mroute_addr *dest, const in_addr_t src)$/;"	f
mroute_extract_openvpn_sockaddr	mroute.c	/^bool mroute_extract_openvpn_sockaddr (struct mroute_addr *addr,$/;"	f
mroute_get_in6_addr	mroute.c	/^mroute_get_in6_addr (struct mroute_addr *ma, const struct in6_addr src, unsigned int mask)$/;"	f	file:
mroute_get_in_addr_t	mroute.c	/^mroute_get_in_addr_t (struct mroute_addr *ma, const in_addr_t src, unsigned int mask)$/;"	f	file:
mroute_helper	mroute.h	/^struct mroute_helper {$/;"	s
mroute_helper_add_iroute	mroute.c	/^mroute_helper_add_iroute (struct mroute_helper *mh, const struct iroute *ir)$/;"	f
mroute_helper_add_iroute6	mroute.c	/^mroute_helper_add_iroute6 (struct mroute_helper *mh, $/;"	f
mroute_helper_del_iroute	mroute.c	/^mroute_helper_del_iroute (struct mroute_helper *mh, const struct iroute *ir)$/;"	f
mroute_helper_del_iroute6	mroute.c	/^mroute_helper_del_iroute6 (struct mroute_helper *mh, $/;"	f
mroute_helper_free	mroute.c	/^mroute_helper_free (struct mroute_helper *mh)$/;"	f
mroute_helper_init	mroute.c	/^mroute_helper_init (int ageable_ttl_secs)$/;"	f
mroute_helper_regenerate	mroute.c	/^mroute_helper_regenerate (struct mroute_helper *mh)$/;"	f	file:
mroute_is_mcast	mroute.c	/^mroute_is_mcast (const in_addr_t addr)$/;"	f	file:
mroute_is_mcast_ipv6	mroute.c	/^mroute_is_mcast_ipv6 (const struct in6_addr addr)$/;"	f	file:
mroute_learnable_address	mroute.c	/^mroute_learnable_address (const struct mroute_addr *addr)$/;"	f
ms_error_text	cryptoapi.c	/^static char *ms_error_text(DWORD ms_err)$/;"	f	file:
msg	error.h	149;"	d
msg	error.h	157;"	d
msg	error.h	171;"	d
msg_flags	manage.h	/^  unsigned int msg_flags;$/;"	m	union:log_entry_union
msg_flags_string	error.c	/^msg_flags_string (const unsigned int flags, struct gc_arena *gc)$/;"	f
msg_forked	error.c	/^msg_forked (void)$/;"	f
msg_fp	error.c	/^msg_fp(const unsigned int flags)$/;"	f
msg_get_prefix	error.h	/^msg_get_prefix (void)$/;"	f
msg_get_virtual_output	error.h	/^msg_get_virtual_output (void)$/;"	f
msg_prefix	multi.h	/^  const char *msg_prefix;$/;"	m	struct:multi_instance
msg_set_prefix	error.h	/^msg_set_prefix (const char *prefix)$/;"	f
msg_set_virtual_output	error.h	/^msg_set_virtual_output (const struct virtual_output *vo)$/;"	f
msgfp	error.c	/^static FILE *msgfp;         \/* GLOBAL *\/$/;"	v	file:
msglevel	status.h	/^  int msglevel;$/;"	m	struct:status_output
msglevel_forward_compatible	options.c	/^msglevel_forward_compatible (struct options *options, const int msglevel)$/;"	f	file:
msgpi4	socket.c	/^	struct openvpn_in4_pktinfo msgpi4;$/;"	m	union:openvpn_pktinfo	typeref:struct:openvpn_pktinfo::openvpn_in4_pktinfo	file:
msgpi6	socket.c	/^	struct openvpn_in6_pktinfo msgpi6;$/;"	m	union:openvpn_pktinfo	typeref:struct:openvpn_pktinfo::openvpn_in6_pktinfo	file:
mss_fixup_dowork	mss.c	/^mss_fixup_dowork (struct buffer *buf, uint16_t maxmss)$/;"	f
mss_fixup_ipv4	mss.c	/^mss_fixup_ipv4 (struct buffer *buf, int maxmss)$/;"	f
mss_fixup_ipv6	mss.c	/^mss_fixup_ipv6 (struct buffer *buf, int maxmss)$/;"	f
mssfix	options.h	/^  int mssfix;            \/* Upper bound on TCP MSS *\/$/;"	m	struct:connection_entry
mssfix_default	options.h	/^  bool mssfix_default;   \/* true if --mssfix was supplied without a parameter *\/$/;"	m	struct:connection_entry
mstats_close	mstats.c	/^mstats_close(void)$/;"	f
mstats_open	mstats.c	/^mstats_open(const char *fn)$/;"	f
mtcp	multi.h	/^  struct multi_tcp *mtcp;       \/**< State specific to OpenVPN using TCP$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_tcp
mtu	socket.h	/^  int mtu;                      \/* OS discovered MTU, or 0 if unknown *\/$/;"	m	struct:link_socket
mtu_changed	socket.h	/^  int mtu_changed;              \/* Set to true when mtu value is changed *\/$/;"	m	struct:link_socket_info
mtu_discover_type	options.h	/^  int mtu_discover_type; \/* used if OS supports setting Path MTU discovery options on socket *\/$/;"	m	struct:connection_entry
mtu_discover_type	socket.h	/^  int mtu_discover_type;$/;"	m	struct:link_socket
mtu_load_test	occ.h	/^struct mtu_load_test$/;"	s
mtu_load_test_sequence	occ.c	/^static const struct mtu_load_test mtu_load_test_sequence[] = {$/;"	v	typeref:struct:mtu_load_test	file:
mtu_test	options.h	/^  bool mtu_test;$/;"	m	struct:options
multi_add_iroutes	multi.c	/^multi_add_iroutes (struct multi_context *m,$/;"	f	file:
multi_add_mbuf	multi.c	/^multi_add_mbuf (struct multi_context *m,$/;"	f
multi_bcast	multi.c	/^multi_bcast (struct multi_context *m,$/;"	f	file:
multi_client_connect_mda	multi.c	/^multi_client_connect_mda (struct multi_context *m,$/;"	f	file:
multi_client_connect_post	multi.c	/^multi_client_connect_post (struct multi_context *m,$/;"	f	file:
multi_client_connect_post_plugin	multi.c	/^multi_client_connect_post_plugin (struct multi_context *m,$/;"	f	file:
multi_client_connect_setenv	multi.c	/^multi_client_connect_setenv (struct multi_context *m,$/;"	f	file:
multi_client_disconnect_script	multi.c	/^multi_client_disconnect_script (struct multi_context *m,$/;"	f	file:
multi_client_disconnect_setenv	multi.c	/^multi_client_disconnect_setenv (struct multi_context *m,$/;"	f	file:
multi_close_instance	multi.c	/^multi_close_instance (struct multi_context *m,$/;"	f
multi_close_instance_on_signal	multi.c	/^multi_close_instance_on_signal (struct multi_context *m, struct multi_instance *mi)$/;"	f
multi_connection_established	multi.c	/^multi_connection_established (struct multi_context *m, struct multi_instance *mi)$/;"	f	file:
multi_context	multi.h	/^struct multi_context {$/;"	s
multi_create_instance	multi.c	/^multi_create_instance (struct multi_context *m, const struct mroute_addr *real)$/;"	f
multi_create_instance_tcp	mtcp.c	/^multi_create_instance_tcp (struct multi_context *m)$/;"	f	file:
multi_del_iroutes	multi.c	/^multi_del_iroutes (struct multi_context *m,$/;"	f	file:
multi_delete_dup	multi.c	/^multi_delete_dup (struct multi_context *m, struct multi_instance *new_mi)$/;"	f	file:
multi_get_create_instance_udp	mudp.c	/^multi_get_create_instance_udp (struct multi_context *m)$/;"	f
multi_get_instance_by_virtual_addr	multi.c	/^multi_get_instance_by_virtual_addr (struct multi_context *m,$/;"	f	file:
multi_get_queue	multi.c	/^multi_get_queue (struct mbuf_set *ms)$/;"	f
multi_get_timeout	multi.h	/^multi_get_timeout (struct multi_context *m, struct timeval *dest)$/;"	f
multi_ifconfig_pool_persist	multi.c	/^multi_ifconfig_pool_persist (struct multi_context *m, bool force)$/;"	f
multi_init	multi.c	/^multi_init (struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode)$/;"	f
multi_instance	multi.h	/^struct multi_instance {$/;"	s
multi_instance_dec_refcount	multi.h	/^multi_instance_dec_refcount (struct multi_instance *mi)$/;"	f
multi_instance_inc_refcount	multi.h	/^multi_instance_inc_refcount (struct multi_instance *mi)$/;"	f
multi_instance_string	multi.c	/^multi_instance_string (const struct multi_instance *mi, bool null, struct gc_arena *gc)$/;"	f
multi_learn_addr	multi.c	/^multi_learn_addr (struct multi_context *m,$/;"	f	file:
multi_learn_in6_addr	multi.c	/^multi_learn_in6_addr  (struct multi_context *m,$/;"	f	file:
multi_learn_in_addr_t	multi.c	/^multi_learn_in_addr_t (struct multi_context *m,$/;"	f	file:
multi_output_queue_ready	multi.h	/^multi_output_queue_ready (const struct multi_context *m,$/;"	f
multi_print_status	multi.c	/^multi_print_status (struct multi_context *m, struct status_output *so, const int version)$/;"	f
multi_process_drop_outgoing_tun	multi.c	/^multi_process_drop_outgoing_tun (struct multi_context *m, const unsigned int mpp_flags)$/;"	f
multi_process_incoming_link	multi.c	/^multi_process_incoming_link (struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)$/;"	f
multi_process_incoming_tun	multi.c	/^multi_process_incoming_tun (struct multi_context *m, const unsigned int mpp_flags)$/;"	f
multi_process_io_udp	mudp.c	/^multi_process_io_udp (struct multi_context *m)$/;"	f	file:
multi_process_outgoing_link	mudp.c	/^multi_process_outgoing_link (struct multi_context *m, const unsigned int mpp_flags)$/;"	f	file:
multi_process_outgoing_link_dowork	multi.h	/^multi_process_outgoing_link_dowork (struct multi_context *m, struct multi_instance *mi, const unsigned int mpp_flags)$/;"	f
multi_process_outgoing_link_pre	multi.h	/^multi_process_outgoing_link_pre (struct multi_context *m)$/;"	f
multi_process_outgoing_tun	multi.h	/^multi_process_outgoing_tun (struct multi_context *m, const unsigned int mpp_flags)$/;"	f
multi_process_per_second_timers	multi.h	/^multi_process_per_second_timers (struct multi_context *m)$/;"	f
multi_process_per_second_timers_dowork	multi.c	/^multi_process_per_second_timers_dowork (struct multi_context *m)$/;"	f
multi_process_post	multi.c	/^multi_process_post (struct multi_context *m, struct multi_instance *mi, const unsigned int flags)$/;"	f
multi_process_signal	multi.c	/^multi_process_signal (struct multi_context *m)$/;"	f
multi_process_timeout	multi.c	/^multi_process_timeout (struct multi_context *m, const unsigned int mpp_flags)$/;"	f
multi_reap	multi.h	/^struct multi_reap$/;"	s
multi_reap_all	multi.c	/^multi_reap_all (const struct multi_context *m)$/;"	f	file:
multi_reap_free	multi.c	/^multi_reap_free (struct multi_reap *mr)$/;"	f	file:
multi_reap_new	multi.c	/^multi_reap_new (int buckets_per_pass)$/;"	f	file:
multi_reap_process	multi.h	/^multi_reap_process (const struct multi_context *m)$/;"	f
multi_reap_process_dowork	multi.c	/^multi_reap_process_dowork (const struct multi_context *m)$/;"	f
multi_reap_range	multi.c	/^multi_reap_range (const struct multi_context *m,$/;"	f	file:
multi_release_io_lock	multi.h	/^multi_release_io_lock (struct multi_context *m)$/;"	f
multi_route	multi.h	/^struct multi_route$/;"	s
multi_route_defined	multi.h	/^multi_route_defined (const struct multi_context *m,$/;"	f
multi_route_del	multi.h	/^multi_route_del (struct multi_route *route)$/;"	f
multi_schedule_context_wakeup	multi.c	/^multi_schedule_context_wakeup (struct multi_context *m, struct multi_instance *mi)$/;"	f	file:
multi_select_virtual_addr	multi.c	/^multi_select_virtual_addr (struct multi_context *m, struct multi_instance *mi)$/;"	f	file:
multi_set_pending	multi.h	/^multi_set_pending (struct multi_context *m, struct multi_instance *mi)$/;"	f
multi_set_virtual_addr_env	multi.c	/^multi_set_virtual_addr_env (struct multi_context *m, struct multi_instance *mi)$/;"	f	file:
multi_signal_instance	multi.c	/^multi_signal_instance (struct multi_context *m, struct multi_instance *mi, const int sig)$/;"	f	file:
multi_tcp	mtcp.h	/^struct multi_tcp$/;"	s
multi_tcp_action	mtcp.c	/^multi_tcp_action (struct multi_context *m, struct multi_instance *mi, int action, bool poll)$/;"	f	file:
multi_tcp_context	mtcp.c	/^multi_tcp_context (struct multi_context *m, struct multi_instance *mi)$/;"	f	file:
multi_tcp_delete_event	mtcp.c	/^multi_tcp_delete_event (struct multi_tcp *mtcp, event_t event)$/;"	f
multi_tcp_dereference_instance	mtcp.c	/^multi_tcp_dereference_instance (struct multi_tcp *mtcp, struct multi_instance *mi)$/;"	f
multi_tcp_dispatch	mtcp.c	/^multi_tcp_dispatch (struct multi_context *m, struct multi_instance *mi, const int action)$/;"	f	file:
multi_tcp_free	mtcp.c	/^multi_tcp_free (struct multi_tcp *mtcp)$/;"	f
multi_tcp_init	mtcp.c	/^multi_tcp_init (int maxevents, int *maxclients)$/;"	f
multi_tcp_instance_specific_free	mtcp.c	/^multi_tcp_instance_specific_free (struct multi_instance *mi)$/;"	f
multi_tcp_instance_specific_init	mtcp.c	/^multi_tcp_instance_specific_init (struct multi_context *m, struct multi_instance *mi)$/;"	f
multi_tcp_post	mtcp.c	/^multi_tcp_post (struct multi_context *m, struct multi_instance *mi, const int action)$/;"	f
multi_tcp_process_io	mtcp.c	/^multi_tcp_process_io (struct multi_context *m)$/;"	f	file:
multi_tcp_process_outgoing_link	mtcp.c	/^multi_tcp_process_outgoing_link (struct multi_context *m, bool defer, const unsigned int mpp_flags)$/;"	f	file:
multi_tcp_process_outgoing_link_ready	mtcp.c	/^multi_tcp_process_outgoing_link_ready (struct multi_context *m, struct multi_instance *mi, const unsigned int mpp_flags)$/;"	f	file:
multi_tcp_set_global_rw_flags	mtcp.c	/^multi_tcp_set_global_rw_flags (struct multi_context *m, struct multi_instance *mi)$/;"	f	file:
multi_tcp_wait	mtcp.c	/^multi_tcp_wait (const struct context *c,$/;"	f	file:
multi_tcp_wait_lite	mtcp.c	/^multi_tcp_wait_lite (struct multi_context *m, struct multi_instance *mi, const int action, bool *tun_input_pending)$/;"	f	file:
multi_top_free	multi.c	/^multi_top_free (struct multi_context *m)$/;"	f
multi_top_init	multi.c	/^multi_top_init (struct multi_context *m, const struct context *top, const bool alloc_buffers)$/;"	f
multi_unicast	multi.c	/^multi_unicast (struct multi_context *m,$/;"	f	file:
multi_uninit	multi.c	/^multi_uninit (struct multi_context *m)$/;"	f
multiline	options.c	/^    struct buffer *multiline;$/;"	m	union:in_src::__anon3	typeref:struct:in_src::__anon3::buffer	file:
must_die	ssl_common.h	/^  time_t must_die;		\/* this object is destroyed at this time *\/$/;"	m	struct:key_state
must_have_n_keys	crypto.c	/^must_have_n_keys (const char *filename, const char *option, const struct key2 *key2, int n)$/;"	f
must_negotiate	ssl_common.h	/^  time_t must_negotiate;	\/* key negotiation times out if not finished before this time *\/$/;"	m	struct:key_state
mute	options.h	/^  int mute;$/;"	m	struct:options
mute_category	error.c	/^static int mute_category;   \/* GLOBAL *\/$/;"	v	file:
mute_count	error.c	/^static int mute_count;      \/* GLOBAL *\/$/;"	v	file:
mute_cutoff	error.c	/^static int mute_cutoff;     \/* GLOBAL *\/$/;"	v	file:
mute_replay_warnings	options.h	/^  bool mute_replay_warnings;$/;"	m	struct:options
my_debug	ssl_polarssl.c	/^static void my_debug( void *ctx, int level, const char *str )$/;"	f	file:
my_strupr	ntlm.c	/^unsigned char *my_strupr(unsigned char *str)$/;"	f
mydata_index	ssl_openssl.c	/^int mydata_index; \/* GLOBAL *\/$/;"	v
n	clinat.h	/^  int n;$/;"	m	struct:client_nat_option_list
n	crypto.h	/^  int n;                        \/**< The number of \\c key objects stored$/;"	m	struct:key2
n	interval.h	/^  interval_t n;$/;"	m	struct:event_timeout
n	list.c	/^  int n;$/;"	m	struct:word	file:
n	otime.h	/^  int n;$/;"	m	struct:frequency_limit
n	plugin.h	/^  int n;$/;"	m	struct:plugin_common
n	plugin.h	/^  int n;$/;"	m	struct:plugin_option_list
n	plugin.h	/^  int n;$/;"	m	struct:plugin_return
n	route.h	/^  int n;$/;"	m	struct:route_ipv6_list
n	route.h	/^  int n;$/;"	m	struct:route_ipv6_option_list
n	route.h	/^  int n;$/;"	m	struct:route_list
n	route.h	/^  int n;$/;"	m	struct:route_option_list
n_addrs	route.h	/^  int n_addrs; \/* len of addrs, may be 0 *\/$/;"	m	struct:route_gateway_info
n_bcast_buf	options.h	/^  int n_bcast_buf;$/;"	m	struct:options
n_buckets	list.h	/^  int n_buckets;$/;"	m	struct:hash
n_bypass	route.h	/^  int n_bypass;$/;"	m	struct:route_bypass
n_bytes	ssl_common.h	/^  counter_type n_bytes;			 \/* how many bytes sent\/recvd since last key exchange *\/$/;"	m	struct:key_state
n_check_reload	pf.h	/^  unsigned int n_check_reload;$/;"	m	struct:pf_context
n_clients	manage.h	/^  int (*n_clients) (void *arg);$/;"	m	struct:management_callback
n_clients	mstats.h	/^  int n_clients;$/;"	m	struct:mmap_stats
n_clients	multi.h	/^  int n_clients; \/* current number of authenticated clients *\/$/;"	m	struct:multi_context
n_clients_delta	multi.h	/^  int n_clients_delta; \/* added to multi_context.n_clients when instance is closed *\/$/;"	m	struct:multi_instance
n_comp	lzo.h	/^  int n_comp;$/;"	m	struct:lzo_adaptive_compress
n_cycles	options.h	/^  int n_cycles;$/;"	m	struct:connection_list
n_elements	list.h	/^  int n_elements;$/;"	m	struct:hash
n_esr	mtcp.h	/^  int n_esr;$/;"	m	struct:multi_tcp
n_events	event.c	/^  int n_events;$/;"	m	struct:po_set	file:
n_events	event.c	/^  int n_events;$/;"	m	struct:we_set	file:
n_hard_errors	ssl_common.h	/^  int n_hard_errors;   \/* errors due to TLS negotiation failure *\/$/;"	m	struct:tls_multi
n_net_len	mroute.h	/^  int n_net_len;                 \/* length of net_len array *\/$/;"	m	struct:mroute_helper
n_packets	gremlin.h	/^  int n_packets;$/;"	m	struct:packet_flood_parms
n_packets	ssl_common.h	/^  counter_type n_packets;		 \/* how many packets sent\/recvd since last key exchange *\/$/;"	m	struct:key_state
n_rnd_bytes	misc.c	944;"	d	file:
n_rnd_bytes	misc.c	954;"	d	file:
n_sent_push_requests	openvpn.h	/^  int n_sent_push_requests;$/;"	m	struct:context_2
n_sessions	ssl_common.h	/^  int n_sessions;               \/**< Number of sessions negotiated thus$/;"	m	struct:tls_multi
n_soft_errors	ssl_common.h	/^  int n_soft_errors;   \/* errors due to unrecognized or failed-to-authenticate incoming packets *\/$/;"	m	struct:tls_multi
n_total	lzo.h	/^  int n_total;$/;"	m	struct:lzo_adaptive_compress
n_trunc_post_decrypt	openvpn.h	/^  counter_type n_trunc_post_decrypt;$/;"	m	struct:context_2
n_trunc_pre_encrypt	openvpn.h	/^  counter_type n_trunc_pre_encrypt;$/;"	m	struct:context_2
n_trunc_tun_read	openvpn.h	/^  counter_type n_trunc_tun_read;$/;"	m	struct:context_2
n_trunc_tun_write	openvpn.h	/^  counter_type n_trunc_tun_write;$/;"	m	struct:context_2
name	packet_id.h	/^  const char *name;$/;"	m	struct:packet_id_rec
name	ssl_verify.h	/^  const char *name;$/;"	m	struct:x509_track
name	tun.h	/^  const char *name;$/;"	m	struct:panel_reg
name	win32.h	/^  const char *name;$/;"	m	struct:semaphore
name_to_guid	tun.c	/^name_to_guid (const char *name, const struct tap_reg *tap_reg, const struct panel_reg *panel_reg)$/;"	f	file:
nbdd	tun.h	/^  in_addr_t nbdd[N_DHCP_ADDR];$/;"	m	struct:tuntap_options
nbdd_len	tun.h	/^  int nbdd_len;$/;"	m	struct:tuntap_options
ne32	manage.h	/^  struct net_event_win32 ne32;$/;"	m	struct:man_connection	typeref:struct:man_connection::net_event_win32
need_keys	crypto.h	/^  int need_keys;                \/**< The number of key objects necessary$/;"	m	struct:key_direction_state
net_event_win32	win32.h	/^struct net_event_win32$/;"	s
net_event_win32_clear_selected_events	win32.h	/^net_event_win32_clear_selected_events (struct net_event_win32 *ne, long selected_events)$/;"	f
net_event_win32_close	win32.c	/^net_event_win32_close (struct net_event_win32 *ne)$/;"	f
net_event_win32_defined	win32.h	/^net_event_win32_defined (const struct net_event_win32 *ne)$/;"	f
net_event_win32_get_event	win32.h	/^net_event_win32_get_event (struct net_event_win32 *ne)$/;"	f
net_event_win32_get_event_mask	win32.h	/^net_event_win32_get_event_mask (const struct net_event_win32 *ne)$/;"	f
net_event_win32_init	win32.c	/^net_event_win32_init (struct net_event_win32 *ne)$/;"	f
net_event_win32_reset	win32.c	/^net_event_win32_reset (struct net_event_win32 *ne)$/;"	f
net_event_win32_reset_write	win32.c	/^net_event_win32_reset_write (struct net_event_win32 *ne)$/;"	f
net_event_win32_start	win32.c	/^net_event_win32_start (struct net_event_win32 *ne, long network_events, socket_descriptor_t sd)$/;"	f
net_event_win32_stop	win32.c	/^net_event_win32_stop (struct net_event_win32 *ne)$/;"	f
net_len	mroute.h	/^  uint8_t net_len[MR_HELPER_NET_LEN];      \/* CIDR netlengths in descending order *\/$/;"	m	struct:mroute_helper
net_len_refcount	mroute.h	/^  int net_len_refcount[MR_HELPER_NET_LEN]; \/* refcount of each netlength *\/$/;"	m	struct:mroute_helper
net_time_t	packet_id.h	/^typedef uint16_t net_time_t;$/;"	t
net_time_t	packet_id.h	/^typedef uint32_t net_time_t;$/;"	t
netbios_node_type	tun.h	/^  int netbios_node_type;     \/* NBT 1,2,4,8 (46) *\/$/;"	m	struct:tuntap_options
netbios_scope	tun.h	/^  const char *netbios_scope; \/* NBS (47) *\/$/;"	m	struct:tuntap_options
netbits	mroute.h	/^  uint8_t netbits;  \/* number of bits in network part of address,$/;"	m	struct:mroute_addr
netbits	route.h	/^  int netbits;$/;"	m	struct:iroute
netbits	route.h	/^  unsigned int netbits;$/;"	m	struct:iroute_ipv6
netbits	route.h	/^  unsigned int netbits;$/;"	m	struct:route_ipv6
netbits_ipv6	tun.h	/^  int netbits_ipv6;$/;"	m	struct:tuntap
netbits_to_netmask	route.h	/^netbits_to_netmask (const int netbits)$/;"	f
netbsd_modify_read_write_return	tun.c	/^netbsd_modify_read_write_return (int len)$/;"	f	file:
netcmd_semaphore	win32.c	/^struct semaphore netcmd_semaphore; \/* GLOBAL *\/$/;"	v	typeref:struct:semaphore
netcmd_semaphore_close	win32.c	/^netcmd_semaphore_close (void)$/;"	f
netcmd_semaphore_init	win32.c	/^netcmd_semaphore_init (void)$/;"	f
netcmd_semaphore_lock	win32.c	/^netcmd_semaphore_lock (void)$/;"	f
netcmd_semaphore_release	win32.c	/^netcmd_semaphore_release (void)$/;"	f
netmask	clinat.h	/^  in_addr_t netmask;$/;"	m	struct:client_nat_entry
netmask	pf.h	/^  in_addr_t netmask;$/;"	m	struct:ipv4_subnet
netmask	route.h	/^  const char *netmask;$/;"	m	struct:route_option
netmask	route.h	/^  in_addr_t netmask;$/;"	m	struct:route_gateway_address
netmask	route.h	/^  in_addr_t netmask;$/;"	m	struct:route_ipv4
netmask_to_netbits	route.c	/^netmask_to_netbits (const in_addr_t network, const in_addr_t netmask, int *netbits)$/;"	f
netsh_command	tun.c	/^netsh_command (const struct argv *a, int n)$/;"	f	file:
netsh_enable_dhcp	tun.c	/^netsh_enable_dhcp (const struct tuntap_options *to,$/;"	f	file:
netsh_get_id	tun.c	/^netsh_get_id (const char *dev_node, struct gc_arena *gc)$/;"	f	file:
netsh_ifconfig	tun.c	/^netsh_ifconfig (const struct tuntap_options *to,$/;"	f	file:
netsh_ifconfig_options	tun.c	/^netsh_ifconfig_options (const char *type,$/;"	f	file:
network	clinat.h	/^  in_addr_t network;$/;"	m	struct:client_nat_entry
network	pf.h	/^  in_addr_t network;$/;"	m	struct:ipv4_subnet
network	route.h	/^  const char *network;$/;"	m	struct:route_option
network	route.h	/^  in_addr_t network;$/;"	m	struct:iroute
network	route.h	/^  in_addr_t network;$/;"	m	struct:route_ipv4
network	route.h	/^  struct in6_addr network;$/;"	m	struct:iroute_ipv6	typeref:struct:iroute_ipv6::in6_addr
network	route.h	/^  struct in6_addr network;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::in6_addr
new_client_nat_list	clinat.c	/^new_client_nat_list (struct gc_arena *gc)$/;"	f
new_connection_limiter	multi.h	/^  struct frequency_limit *new_connection_limiter;$/;"	m	struct:multi_context	typeref:struct:multi_context::frequency_limit
new_route_ipv6_list	route.c	/^new_route_ipv6_list (const int max_routes, struct gc_arena *a)$/;"	f
new_route_ipv6_option_list	route.c	/^new_route_ipv6_option_list (const int max_routes, struct gc_arena *a)$/;"	f
new_route_list	route.c	/^new_route_list (const int max_routes, struct gc_arena *a)$/;"	f
new_route_option_list	route.c	/^new_route_option_list (const int max_routes, struct gc_arena *a)$/;"	f
next	buffer.h	/^  struct buffer_entry *next;$/;"	m	struct:buffer_entry	typeref:struct:buffer_entry::buffer_entry
next	buffer.h	/^  struct gc_entry *next;        \/**< Pointer to the next item in the$/;"	m	struct:gc_entry	typeref:struct:gc_entry::gc_entry
next	gremlin.c	/^static time_t next;      \/* GLOBAL *\/$/;"	v	file:
next	list.h	/^  struct hash_element *next;$/;"	m	struct:hash_element	typeref:struct:hash_element::hash_element
next	lzo.h	/^  time_t next;$/;"	m	struct:lzo_adaptive_compress
next	misc.h	/^  struct env_item *next;$/;"	m	struct:env_item	typeref:struct:env_item::env_item
next	pf.h	/^  struct pf_cn_elem *next;$/;"	m	struct:pf_cn_elem	typeref:struct:pf_cn_elem::pf_cn_elem
next	pf.h	/^  struct pf_subnet *next;$/;"	m	struct:pf_subnet	typeref:struct:pf_subnet::pf_subnet
next	ps.c	/^  struct proxy_connection *next;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::proxy_connection	file:
next	pushlist.h	/^  struct push_entry *next;$/;"	m	struct:push_entry	typeref:struct:push_entry::push_entry
next	route.h	/^  struct iroute *next;$/;"	m	struct:iroute	typeref:struct:iroute::iroute
next	route.h	/^  struct iroute_ipv6 *next;$/;"	m	struct:iroute_ipv6	typeref:struct:iroute_ipv6::iroute_ipv6
next	socket.h	/^  struct buffer next;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer
next	ssl_verify.h	/^  const struct x509_track *next;$/;"	m	struct:x509_track	typeref:struct:x509_track::x509_track
next	tun.h	/^  struct panel_reg *next;$/;"	m	struct:panel_reg	typeref:struct:panel_reg::panel_reg
next	tun.h	/^  struct tap_reg *next;$/;"	m	struct:tap_reg	typeref:struct:tap_reg::tap_reg
next_block	ssl_polarssl.h	/^    buffer_entry *next_block;$/;"	m	struct:_buffer_entry
next_connection_entry	init.c	/^next_connection_entry (struct context *c)$/;"	f	file:
next_try	reliable.h	/^  time_t next_try;$/;"	m	struct:reliable_entry
nexthdr	proto.h	/^        uint8_t		nexthdr;$/;"	m	struct:openvpn_ipv6hdr
nice	options.h	/^  int nice;$/;"	m	struct:options
nid	ssl_verify.h	/^  int nid;$/;"	m	struct:x509_track
no_advance	options.h	/^  bool no_advance;$/;"	m	struct:connection_list
no_more_than_n_args	options.c	/^no_more_than_n_args (const int msglevel,$/;"	f	file:
nocache	misc.h	/^  bool nocache;$/;"	m	struct:user_pass
nonce_data	crypto.c	/^static uint8_t *nonce_data = NULL; \/* GLOBAL *\/$/;"	v	file:
nonce_md	crypto.c	/^static const md_kt_t *nonce_md = NULL; \/* GLOBAL *\/$/;"	v	file:
nonce_secret_len	crypto.c	/^static int nonce_secret_len = 0; \/* GLOBAL *\/$/;"	v	file:
notnull	options.c	/^notnull (const char *arg, const char *description)$/;"	f
now	otime.c	/^time_t now = 0;            \/* GLOBAL *\/$/;"	v
now_adj	otime.c	/^static time_t now_adj = 0; \/* GLOBAL *\/$/;"	v	file:
now_usec	otime.c	/^time_t now_usec = 0;       \/* GLOBAL *\/$/;"	v
np	buffer.c	/^np (const char *str)$/;"	f
ns_cert_type	options.h	/^  int ns_cert_type; \/* set to 0, NS_CERT_CHECK_SERVER, or NS_CERT_CHECK_CLIENT *\/$/;"	m	struct:options
ns_cert_type	ssl_common.h	/^  int ns_cert_type;$/;"	m	struct:tls_options
ntlm_phase_1	ntlm.c	/^ntlm_phase_1 (const struct http_proxy_info *p, struct gc_arena *gc)$/;"	f
ntlm_phase_3	ntlm.c	/^ntlm_phase_3 (const struct http_proxy_info *p, const char *phase_2, struct gc_arena *gc)$/;"	f
ntoh_fragment_header_type	fragment.h	199;"	d
ntohpid	packet_id.h	66;"	d
ntohpid	packet_id.h	88;"	d
ntohps	socket.h	67;"	d
ntohtime	packet_id.h	72;"	d
ntohtime	packet_id.h	90;"	d
ntp	tun.h	/^  in_addr_t ntp[N_DHCP_ADDR];$/;"	m	struct:tuntap_options
ntp_len	tun.h	/^  int ntp_len;$/;"	m	struct:tuntap_options
occ	options.h	/^  bool occ;$/;"	m	struct:options
occ_interval	openvpn.h	/^  struct event_timeout occ_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
occ_magic	occ.c	/^const uint8_t occ_magic[] = {$/;"	v
occ_mtu_load_n_tries	openvpn.h	/^  int occ_mtu_load_n_tries;$/;"	m	struct:context_2
occ_mtu_load_size	openvpn.h	/^  int occ_mtu_load_size;$/;"	m	struct:context_2
occ_mtu_load_test_interval	openvpn.h	/^  struct event_timeout occ_mtu_load_test_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
occ_n_tries	openvpn.h	/^  int occ_n_tries;$/;"	m	struct:context_2
occ_op	openvpn.h	/^  int occ_op;			\/* INIT to -1 *\/$/;"	m	struct:context_2
occ_reset_op	occ-inline.h	/^occ_reset_op ()$/;"	f
offset	buffer.h	/^  int offset;                   \/**< Offset in bytes of the actual content$/;"	m	struct:buffer
offset	reliable.h	/^  int offset;$/;"	m	struct:reliable
old_window_title	win32.h	/^  char old_window_title [256];$/;"	m	struct:window_title
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
op	dhcp.h	/^  uint8_t op;          \/* message op *\/$/;"	m	struct:dhcp
op	occ.h	/^  int op;			\/* OCC opcode to send to peer *\/$/;"	m	struct:mtu_load_test
opcode	reliable.h	/^  int opcode;$/;"	m	struct:reliable_entry
open1	plugin.h	/^  openvpn_plugin_open_v1 open1;$/;"	m	struct:plugin
open2	plugin.h	/^  openvpn_plugin_open_v2 open2;$/;"	m	struct:plugin
open3	plugin.h	/^  openvpn_plugin_open_v3 open3;$/;"	m	struct:plugin
open_biofp	ssl_openssl.c	/^open_biofp()$/;"	f	file:
open_darwin_utun	tun.c	/^open_darwin_utun (const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)$/;"	f
open_management	init.c	/^open_management (struct context *c)$/;"	f
open_null	tun.c	/^open_null (struct tuntap *tt)$/;"	f	file:
open_plugins	init.c	/^open_plugins (struct context *c, const bool import_options, int init_point)$/;"	f
open_syslog	error.c	/^open_syslog (const char *pgmname, bool stdio_to_null)$/;"	f
open_tty	console.c	/^open_tty (const bool write)$/;"	f	file:
open_tun	tun.c	/^open_tun (const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)$/;"	f
open_tun_generic	tun.c	/^open_tun_generic (const char *dev, const char *dev_type, const char *dev_node,$/;"	f	file:
openssl_name	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	m	struct:__anon10
openvpn_DEPENDENCIES	Makefile	/^openvpn_DEPENDENCIES = $(top_builddir)\/src\/compat\/libcompat.la \\$/;"	m
openvpn_LDADD	Makefile	/^openvpn_LDADD = $(top_builddir)\/src\/compat\/libcompat.la \\$/;"	m
openvpn_OBJECTS	Makefile	/^openvpn_OBJECTS = $(am_openvpn_OBJECTS)$/;"	m
openvpn_PRF	ssl.c	/^openvpn_PRF (const uint8_t *secret,$/;"	f	file:
openvpn_SOURCES	Makefile	/^openvpn_SOURCES = base64.c base64.h basic.h buffer.c buffer.h \\$/;"	m
openvpn_arp	proto.h	/^struct openvpn_arp {$/;"	s
openvpn_base64_decode	base64.c	/^openvpn_base64_decode(const char *str, void *data, int size)$/;"	f
openvpn_base64_encode	base64.c	/^openvpn_base64_encode(const void *data, int size, char **str)$/;"	f
openvpn_close_socket	socket.h	263;"	d
openvpn_close_socket	socket.h	279;"	d
openvpn_connect	socket.c	/^openvpn_connect (socket_descriptor_t sd,$/;"	f
openvpn_decrypt	crypto.c	/^openvpn_decrypt (struct buffer *buf, struct buffer work,$/;"	f
openvpn_dmalloc	memdbg.h	90;"	d
openvpn_encrypt	crypto.c	/^openvpn_encrypt (struct buffer *buf, struct buffer work,$/;"	f
openvpn_errno	error.h	70;"	d
openvpn_errno	error.h	74;"	d
openvpn_ethhdr	proto.h	/^struct openvpn_ethhdr $/;"	s
openvpn_execve	misc.c	/^openvpn_execve (const struct argv *a, const struct env_set *es, const unsigned int flags)$/;"	f
openvpn_execve	win32.c	/^openvpn_execve (const struct argv *a, const struct env_set *es, const unsigned int flags)$/;"	f
openvpn_execve_allowed	misc.c	/^openvpn_execve_allowed (const unsigned int flags)$/;"	f
openvpn_execve_check	misc.c	/^openvpn_execve_check (const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message)$/;"	f
openvpn_exit	error.c	/^openvpn_exit (const int status)$/;"	f
openvpn_getaddrinfo	socket.c	/^openvpn_getaddrinfo (unsigned int flags,$/;"	f
openvpn_gettimeofday	otime.h	/^openvpn_gettimeofday (struct timeval *tv, void *tz)$/;"	f
openvpn_in4_pktinfo	socket.c	/^struct openvpn_in4_pktinfo$/;"	s	file:
openvpn_in6_pktinfo	socket.c	/^struct openvpn_in6_pktinfo$/;"	s	file:
openvpn_inet_aton	socket.c	/^openvpn_inet_aton (const char *dotted_quad, struct in_addr *addr)$/;"	f
openvpn_iphdr	proto.h	/^struct openvpn_iphdr {$/;"	s
openvpn_ipv6hdr	proto.h	/^struct openvpn_ipv6hdr {$/;"	s
openvpn_main	openvpn.c	/^openvpn_main (int argc, char *argv[])$/;"	f	file:
openvpn_name	crypto_polarssl.c	/^typedef struct { const char * openvpn_name; const char * polarssl_name; } cipher_name_pair;$/;"	m	struct:__anon4	file:
openvpn_pktinfo	socket.c	/^union openvpn_pktinfo {$/;"	u	file:
openvpn_plugin_string_list_find	plugin.c	/^openvpn_plugin_string_list_find (struct openvpn_plugin_string_list *l, const char *name)$/;"	f	file:
openvpn_plugin_string_list_free	plugin.c	/^openvpn_plugin_string_list_free (struct openvpn_plugin_string_list *l)$/;"	f	file:
openvpn_plugin_string_list_item_free	plugin.c	/^openvpn_plugin_string_list_item_free (struct openvpn_plugin_string_list *l)$/;"	f	file:
openvpn_popen	misc.c	/^openvpn_popen (const struct argv *a,  const struct env_set *es)$/;"	f
openvpn_run_script	misc.h	/^openvpn_run_script (const struct argv *a, const struct env_set *es, const unsigned int flags, const char *hook)$/;"	f
openvpn_sleep	misc.c	/^openvpn_sleep (const int n)$/;"	f
openvpn_snprintf	buffer.c	/^bool openvpn_snprintf(char *str, size_t size, const char *format, ...)$/;"	f
openvpn_sockaddr	socket.h	/^struct openvpn_sockaddr$/;"	s
openvpn_strerror	error.h	71;"	d
openvpn_strerror	error.h	75;"	d
openvpn_tcphdr	proto.h	/^struct openvpn_tcphdr {$/;"	s
openvpn_time	otime.h	/^openvpn_time (time_t *t)$/;"	f
openvpn_udphdr	proto.h	/^struct openvpn_udphdr {$/;"	s
openvpn_x509_cert_t	ssl_verify_openssl.h	/^typedef X509 openvpn_x509_cert_t;$/;"	t
openvpn_x509_cert_t	ssl_verify_polarssl.h	/^typedef x509_cert openvpn_x509_cert_t;$/;"	t
opt	ssl_common.h	/^  struct tls_options *opt;$/;"	m	struct:tls_session	typeref:struct:tls_session::tls_options
opt	ssl_common.h	/^  struct tls_options opt;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::tls_options
optimal_fragment_size	fragment.c	/^optimal_fragment_size (int len, int max_frag_size)$/;"	f	file:
option	pushlist.h	/^  const char *option;$/;"	m	struct:push_entry
option	route.h	/^  const struct route_option *option;$/;"	m	struct:route_ipv4	typeref:struct:route_ipv4::route_option
option_iroute	options.c	/^option_iroute (struct options *o,$/;"	f	file:
option_iroute_ipv6	options.c	/^option_iroute_ipv6 (struct options *o,$/;"	f	file:
options	dhcp.h	/^  uint8_t options[DHCP_OPTIONS_BUFFER_SIZE];$/;"	m	struct:dhcp_full
options	openvpn.h	/^  struct options options;       \/**< Options loaded from command line or$/;"	m	struct:context	typeref:struct:context::options
options	options.h	/^struct options$/;"	s
options	proxy.h	/^  struct http_proxy_options options;$/;"	m	struct:http_proxy_info	typeref:struct:http_proxy_info::http_proxy_options
options	tun.h	/^  struct tuntap_options options; \/* options set on command line *\/$/;"	m	struct:tuntap	typeref:struct:tuntap::tuntap_options
options_cmp_equal	options.c	/^options_cmp_equal (char *actual, const char *expected)$/;"	f
options_cmp_equal_safe	options.c	/^options_cmp_equal_safe (char *actual, const char *expected, size_t actual_n)$/;"	f
options_detach	options.c	/^options_detach (struct options *o)$/;"	f
options_postprocess	options.c	/^options_postprocess (struct options *options)$/;"	f
options_postprocess_filechecks	options.c	/^options_postprocess_filechecks (struct options *options)$/;"	f	file:
options_postprocess_http_proxy_override	options.c	/^options_postprocess_http_proxy_override (struct options *o)$/;"	f
options_postprocess_mutate	options.c	/^options_postprocess_mutate (struct options *o)$/;"	f	file:
options_postprocess_mutate_ce	options.c	/^options_postprocess_mutate_ce (struct options *o, struct connection_entry *ce)$/;"	f	file:
options_postprocess_mutate_invariant	options.c	/^options_postprocess_mutate_invariant (struct options *options)$/;"	f	file:
options_postprocess_verify	options.c	/^options_postprocess_verify (const struct options *o)$/;"	f	file:
options_postprocess_verify_ce	options.c	/^options_postprocess_verify_ce (const struct options *options, const struct connection_entry *ce)$/;"	f	file:
options_pre_pull	options.h	/^struct options_pre_pull$/;"	s
options_server_import	options.c	/^options_server_import (struct options *o,$/;"	f
options_string	options.c	/^options_string (const struct options *o,$/;"	f
options_string_import	options.c	/^void options_string_import (struct options *options,$/;"	f
options_string_local	openvpn.h	/^  char *options_string_local;$/;"	m	struct:context_2
options_string_remote	openvpn.h	/^  char *options_string_remote;$/;"	m	struct:context_2
options_string_version	options.c	/^options_string_version (const char* s, struct gc_arena *gc)$/;"	f
options_warning	options.c	/^options_warning (char *actual, const char *expected)$/;"	f
options_warning_extract_parm1	options.c	/^options_warning_extract_parm1 (const char *option_string,$/;"	f	file:
options_warning_safe	options.c	/^options_warning_safe (char *actual, const char *expected, size_t actual_n)$/;"	f
options_warning_safe_ml	options.c	/^options_warning_safe_ml (const int msglevel, char *actual, const char *expected, size_t actual_n)$/;"	f	file:
options_warning_safe_scan1	options.c	/^options_warning_safe_scan1 (const int msglevel,$/;"	f	file:
options_warning_safe_scan2	options.c	/^options_warning_safe_scan2 (const int msglevel,$/;"	f	file:
orig_stderr	error.c	/^static HANDLE orig_stderr;$/;"	v	file:
original_recv_size	openvpn.h	/^  int original_recv_size;	\/* temporary *\/$/;"	m	struct:context_2
out	manage.h	/^  struct buffer_list *out;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list
out_key	crypto.h	/^  int out_key;                  \/**< Index into the \\c key2.keys array for$/;"	m	struct:key_direction_state
out_of_memory	error.c	/^out_of_memory (void)$/;"	f
outgoing	fragment.h	/^  struct buffer outgoing;       \/**< Buffer containing the remaining parts$/;"	m	struct:fragment_master	typeref:struct:fragment_master::buffer
outgoing_frag_id	fragment.h	/^  int outgoing_frag_id;         \/**< The fragment ID of the next part to$/;"	m	struct:fragment_master
outgoing_frag_size	fragment.h	/^  int outgoing_frag_size;       \/**< Size in bytes of each part to be$/;"	m	struct:fragment_master
outgoing_return	fragment.h	/^  struct buffer outgoing_return;$/;"	m	struct:fragment_master	typeref:struct:fragment_master::buffer
outgoing_seq_id	fragment.h	/^  int outgoing_seq_id;          \/**< Fragment sequence ID of the current$/;"	m	struct:fragment_master
overlapped	win32.h	/^  OVERLAPPED overlapped;$/;"	m	struct:overlapped_io
overlapped_io	win32.h	/^struct overlapped_io {$/;"	s
overlapped_io_active	win32.h	/^overlapped_io_active (struct overlapped_io *o)$/;"	f
overlapped_io_close	win32.c	/^overlapped_io_close (struct overlapped_io *o)$/;"	f
overlapped_io_init	win32.c	/^overlapped_io_init (struct overlapped_io *o,$/;"	f
overlapped_io_state_ascii	win32.c	/^overlapped_io_state_ascii (const struct overlapped_io *o)$/;"	f
p2mp_iow_flags	mudp.c	/^p2mp_iow_flags (const struct multi_context *m)$/;"	f	file:
p2p_iow_flags	forward-inline.h	/^p2p_iow_flags (const struct context *c)$/;"	f
packet_flood_data	gremlin.c	/^static const struct packet_flood_parms packet_flood_data[] =$/;"	v	typeref:struct:packet_flood_parms	file:
packet_flood_parms	gremlin.h	/^struct packet_flood_parms$/;"	s
packet_id	crypto.h	/^  struct packet_id *packet_id;  \/**< Current packet ID state for both$/;"	m	struct:crypto_options	typeref:struct:crypto_options::packet_id
packet_id	openvpn.h	/^  struct packet_id packet_id;$/;"	m	struct:context_2	typeref:struct:context_2::packet_id
packet_id	packet_id.h	/^struct packet_id$/;"	s
packet_id	reliable.h	/^  packet_id_type packet_id;$/;"	m	struct:reliable
packet_id	reliable.h	/^  packet_id_type packet_id;$/;"	m	struct:reliable_entry
packet_id	reliable.h	/^  packet_id_type packet_id[RELIABLE_ACK_SIZE];$/;"	m	struct:reliable_ack
packet_id	ssl_common.h	/^  struct packet_id packet_id;	       \/* for data channel, to prevent replay attacks *\/$/;"	m	struct:key_state	typeref:struct:key_state::packet_id
packet_id_add	packet_id.c	/^packet_id_add (struct packet_id_rec *p, const struct packet_id_net *pin)$/;"	f
packet_id_alloc_outgoing	packet_id.h	/^packet_id_alloc_outgoing (struct packet_id_send *p, struct packet_id_net *pin, bool long_form)$/;"	f
packet_id_close_to_wrapping	packet_id.h	/^packet_id_close_to_wrapping (const struct packet_id_send *p)$/;"	f
packet_id_debug	packet_id.c	/^packet_id_debug (int msglevel,$/;"	f	file:
packet_id_debug_print	packet_id.c	/^packet_id_debug_print (int msglevel,$/;"	f	file:
packet_id_file	options.h	/^  const char *packet_id_file;$/;"	m	struct:options
packet_id_format	packet_id.h	97;"	d
packet_id_free	packet_id.c	/^packet_id_free (struct packet_id *p)$/;"	f
packet_id_init	packet_id.c	/^packet_id_init (struct packet_id *p, bool tcp_mode, int seq_backtrack, int time_backtrack, const char *name, int unit)$/;"	f
packet_id_interactive_test	packet_id.c	/^packet_id_interactive_test ()$/;"	f
packet_id_net	packet_id.h	/^struct packet_id_net$/;"	s
packet_id_net_print	packet_id.c	/^packet_id_net_print (const struct packet_id_net *pin, bool print_timestamp, struct gc_arena *gc)$/;"	f
packet_id_persist	openvpn.h	/^struct packet_id_persist$/;"	s
packet_id_persist	packet_id.h	/^struct packet_id_persist$/;"	s
packet_id_persist_close	packet_id.c	/^packet_id_persist_close (struct packet_id_persist *p)$/;"	f
packet_id_persist_enabled	packet_id.h	/^packet_id_persist_enabled (const struct packet_id_persist *p)$/;"	f
packet_id_persist_file_image	packet_id.h	/^struct packet_id_persist_file_image$/;"	s
packet_id_persist_init	openvpn.h	/^packet_id_persist_init (struct packet_id_persist *p)$/;"	f
packet_id_persist_init	packet_id.c	/^packet_id_persist_init (struct packet_id_persist *p)$/;"	f
packet_id_persist_interval	openvpn.h	/^  struct event_timeout packet_id_persist_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
packet_id_persist_load	packet_id.c	/^packet_id_persist_load (struct packet_id_persist *p, const char *filename)$/;"	f
packet_id_persist_load_obj	packet_id.c	/^packet_id_persist_load_obj (const struct packet_id_persist *p, struct packet_id *pid)$/;"	f
packet_id_persist_print	packet_id.c	/^packet_id_persist_print (const struct packet_id_persist *p, struct gc_arena *gc)$/;"	f
packet_id_persist_save	packet_id.c	/^packet_id_persist_save (struct packet_id_persist *p)$/;"	f
packet_id_persist_save_obj	packet_id.h	/^packet_id_persist_save_obj (struct packet_id_persist *p, const struct packet_id* pid)$/;"	f
packet_id_print_type	packet_id.h	/^typedef unsigned int packet_id_print_type;$/;"	t
packet_id_read	packet_id.c	/^packet_id_read (struct packet_id_net *pin, struct buffer *buf, bool long_form)$/;"	f
packet_id_reap	packet_id.c	/^packet_id_reap (struct packet_id_rec *p)$/;"	f
packet_id_reap_test	packet_id.h	/^packet_id_reap_test (struct packet_id_rec *p)$/;"	f
packet_id_rec	packet_id.h	/^struct packet_id_rec$/;"	s
packet_id_send	packet_id.h	/^struct packet_id_send$/;"	s
packet_id_size	packet_id.h	/^packet_id_size (bool long_form)$/;"	f
packet_id_test	packet_id.c	/^packet_id_test (struct packet_id_rec *p,$/;"	f
packet_id_type	packet_id.h	/^typedef uint32_t packet_id_type;$/;"	t
packet_id_type	packet_id.h	/^typedef uint8_t packet_id_type;$/;"	t
packet_id_write	packet_id.c	/^packet_id_write (const struct packet_id_net *pin, struct buffer *buf, bool long_form, bool prepend)$/;"	f
packet_opcode_name	ssl.c	/^packet_opcode_name (int op)$/;"	f	file:
packet_size	gremlin.h	/^  int packet_size;$/;"	m	struct:packet_flood_parms
packet_size_type	socket.h	/^typedef uint16_t packet_size_type;$/;"	t
packet_timeout	ssl_common.h	/^  interval_t packet_timeout;$/;"	m	struct:tls_options
panel_reg	tun.h	/^struct panel_reg$/;"	s
parent	schedule.h	/^  struct schedule_entry *parent; \/* treap (btree) links *\/$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry
parse_argv	options.c	/^parse_argv (struct options *options,$/;"	f
parse_cid	manage.c	/^parse_cid (const char *str, unsigned long *cid)$/;"	f	file:
parse_hash_fingerprint	options.c	/^parse_hash_fingerprint(const char *str, int nbytes, int msglevel, struct gc_arena *gc)$/;"	f	file:
parse_http_proxy_override	options.c	/^parse_http_proxy_override (const char *server,$/;"	f	file:
parse_kid	manage.c	/^parse_kid (const char *str, unsigned int *kid)$/;"	f	file:
parse_line	options.c	/^parse_line (const char *line,$/;"	f
parse_signal	sig.c	/^parse_signal (const char *signame)$/;"	f
parse_topology	options.c	/^parse_topology (const char *str, const int msglevel)$/;"	f
pass_config_info	ssl_common.h	/^  bool pass_config_info;$/;"	m	struct:tls_options
passbuf	ssl.c	/^static struct user_pass passbuf; \/* GLOBAL *\/$/;"	v	typeref:struct:user_pass	file:
passtos	options.h	/^  bool passtos;                  $/;"	m	struct:options
password	misc.h	/^  char password[USER_PASS_LEN];$/;"	m	struct:user_pass
password_tries	manage.h	/^  int password_tries;$/;"	m	struct:man_connection
password_verified	manage.h	/^  bool password_verified;$/;"	m	struct:man_connection
pause_exit_enabled	win32.c	/^static bool pause_exit_enabled = false; \/* GLOBAL *\/$/;"	v	file:
paybuf	ssl_common.h	/^  struct buffer_list *paybuf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer_list
payload_len	proto.h	/^        uint16_t	payload_len;$/;"	m	struct:openvpn_ipv6hdr
pct_name	pf.c	/^pct_name (const int type)$/;"	f	file:
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
peer_info	ssl_common.h	/^  char *peer_info;$/;"	m	struct:tls_multi
pem_password_callback	ssl.c	/^pem_password_callback (char *buf, int size, int rwflag, void *u)$/;"	f
pem_password_setup	ssl.c	/^pem_password_setup (const char *auth_file)$/;"	f
pending	multi.h	/^  struct multi_instance *pending;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance
per	otime.h	/^  int per;$/;"	m	struct:frequency_limit
per_client	plugin.h	/^  struct plugin_per_client per_client;$/;"	m	struct:plugin_list	typeref:struct:plugin_list::plugin_per_client
per_client_context	plugin.h	/^  void *per_client_context[MAX_PLUGINS];$/;"	m	struct:plugin_per_client
per_second_trigger	multi.h	/^  time_t per_second_trigger;$/;"	m	struct:multi_context
perf	perf.c	/^  struct perf perf[PERF_N];$/;"	m	struct:perf_set	typeref:struct:perf_set::perf	file:
perf	perf.c	/^struct perf$/;"	s	file:
perf_interrupt	perf.c	/^perf_interrupt (struct perf *p)$/;"	f	file:
perf_output_results	perf.c	/^perf_output_results (void)$/;"	f
perf_output_results	perf.h	/^static inline void perf_output_results (void) {}$/;"	f
perf_pop	perf.c	/^perf_pop (void)$/;"	f
perf_pop	perf.h	/^static inline void perf_pop (void) {}$/;"	f
perf_print_state	perf.c	/^perf_print_state (int lev)$/;"	f	file:
perf_push	perf.c	/^perf_push (int type)$/;"	f
perf_push	perf.h	/^static inline void perf_push (int type) {}$/;"	f
perf_resume	perf.c	/^perf_resume (struct perf *p)$/;"	f	file:
perf_set	perf.c	/^static struct perf_set perf_set;$/;"	v	typeref:struct:perf_set	file:
perf_set	perf.c	/^struct perf_set$/;"	s	file:
perf_start	perf.c	/^perf_start (struct perf *p)$/;"	f	file:
perf_stop	perf.c	/^perf_stop (struct perf *p)$/;"	f	file:
persist	manage.h	/^  struct man_persist persist;$/;"	m	struct:management	typeref:struct:management::man_persist
persist	openvpn.h	/^  struct context_persist persist;$/;"	m	struct:context	typeref:struct:context::context_persist
persist_config	options.h	/^  bool persist_config;$/;"	m	struct:options
persist_key	options.h	/^  bool persist_key;             \/* Don't re-read key files on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options
persist_local_ip	options.h	/^  bool persist_local_ip;        \/* Don't re-resolve local address on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options
persist_mode	options.h	/^  int persist_mode;$/;"	m	struct:options
persist_remote_ip	options.h	/^  bool persist_remote_ip;       \/* Don't re-resolve remote address on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options
persist_tun	options.h	/^  bool persist_tun;             \/* Don't close\/reopen TUN\/TAP dev on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options
persistent_if	tun.h	/^  bool persistent_if;		\/* if existed before, keep on program end *\/$/;"	m	struct:tuntap
pf	openvpn.h	/^  struct pf_context pf;$/;"	m	struct:context_2	typeref:struct:context_2::pf_context
pf_addr_test	pf-inline.h	/^pf_addr_test (const struct context *src, const struct mroute_addr *dest, const char *prefix)$/;"	f
pf_addr_test_dowork	pf.c	/^pf_addr_test_dowork (const struct context *src, const struct mroute_addr *dest, const char *prefix)$/;"	f
pf_addr_test_print	pf.c	/^pf_addr_test_print (const char *prefix,$/;"	f	file:
pf_c2c_test	pf-inline.h	/^pf_c2c_test (const struct context *src, const struct context *dest, const char *prefix)$/;"	f
pf_check_reload	pf.c	/^pf_check_reload (struct context *c)$/;"	f
pf_cn	pf.h	/^struct pf_cn {$/;"	s
pf_cn_elem	pf.h	/^struct pf_cn_elem {$/;"	s
pf_cn_set	pf.h	/^struct pf_cn_set {$/;"	s
pf_cn_set_print	pf.c	/^pf_cn_set_print (const struct pf_cn_set *s, const int lev)$/;"	f	file:
pf_cn_test	pf.c	/^pf_cn_test (struct pf_set *pfs, const struct tls_multi *tm, const int type, const char *prefix)$/;"	f
pf_cn_test_print	pf.c	/^pf_cn_test_print (const char *prefix,$/;"	f	file:
pf_context	pf.h	/^struct pf_context {$/;"	s
pf_context_print	pf.c	/^pf_context_print (const struct pf_context *pfc, const char *prefix, const int lev)$/;"	f
pf_destroy	pf.c	/^pf_destroy (struct pf_set *pfs)$/;"	f	file:
pf_destroy_context	pf.c	/^pf_destroy_context (struct pf_context *pfc)$/;"	f
pf_init	pf.c	/^pf_init (const struct buffer_list *bl, const char *prefix, const bool allow_kill)$/;"	f	file:
pf_init_context	pf.c	/^pf_init_context (struct context *c)$/;"	f
pf_init_from_file	pf.c	/^pf_init_from_file (const char *fn)$/;"	f	file:
pf_kill_test	pf-inline.h	/^pf_kill_test (const struct pf_set *pfs)$/;"	f
pf_load_from_buffer_list	pf.c	/^pf_load_from_buffer_list (struct context *c, const struct buffer_list *config)$/;"	f
pf_set	pf.h	/^struct pf_set {$/;"	s
pf_set_print	pf.c	/^pf_set_print (const struct pf_set *pfs, const int lev)$/;"	f	file:
pf_subnet	pf.h	/^struct pf_subnet {$/;"	s
pf_subnet_set	pf.h	/^struct pf_subnet_set {$/;"	s
pf_subnet_set_print	pf.c	/^pf_subnet_set_print (const struct pf_subnet_set *s, const int lev)$/;"	f	file:
pfs	pf.h	/^  struct pf_set *pfs;$/;"	m	struct:pf_context	typeref:struct:pf_context::pf_set
pgmname_syslog	error.c	/^static char *pgmname_syslog;  \/* GLOBAL *\/$/;"	v	file:
pi	socket.h	/^  } pi;$/;"	m	struct:link_socket_actual	typeref:union:link_socket_actual::__anon9
pi4	socket.c	/^  struct in_addr pi4;$/;"	m	struct:openvpn_in4_pktinfo	typeref:struct:openvpn_in4_pktinfo::in_addr	file:
pi4	socket.c	/^  struct in_pktinfo pi4;$/;"	m	struct:openvpn_in4_pktinfo	typeref:struct:openvpn_in4_pktinfo::in_pktinfo	file:
pi6	socket.c	/^  struct in6_pktinfo pi6;$/;"	m	struct:openvpn_in6_pktinfo	typeref:struct:openvpn_in6_pktinfo::in6_pktinfo	file:
pid_persist	crypto.h	/^  struct packet_id_persist *pid_persist;$/;"	m	struct:crypto_options	typeref:struct:crypto_options::packet_id_persist
pid_persist	openvpn.h	/^  struct packet_id_persist pid_persist;$/;"	m	struct:context_1	typeref:struct:context_1::packet_id_persist
pid_state	misc.h	/^struct pid_state {$/;"	s
pid_state	openvpn.h	/^  struct pid_state pid_state;$/;"	m	struct:context_0	typeref:struct:context_0::pid_state
ping_rec_interval	openvpn.h	/^  struct event_timeout ping_rec_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
ping_rec_timeout	options.h	/^  int ping_rec_timeout;         \/* Expect a TCP\/UDP ping from remote at least once every n seconds *\/$/;"	m	struct:options
ping_rec_timeout_action	options.h	/^  int ping_rec_timeout_action;  \/* What action to take on ping_rec_timeout (exit or restart)? *\/$/;"	m	struct:options
ping_send_interval	openvpn.h	/^  struct event_timeout ping_send_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
ping_send_timeout	options.h	/^  int ping_send_timeout;        \/* Send a TCP\/UDP ping to remote every n seconds *\/$/;"	m	struct:options
ping_string	ping.c	/^const uint8_t ping_string[] = {$/;"	v
ping_timer_remote	options.h	/^  bool ping_timer_remote;       \/* Run ping timer only if we have a remote address *\/$/;"	m	struct:options
pkcs11_addProvider	pkcs11.c	/^pkcs11_addProvider ($/;"	f
pkcs11_cert_private	options.h	/^  bool pkcs11_cert_private[MAX_PARMS];$/;"	m	struct:options
pkcs11_certificate_dn	pkcs11_openssl.c	/^pkcs11_certificate_dn (pkcs11h_certificate_t certificate, struct gc_arena *gc)$/;"	f
pkcs11_certificate_dn	pkcs11_polarssl.c	/^pkcs11_certificate_dn (pkcs11h_certificate_t cert, struct gc_arena *gc)$/;"	f
pkcs11_certificate_serial	pkcs11_openssl.c	/^pkcs11_certificate_serial (pkcs11h_certificate_t certificate, char *serial,$/;"	f
pkcs11_certificate_serial	pkcs11_polarssl.c	/^pkcs11_certificate_serial (pkcs11h_certificate_t cert, char *serial,$/;"	f
pkcs11_forkFixup	pkcs11.c	/^pkcs11_forkFixup () {$/;"	f
pkcs11_id	options.h	/^  const char *pkcs11_id;$/;"	m	struct:options
pkcs11_id_management	options.h	/^  bool pkcs11_id_management;$/;"	m	struct:options
pkcs11_init_tls_session	pkcs11_openssl.c	/^pkcs11_init_tls_session(pkcs11h_certificate_t certificate,$/;"	f
pkcs11_init_tls_session	pkcs11_polarssl.c	/^pkcs11_init_tls_session(pkcs11h_certificate_t certificate,$/;"	f
pkcs11_initialize	pkcs11.c	/^pkcs11_initialize ($/;"	f
pkcs11_logout	pkcs11.c	/^pkcs11_logout() {$/;"	f
pkcs11_management_id_count	pkcs11.c	/^pkcs11_management_id_count () {$/;"	f
pkcs11_management_id_get	pkcs11.c	/^pkcs11_management_id_get ($/;"	f
pkcs11_pin_cache_period	options.h	/^  int pkcs11_pin_cache_period;$/;"	m	struct:options
pkcs11_private_mode	options.h	/^  unsigned pkcs11_private_mode[MAX_PARMS];$/;"	m	struct:options
pkcs11_protected_authentication	options.h	/^  bool pkcs11_protected_authentication[MAX_PARMS];$/;"	m	struct:options
pkcs11_providers	options.h	/^  const char *pkcs11_providers[MAX_PARMS];$/;"	m	struct:options
pkcs11_terminate	pkcs11.c	/^pkcs11_terminate () {$/;"	f
pkcs12_file	options.h	/^  const char *pkcs12_file;$/;"	m	struct:options
pkcs12_file_inline	options.h	/^  const char *pkcs12_file_inline; \/* contains the base64 encoding of pkcs12 file *\/$/;"	m	struct:options
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/openvpn$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/openvpn$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/openvpn$/;"	m
pkglibexecdir	Makefile	/^pkglibexecdir = $(libexecdir)\/openvpn$/;"	m
plaintext_read_buf	ssl_common.h	/^  struct buffer plaintext_read_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer
plaintext_write_buf	ssl_common.h	/^  struct buffer plaintext_write_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer
platform_access	platform.c	/^platform_access (const char *path, int mode)$/;"	f
platform_chdir	platform.c	/^platform_chdir (const char* dir)$/;"	f
platform_chroot	platform.c	/^platform_chroot (const char *path)$/;"	f
platform_fopen	platform.c	/^platform_fopen (const char *path, const char *mode)$/;"	f
platform_getpid	platform.c	/^platform_getpid ()$/;"	f
platform_group_get	platform.c	/^platform_group_get (const char *groupname, struct platform_state_group *state)$/;"	f
platform_group_set	platform.c	/^platform_group_set (const struct platform_state_group *state)$/;"	f
platform_mlockall	platform.c	/^platform_mlockall(bool print_msg)$/;"	f
platform_nice	platform.c	/^platform_nice (int niceval)$/;"	f
platform_open	platform.c	/^platform_open (const char *path, int flags, int mode)$/;"	f
platform_sleep_milliseconds	platform.c	/^platform_sleep_milliseconds (unsigned int n)$/;"	f
platform_sleep_until_signal	platform.c	/^platform_sleep_until_signal (void)$/;"	f
platform_stat	platform.c	/^platform_stat (const char *path, platform_stat_t *buf)$/;"	f
platform_stat_t	platform.h	/^typedef struct _stat platform_stat_t;$/;"	t	typeref:struct:_stat
platform_stat_t	platform.h	/^typedef struct stat platform_stat_t;$/;"	t	typeref:struct:stat
platform_state_group	openvpn.h	/^  struct platform_state_group platform_state_group;$/;"	m	struct:context_0	typeref:struct:context_0::platform_state_group
platform_state_group	platform.h	/^struct platform_state_group {$/;"	s
platform_state_group_gid	platform.h	/^platform_state_group_gid (const struct platform_state_group *s)$/;"	f
platform_state_user	openvpn.h	/^  struct platform_state_user platform_state_user;$/;"	m	struct:context_0	typeref:struct:context_0::platform_state_user
platform_state_user	platform.h	/^struct platform_state_user {$/;"	s
platform_state_user_uid	platform.h	/^platform_state_user_uid (const struct platform_state_user *s)$/;"	f
platform_system_ok	platform.c	/^platform_system_ok (int stat)$/;"	f
platform_unlink	platform.c	/^platform_unlink (const char *filename)$/;"	f
platform_user_get	platform.c	/^platform_user_get (const char *username, struct platform_state_user *state)$/;"	f
platform_user_set	platform.c	/^platform_user_set (const struct platform_state_user *state)$/;"	f
plugin	plugin.h	/^struct plugin {$/;"	s
plugin_abort	plugin.c	/^plugin_abort (void)$/;"	f
plugin_abort_item	plugin.c	/^plugin_abort_item (const struct plugin *p)$/;"	f	file:
plugin_call	plugin.h	/^plugin_call(const struct plugin_list *pl,$/;"	f
plugin_call_item	plugin.c	/^plugin_call_item (const struct plugin *p,$/;"	f	file:
plugin_call_ssl	plugin.c	/^plugin_call_ssl (const struct plugin_list *pl,$/;"	f
plugin_call_ssl	plugin.h	/^plugin_call_ssl (const struct plugin_list *pl,$/;"	f
plugin_close_item	plugin.c	/^plugin_close_item (struct plugin *p)$/;"	f	file:
plugin_common	plugin.h	/^struct plugin_common$/;"	s
plugin_common_close	plugin.c	/^plugin_common_close (struct plugin_common *pc)$/;"	f	file:
plugin_common_init	plugin.c	/^plugin_common_init (const struct plugin_option_list *list)$/;"	f	file:
plugin_common_open	plugin.c	/^plugin_common_open (struct plugin_common *pc,$/;"	f	file:
plugin_defined	plugin.c	/^plugin_defined (const struct plugin_list *pl, const int type)$/;"	f
plugin_defined	plugin.h	/^plugin_defined (const struct plugin_list *pl, const int type)$/;"	f
plugin_handle	plugin.h	/^  openvpn_plugin_handle_t plugin_handle;$/;"	m	struct:plugin
plugin_init_item	plugin.c	/^plugin_init_item (struct plugin *p, const struct plugin_option *o)$/;"	f	file:
plugin_list	options.h	/^  struct plugin_option_list *plugin_list;$/;"	m	struct:options	typeref:struct:options::plugin_option_list
plugin_list	plugin.h	/^struct plugin_list { int dummy; };$/;"	s
plugin_list	plugin.h	/^struct plugin_list$/;"	s
plugin_list_close	plugin.c	/^plugin_list_close (struct plugin_list *pl)$/;"	f
plugin_list_inherit	plugin.c	/^plugin_list_inherit (const struct plugin_list *src)$/;"	f
plugin_list_init	plugin.c	/^plugin_list_init (const struct plugin_option_list *list)$/;"	f
plugin_list_open	plugin.c	/^plugin_list_open (struct plugin_list *pl,$/;"	f
plugin_log	plugin.c	/^plugin_log (openvpn_plugin_log_flags_t flags, const char *name, const char *format, ...)$/;"	f	file:
plugin_mask_string	plugin.c	/^plugin_mask_string (const unsigned int type_mask, struct gc_arena *gc)$/;"	f	file:
plugin_n	plugin.h	/^plugin_n (const struct plugin_list *pl)$/;"	f
plugin_open_item	plugin.c	/^plugin_open_item (struct plugin *p,$/;"	f	file:
plugin_option	plugin.h	/^struct plugin_option {$/;"	s
plugin_option_list	plugin.h	/^struct plugin_option_list {$/;"	s
plugin_option_list_add	plugin.c	/^plugin_option_list_add (struct plugin_option_list *list, char **p, struct gc_arena *gc)$/;"	f
plugin_option_list_new	plugin.c	/^plugin_option_list_new (struct gc_arena *gc)$/;"	f
plugin_option_list_print	plugin.c	/^plugin_option_list_print (const struct plugin_option_list *list, int msglevel)$/;"	f
plugin_per_client	plugin.h	/^struct plugin_per_client$/;"	s
plugin_per_client_destroy	plugin.c	/^plugin_per_client_destroy (const struct plugin_common *pc, struct plugin_per_client *cli)$/;"	f	file:
plugin_per_client_init	plugin.c	/^plugin_per_client_init (const struct plugin_common *pc,$/;"	f	file:
plugin_return	plugin.h	/^struct plugin_return { int dummy; };$/;"	s
plugin_return	plugin.h	/^struct plugin_return$/;"	s
plugin_return_defined	plugin.h	/^plugin_return_defined (const struct plugin_return *pr)$/;"	f
plugin_return_free	plugin.c	/^plugin_return_free (struct plugin_return *pr)$/;"	f
plugin_return_get_column	plugin.c	/^plugin_return_get_column (const struct plugin_return *src,$/;"	f
plugin_return_init	plugin.h	/^plugin_return_init (struct plugin_return *pr)$/;"	f
plugin_return_print	plugin.c	/^plugin_return_print (const int msglevel, const char *prefix, const struct plugin_return *pr)$/;"	f
plugin_show_args_env	plugin.c	/^plugin_show_args_env (int msglevel, const char *argv[], const char *envp[])$/;"	f	file:
plugin_show_string_array	plugin.c	/^plugin_show_string_array (int msglevel, const char *name, const char *array[])$/;"	f	file:
plugin_supported_types	plugin.c	/^plugin_supported_types (void)$/;"	f	file:
plugin_type_mask	plugin.h	/^  unsigned int plugin_type_mask;$/;"	m	struct:plugin
plugin_type_name	plugin.c	/^plugin_type_name (const int type)$/;"	f	file:
plugin_vlog	plugin.c	/^plugin_vlog (openvpn_plugin_log_flags_t flags, const char *name, const char *format, va_list arglist)$/;"	f	file:
plugindir	Makefile	/^plugindir = $(libdir)\/openvpn\/plugins$/;"	m
plugins	openvpn.h	/^  struct plugin_list *plugins;  \/**< List of plug-ins. *\/$/;"	m	struct:context	typeref:struct:context::plugin_list
plugins	plugin.h	/^  struct plugin plugins[MAX_PLUGINS];$/;"	m	struct:plugin_common	typeref:struct:plugin_common::plugin
plugins	plugin.h	/^  struct plugin_option plugins[MAX_PLUGINS];$/;"	m	struct:plugin_option_list	typeref:struct:plugin_option_list::plugin_option
plugins	socket.h	/^  const struct plugin_list *plugins;$/;"	m	struct:link_socket_info	typeref:struct:link_socket_info::plugin_list
plugins	ssl_common.h	/^  const struct plugin_list *plugins;$/;"	m	struct:tls_options	typeref:struct:tls_options::plugin_list
plugins_owned	openvpn.h	/^  bool plugins_owned;           \/**< Whether the plug-ins should be$/;"	m	struct:context
po_append_event	event.c	/^po_append_event (struct po_set *pos, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
po_ctl	event.c	/^po_ctl (struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
po_del	event.c	/^po_del (struct event_set *es, event_t event)$/;"	f	file:
po_free	event.c	/^po_free (struct event_set *es)$/;"	f	file:
po_init	event.c	/^po_init (int *maxevents, unsigned int flags)$/;"	f	file:
po_reset	event.c	/^po_reset (struct event_set *es)$/;"	f	file:
po_set	event.c	/^struct po_set$/;"	s	file:
po_set_pollfd_events	event.c	/^po_set_pollfd_events (struct pollfd *pfdp, unsigned int rwflags)$/;"	f	file:
po_wait	event.c	/^po_wait (struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:
polarssl_name	crypto_polarssl.c	/^typedef struct { const char * openvpn_name; const char * polarssl_name; } cipher_name_pair;$/;"	m	struct:__anon4	file:
pop_perf_index	perf.c	/^pop_perf_index (void)$/;"	f	file:
port	proxy.h	/^  int port;$/;"	m	struct:http_proxy_options
port	proxy.h	/^  int port;$/;"	m	struct:http_proxy_options_simple
port	socks.h	/^  int port;$/;"	m	struct:socks_proxy_info
port_share	ps.c	/^struct port_share *port_share = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:port_share
port_share	ps.h	/^struct port_share {$/;"	s
port_share_abort	ps.c	/^port_share_abort (struct port_share *ps)$/;"	f
port_share_close	ps.c	/^port_share_close (struct port_share *ps)$/;"	f
port_share_host	options.h	/^  char *port_share_host;$/;"	m	struct:options
port_share_journal_dir	options.h	/^  const char *port_share_journal_dir;$/;"	m	struct:options
port_share_open	ps.c	/^port_share_open (const char *host,$/;"	f
port_share_port	options.h	/^  int port_share_port;$/;"	m	struct:options
port_share_proxy	ps.c	/^port_share_proxy (const in_addr_t hostaddr,$/;"	f	file:
port_share_redirect	ps.c	/^port_share_redirect (struct port_share *ps, const struct buffer *head, socket_descriptor_t sd)$/;"	f
port_share_sendmsg	ps.c	/^port_share_sendmsg (const socket_descriptor_t sd,$/;"	f	file:
port_share_state	socket.h	/^  int port_share_state;$/;"	m	struct:stream_buf
pos	base64.c	/^pos(char c)$/;"	f	file:
positive_atoi	options.c	/^positive_atoi (const char *str)$/;"	f	file:
possibly_become_daemon	init.c	/^possibly_become_daemon (const struct options *options, const bool first_time)$/;"	f	file:
post_compress	lzo.h	/^  counter_type post_compress;$/;"	m	struct:lzo_compress_workspace
post_decompress	lzo.h	/^  counter_type post_decompress;$/;"	m	struct:lzo_compress_workspace
post_fork_cleanup_func_t	ps.h	/^typedef void (*post_fork_cleanup_func_t)(void *arg);$/;"	t
post_init_signal_catch	sig.c	/^post_init_signal_catch (void)$/;"	f
post_open_mtu	tun.h	/^  int post_open_mtu;$/;"	m	struct:tuntap
pract	mtcp.c	/^pract (int action)$/;"	f	file:
pre_compress	lzo.h	/^  counter_type pre_compress;$/;"	m	struct:lzo_compress_workspace
pre_decompress	lzo.h	/^  counter_type pre_decompress;$/;"	m	struct:lzo_compress_workspace
pre_init_signal_catch	sig.c	/^pre_init_signal_catch (void)$/;"	f
pre_master	ssl_common.h	/^  uint8_t pre_master[48];       \/**< Random used for master secret$/;"	m	struct:key_source
pre_pull	options.h	/^  struct options_pre_pull *pre_pull;$/;"	m	struct:options	typeref:struct:options::options_pre_pull
pre_pull_restore	options.c	/^pre_pull_restore (struct options *o)$/;"	f
pre_pull_save	options.c	/^pre_pull_save (struct options *o)$/;"	f
pre_select	forward.c	/^pre_select (struct context *c)$/;"	f
pre_setup	init.c	/^pre_setup (const struct options *options)$/;"	f
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
prefix	route.h	/^  const char *prefix;		\/* e.g. "2001:db8:1::\/64" *\/$/;"	m	struct:route_ipv6_option
pri	schedule.h	/^  unsigned int pri;              \/* random treap priority *\/$/;"	m	struct:schedule_entry
print_argv	buffer.c	/^print_argv (const char **p, struct gc_arena *gc, const unsigned int flags)$/;"	f
print_bypass_addresses	route.c	/^print_bypass_addresses (const struct route_bypass *rb)$/;"	f	file:
print_client_nat_list	clinat.c	/^print_client_nat_list(const struct client_nat_option_list *list, int msglevel)$/;"	f
print_default_gateway	route.c	/^print_default_gateway(const int msglevel, const struct route_gateway_info *rgi)$/;"	f
print_details	ssl_openssl.c	/^print_details (struct key_state_ssl * ks_ssl, const char *prefix)$/;"	f
print_details	ssl_polarssl.c	/^print_details (struct key_state_ssl * ks_ssl, const char *prefix)$/;"	f
print_in6_addr	socket.c	/^print_in6_addr (struct in6_addr a6, unsigned int flags, struct gc_arena *gc)$/;"	f
print_in6_addr_netbits_only	route.c	/^print_in6_addr_netbits_only( struct in6_addr network_copy, int netbits, $/;"	f	file:
print_in_addr_t	socket.c	/^print_in_addr_t (in_addr_t addr, unsigned int flags, struct gc_arena *gc)$/;"	f
print_key_id	ssl.c	/^print_key_id (struct tls_multi *multi, struct gc_arena *gc)$/;"	f	file:
print_link_socket_actual	socket.c	/^print_link_socket_actual (const struct link_socket_actual *act, struct gc_arena *gc)$/;"	f
print_link_socket_actual_ex	socket.c	/^print_link_socket_actual_ex (const struct link_socket_actual *act,$/;"	f
print_netmask	helper.c	/^print_netmask (int netbits, struct gc_arena *gc)$/;"	f	file:
print_nhash	list.c	/^print_nhash (struct hash *hash)$/;"	f	file:
print_nsCertType	ssl_verify.c	/^print_nsCertType (int type)$/;"	f	file:
print_openssl_info	init.c	/^print_openssl_info (const struct options *options)$/;"	f
print_opt_route	helper.c	/^print_opt_route (const in_addr_t network, const in_addr_t netmask, struct gc_arena *gc)$/;"	f	file:
print_opt_route_gateway	helper.c	/^print_opt_route_gateway (const in_addr_t route_gateway, struct gc_arena *gc)$/;"	f	file:
print_opt_route_gateway_dhcp	helper.c	/^print_opt_route_gateway_dhcp (struct gc_arena *gc)$/;"	f	file:
print_opt_topology	helper.c	/^print_opt_topology (const int topology, struct gc_arena *gc)$/;"	f	file:
print_pkt	clinat.c	/^print_pkt (struct openvpn_iphdr *iph, const char *prefix, const int direction, const int msglevel)$/;"	f	file:
print_route	route.c	/^print_route (const struct route_ipv4 *r, int level)$/;"	f	file:
print_route_option	route.c	/^print_route_option (const struct route_option *ro, int level)$/;"	f	file:
print_route_options	route.c	/^print_route_options (const struct route_option_list *rol,$/;"	f
print_routes	route.c	/^print_routes (const struct route_list *rl, int level)$/;"	f
print_signal	sig.c	/^print_signal (const struct signal_info *si, const char *title, int msglevel)$/;"	f
print_sockaddr	socket.c	/^print_sockaddr (const struct openvpn_sockaddr *addr, struct gc_arena *gc)$/;"	f
print_sockaddr_ex	socket.c	/^print_sockaddr_ex (const struct openvpn_sockaddr *addr,$/;"	f
print_status	sig.c	/^print_status (const struct context *c, struct status_output *so)$/;"	f
print_status_mode	status.c	/^print_status_mode (unsigned int flags)$/;"	f	file:
print_str	helper.c	/^print_str (const char *str, struct gc_arena *gc)$/;"	f	file:
print_str_int	helper.c	/^print_str_int (const char *str, const int i, struct gc_arena *gc)$/;"	f	file:
print_topology	options.c	/^print_topology (const int topology)$/;"	f
printable_char_fmt	crypto.c	/^static const char printable_char_fmt[] =$/;"	v	file:
priv_key	ssl_polarssl.h	/^    rsa_context *priv_key;	\/**< Local private key *\/$/;"	m	struct:tls_root_ctx
priv_key_file	options.h	/^  const char *priv_key_file;$/;"	m	struct:options
priv_key_file_inline	options.h	/^  char *priv_key_file_inline;$/;"	m	struct:options
priv_key_pkcs11	ssl_polarssl.h	/^    pkcs11_context *priv_key_pkcs11;	\/**< PKCS11 private key *\/$/;"	m	struct:tls_root_ctx
prng_bytes	crypto.c	/^prng_bytes (uint8_t *output, int len)$/;"	f
prng_hash	options.h	/^  const char *prng_hash;$/;"	m	struct:options
prng_init	crypto.c	/^prng_init (const char *md_name, const int nonce_secret_len_parm)$/;"	f
prng_nonce_secret_len	options.h	/^  int prng_nonce_secret_len;$/;"	m	struct:options
prng_reset_nonce	crypto.c	/^prng_reset_nonce ()$/;"	f	file:
prng_uninit	crypto.c	/^prng_uninit (void)$/;"	f
probehdr	mtu.c	/^struct probehdr$/;"	s	file:
process_coarse_timers	forward.c	/^process_coarse_timers (struct context *c)$/;"	f	file:
process_explicit_exit_notification_init	sig.c	/^process_explicit_exit_notification_init (struct context *c)$/;"	f	file:
process_explicit_exit_notification_timer_wakeup	sig.c	/^process_explicit_exit_notification_timer_wakeup (struct context *c)$/;"	f
process_incoming_link	forward.c	/^process_incoming_link (struct context *c)$/;"	f
process_incoming_push_msg	push.c	/^process_incoming_push_msg (struct context *c,$/;"	f
process_incoming_tun	forward.c	/^process_incoming_tun (struct context *c)$/;"	f
process_io	forward.c	/^process_io (struct context *c)$/;"	f
process_ip_header	forward.c	/^process_ip_header (struct context *c, unsigned int flags, struct buffer *buf)$/;"	f
process_outgoing_link	forward.c	/^process_outgoing_link (struct context *c)$/;"	f
process_outgoing_tun	forward.c	/^process_outgoing_tun (struct context *c)$/;"	f
process_received_occ_msg	occ.c	/^process_received_occ_msg (struct context *c)$/;"	f
process_signal	sig.c	/^process_signal (struct context *c)$/;"	f
process_signal_p2p	openvpn.c	/^process_signal_p2p (struct context *c)$/;"	f	file:
process_sigterm	sig.c	/^process_sigterm (struct context *c)$/;"	f	file:
process_sigusr2	sig.c	/^process_sigusr2 (const struct context *c)$/;"	f	file:
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
proto	options.h	/^  int proto;$/;"	m	struct:connection_entry
proto	options.h	/^  int proto;$/;"	m	struct:remote_entry
proto	proto.h	/^  uint16_t proto;                     \/* packet type ID field *\/$/;"	m	struct:openvpn_ethhdr
proto	socket.h	/^  int proto;                    \/* Protocol (PROTO_x defined below) *\/$/;"	m	struct:link_socket_info
proto2ascii	socket.c	/^proto2ascii (int proto, bool display_form)$/;"	f
proto2ascii_all	socket.c	/^proto2ascii_all (struct gc_arena *gc)$/;"	f
proto_addr_size	proto.h	/^  uint8_t  proto_addr_size;     \/* 0x04 *\/$/;"	m	struct:openvpn_arp
proto_addr_type	proto.h	/^  uint16_t proto_addr_type;     \/* 0x0800 *\/$/;"	m	struct:openvpn_arp
proto_af	socket.c	/^  unsigned short proto_af;$/;"	m	struct:proto_names	file:
proto_force	options.h	/^  int proto_force;$/;"	m	struct:options
proto_is_dgram	socket.c	/^proto_is_dgram(int proto)$/;"	f
proto_is_net	socket.c	/^proto_is_net(int proto)$/;"	f
proto_is_tcp	socket.c	/^proto_is_tcp(int proto)$/;"	f
proto_is_udp	socket.c	/^proto_is_udp(int proto)$/;"	f
proto_names	socket.c	/^static const struct proto_names proto_names[PROTO_N] = {$/;"	v	typeref:struct:proto_names	file:
proto_names	socket.c	/^struct proto_names {$/;"	s	file:
proto_num	socket.h	/^enum proto_num {$/;"	g
proto_overhead	socket.c	/^const int proto_overhead[] = { \/* indexed by PROTO_x *\/$/;"	v
proto_remote	socket.c	/^proto_remote (int proto, bool remote)$/;"	f
proto_sa_family	socket.c	/^proto_sa_family(int proto)$/;"	f
protocol	proto.h	/^  uint8_t    protocol;$/;"	m	struct:openvpn_iphdr
protocol_dump	ssl.c	/^protocol_dump (struct buffer *buffer, unsigned int flags, struct gc_arena *gc)$/;"	f
proxy_authenticate	proxy.h	/^  char *proxy_authenticate;$/;"	m	struct:http_proxy_info
proxy_cmd	manage.h	/^  bool (*proxy_cmd) (void *arg, const char **p);$/;"	m	struct:management_callback
proxy_connection	ps.c	/^struct proxy_connection {$/;"	s	file:
proxy_connection_io_dispatch	ps.c	/^proxy_connection_io_dispatch (struct proxy_connection *pc,$/;"	f	file:
proxy_connection_io_recv	ps.c	/^proxy_connection_io_recv (struct proxy_connection *pc)$/;"	f	file:
proxy_connection_io_requeue	ps.c	/^proxy_connection_io_requeue (struct proxy_connection *pc, const int rwflags_new, struct event_set *es)$/;"	f	file:
proxy_connection_io_send	ps.c	/^proxy_connection_io_send (struct proxy_connection *pc, int *bytes_sent)$/;"	f	file:
proxy_connection_io_status	ps.c	/^proxy_connection_io_status (const int status, int *rwflags_pc, int *rwflags_cp)$/;"	f	file:
proxy_connection_io_xfer	ps.c	/^proxy_connection_io_xfer (struct proxy_connection *pc, const int max_transfer)$/;"	f	file:
proxy_dest_host	socket.h	/^  const char *proxy_dest_host;$/;"	m	struct:link_socket
proxy_dest_port	socket.h	/^  int proxy_dest_port;$/;"	m	struct:link_socket
proxy_entry_close_sd	ps.c	/^proxy_entry_close_sd (struct proxy_connection *pc, struct event_set *es)$/;"	f	file:
proxy_entry_mark_for_close	ps.c	/^proxy_entry_mark_for_close (struct proxy_connection *pc, struct event_set *es)$/;"	f	file:
proxy_entry_new	ps.c	/^proxy_entry_new (struct proxy_connection **list,$/;"	f	file:
proxy_list_close	ps.c	/^proxy_list_close (struct proxy_connection **list)$/;"	f	file:
proxy_list_housekeeping	ps.c	/^proxy_list_housekeeping (struct proxy_connection **list)$/;"	f	file:
proxy_scope	init.c	/^proxy_scope (struct context *c)$/;"	f	file:
psdir	Makefile	/^psdir = ${docdir}$/;"	m
ptos	socket.h	/^  int  ptos;$/;"	m	struct:link_socket
ptos	socket.h	/^  uint8_t ptos;$/;"	m	struct:link_socket
ptos_defined	socket.h	/^  bool ptos_defined;$/;"	m	struct:link_socket
ptr_format	common.h	57;"	d
ptr_format	common.h	59;"	d
ptr_type	common.h	/^typedef unsigned long long ptr_type;$/;"	t
ptr_type	common.h	/^typedef unsigned long ptr_type;$/;"	t
pull	options.h	/^  bool pull; \/* client pull of config options from server *\/$/;"	m	struct:options
pull_permission_mask	init.c	/^pull_permission_mask (const struct context *c)$/;"	f
pulled_options_digest	openvpn.h	/^  struct md5_digest pulled_options_digest;$/;"	m	struct:context_2	typeref:struct:context_2::md5_digest
pulled_options_digest_save	openvpn.h	/^  struct md5_digest pulled_options_digest_save;$/;"	m	struct:context_1	typeref:struct:context_1::md5_digest
pulled_options_md5_init_done	openvpn.h	/^  bool pulled_options_md5_init_done;$/;"	m	struct:context_2
pulled_options_state	openvpn.h	/^  struct md5_state pulled_options_state;$/;"	m	struct:context_2	typeref:struct:context_2::md5_state
purge_user_pass	misc.c	/^purge_user_pass (struct user_pass *up, const bool force)$/;"	f
push_continuation	options.h	/^  int push_continuation;$/;"	m	struct:options
push_entry	pushlist.h	/^struct push_entry {$/;"	s
push_ifconfig_constraint_defined	options.h	/^  bool push_ifconfig_constraint_defined;$/;"	m	struct:options
push_ifconfig_constraint_netmask	options.h	/^  in_addr_t push_ifconfig_constraint_netmask;$/;"	m	struct:options
push_ifconfig_constraint_network	options.h	/^  in_addr_t push_ifconfig_constraint_network;$/;"	m	struct:options
push_ifconfig_defined	openvpn.h	/^  bool push_ifconfig_defined;$/;"	m	struct:context_2
push_ifconfig_defined	options.h	/^  bool push_ifconfig_defined;$/;"	m	struct:options
push_ifconfig_ipv6_defined	openvpn.h	/^  bool            push_ifconfig_ipv6_defined;$/;"	m	struct:context_2
push_ifconfig_ipv6_defined	options.h	/^  bool            push_ifconfig_ipv6_defined;		\/* IPv6 *\/$/;"	m	struct:options
push_ifconfig_ipv6_local	openvpn.h	/^  struct in6_addr push_ifconfig_ipv6_local;$/;"	m	struct:context_2	typeref:struct:context_2::in6_addr
push_ifconfig_ipv6_local	options.h	/^  struct in6_addr push_ifconfig_ipv6_local;		\/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr
push_ifconfig_ipv6_netbits	openvpn.h	/^  int             push_ifconfig_ipv6_netbits;$/;"	m	struct:context_2
push_ifconfig_ipv6_netbits	options.h	/^  int 		  push_ifconfig_ipv6_netbits;		\/* IPv6 *\/$/;"	m	struct:options
push_ifconfig_ipv6_remote	openvpn.h	/^  struct in6_addr push_ifconfig_ipv6_remote;$/;"	m	struct:context_2	typeref:struct:context_2::in6_addr
push_ifconfig_ipv6_remote	options.h	/^  struct in6_addr push_ifconfig_ipv6_remote;		\/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr
push_ifconfig_local	openvpn.h	/^  in_addr_t push_ifconfig_local;$/;"	m	struct:context_2
push_ifconfig_local	options.h	/^  in_addr_t push_ifconfig_local;$/;"	m	struct:options
push_ifconfig_local_alias	openvpn.h	/^  in_addr_t push_ifconfig_local_alias;$/;"	m	struct:context_2
push_ifconfig_local_alias	options.h	/^  in_addr_t push_ifconfig_local_alias;$/;"	m	struct:options
push_ifconfig_remote_netmask	openvpn.h	/^  in_addr_t push_ifconfig_remote_netmask;$/;"	m	struct:context_2
push_ifconfig_remote_netmask	options.h	/^  in_addr_t push_ifconfig_remote_netmask;$/;"	m	struct:options
push_list	options.h	/^  struct push_list push_list;$/;"	m	struct:options	typeref:struct:options::push_list
push_list	pushlist.h	/^struct push_list {$/;"	s
push_option	push.c	/^push_option (struct options *o, const char *opt, int msglevel)$/;"	f
push_option_ex	push.c	/^push_option_ex (struct options *o, const char *opt, bool enable, int msglevel)$/;"	f	file:
push_option_types_found	options.h	/^  unsigned int push_option_types_found;$/;"	m	struct:options
push_options	push.c	/^push_options (struct options *o, char **p, int msglevel, struct gc_arena *gc)$/;"	f
push_peer_info	options.h	/^  bool push_peer_info;$/;"	m	struct:options
push_peer_info	ssl.c	/^push_peer_info(struct buffer *buf, struct tls_session *session)$/;"	f	file:
push_peer_info_detail	ssl_common.h	/^  int push_peer_info_detail;$/;"	m	struct:tls_options
push_perf_index	perf.c	/^push_perf_index (int pindex)$/;"	f	file:
push_reply_deferred	openvpn.h	/^  bool push_reply_deferred;$/;"	m	struct:context_2
push_request_interval	openvpn.h	/^  struct event_timeout push_request_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
push_reset	push.c	/^push_reset (struct options *o)$/;"	f
pw	platform.h	/^  struct passwd *pw;$/;"	m	struct:platform_state_user	typeref:struct:platform_state_user::passwd
queried_creds	proxy.h	/^  bool queried_creds;$/;"	m	struct:http_proxy_info
rand_bytes	crypto_openssl.c	/^int rand_bytes(uint8_t *output, int len)$/;"	f
rand_bytes	crypto_polarssl.c	/^rand_bytes (uint8_t *output, int len)$/;"	f
rand_ctx_enable_prediction_resistance	crypto_polarssl.c	/^void rand_ctx_enable_prediction_resistance()$/;"	f
rand_ctx_get	crypto_polarssl.c	/^ctr_drbg_context * rand_ctx_get()$/;"	f
random	syshead.h	44;"	d
random1	ssl_common.h	/^  uint8_t random1[32];          \/**< Seed used for master secret$/;"	m	struct:key_source
random2	ssl_common.h	/^  uint8_t random2[32];          \/**< Seed used for key expansion, provided$/;"	m	struct:key_source
random_bytes_to_buf	ssl.c	/^random_bytes_to_buf (struct buffer *buf,$/;"	f	file:
rcvbuf	options.h	/^  int rcvbuf;$/;"	m	struct:options
rcvbuf	socket.h	/^  int rcvbuf;$/;"	m	struct:socket_buffer_size
read	win32.h	/^  HANDLE read;$/;"	m	struct:rw_handle
read_buf	status.h	/^  struct buffer read_buf;$/;"	m	struct:status_output	typeref:struct:status_output::buffer
read_config_file	options.c	/^read_config_file (struct options *options,$/;"	f	file:
read_config_string	options.c	/^read_config_string (const char *prefix,$/;"	f	file:
read_control_auth	ssl.c	/^read_control_auth (struct buffer *buf,$/;"	f	file:
read_incoming_link	forward.c	/^read_incoming_link (struct context *c)$/;"	f
read_incoming_tun	forward.c	/^read_incoming_tun (struct context *c)$/;"	f
read_inline_file	options.c	/^read_inline_file (struct in_src *is, const char *close_tag, struct gc_arena *gc)$/;"	f	file:
read_key	crypto.c	/^read_key (struct key *key, const struct key_type *kt, struct buffer *buf)$/;"	f
read_key_file	crypto.c	/^read_key_file (struct key2 *key2, const char *file, const unsigned int flags)$/;"	f
read_link_buf	openvpn.h	/^  struct buffer read_link_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
read_passphrase_hash	crypto.c	/^read_passphrase_hash (const char *passphrase_file,$/;"	f
read_string	ssl.c	/^read_string (struct buffer *buf, char *str, const unsigned int capacity)$/;"	f	file:
read_string_alloc	ssl.c	/^read_string_alloc (struct buffer *buf)$/;"	f	file:
read_string_discard	ssl.c	/^read_string_discard (struct buffer *buf)$/;"	f
read_tun	tun.c	/^read_tun (struct tuntap *tt, uint8_t *buf, int len)$/;"	f
read_tun	tun.c	/^read_tun (struct tuntap* tt, uint8_t *buf, int len)$/;"	f
read_tun_buf	openvpn.h	/^  struct buffer read_tun_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer
read_tun_buffered	tun.h	/^read_tun_buffered (struct tuntap *tt, struct buffer *buf, int maxsize)$/;"	f
read_tun_header	tun.c	/^read_tun_header (struct tuntap* tt, uint8_t *buf, int len)$/;"	f
readfds	event.c	/^  fd_set readfds;$/;"	m	struct:se_set	file:
reads	socket.h	/^  struct overlapped_io reads;$/;"	m	struct:link_socket	typeref:struct:link_socket::overlapped_io
reads	tun.h	/^  struct overlapped_io reads;$/;"	m	struct:tuntap	typeref:struct:tuntap::overlapped_io
real	multi.h	/^  struct mroute_addr real;      \/**< External network address of the$/;"	m	struct:multi_instance	typeref:struct:multi_instance::mroute_addr
real_hash_size	options.h	/^  int real_hash_size;$/;"	m	struct:options
reap_buckets_per_pass	multi.c	/^reap_buckets_per_pass (int n_buckets)$/;"	f	file:
reaper	multi.h	/^  struct multi_reap *reaper;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_reap
rec	packet_id.h	/^  struct packet_id_rec rec;$/;"	m	struct:packet_id	typeref:struct:packet_id::packet_id_rec
rec_ack	ssl_common.h	/^  struct reliable_ack *rec_ack;	  \/* buffers all packet IDs we want to ACK back to sender *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable_ack
rec_reliable	ssl_common.h	/^  struct reliable *rec_reliable;  \/* order incoming ciphertext packets before we pass to TLS *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable
receive_auth_failed	push.c	/^receive_auth_failed (struct context *c, const struct buffer *buffer)$/;"	f
received_os_mtu_hint	fragment.h	/^  bool received_os_mtu_hint;    \/**< Whether the operating system has$/;"	m	struct:fragment_master
recv_control	ps.c	/^recv_control (const socket_descriptor_t fd)$/;"	f	file:
recv_line	proxy.c	/^recv_line (socket_descriptor_t sd,$/;"	f	file:
recv_socks_reply	socks.c	/^recv_socks_reply (socket_descriptor_t sd,$/;"	f	file:
redirect_default_route_to_vpn	route.c	/^redirect_default_route_to_vpn (struct route_list *rl, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	file:
redirect_stdout_stderr	error.c	/^redirect_stdout_stderr (const char *file, bool append)$/;"	f
refcount	mbuf.h	/^  int refcount;$/;"	m	struct:mbuf_buffer
refcount	multi.h	/^  int refcount;$/;"	m	struct:multi_instance
refresh	interval.h	/^  interval_t refresh;$/;"	m	struct:interval
register_activity	forward-inline.h	/^register_activity (struct context *c, const int size)$/;"	f
register_dns	tun.h	/^  bool register_dns;$/;"	m	struct:tuntap_options
register_signal	sig.c	/^register_signal (struct context *c, int sig, const char *text)$/;"	f
reliable	reliable.h	/^struct reliable$/;"	s
reliable_ack	reliable.h	/^struct reliable_ack$/;"	s
reliable_ack_acknowledge_packet_id	reliable.c	/^reliable_ack_acknowledge_packet_id (struct reliable_ack *ack, packet_id_type pid)$/;"	f
reliable_ack_adjust_frame_parameters	reliable.c	/^reliable_ack_adjust_frame_parameters (struct frame* frame, int max)$/;"	f
reliable_ack_empty	reliable.h	/^reliable_ack_empty (struct reliable_ack *ack)$/;"	f
reliable_ack_packet_id_present	reliable.c	/^reliable_ack_packet_id_present (struct reliable_ack *ack, packet_id_type pid)$/;"	f	file:
reliable_ack_print	reliable.c	/^reliable_ack_print (struct buffer *buf, bool verbose, struct gc_arena *gc)$/;"	f
reliable_ack_read	reliable.c	/^reliable_ack_read (struct reliable_ack * ack,$/;"	f
reliable_ack_read_packet_id	reliable.c	/^reliable_ack_read_packet_id (struct buffer *buf, packet_id_type *pid)$/;"	f
reliable_ack_write	reliable.c	/^reliable_ack_write (struct reliable_ack * ack,$/;"	f
reliable_can_get	reliable.c	/^reliable_can_get (const struct reliable *rel)$/;"	f
reliable_can_send	reliable.c	/^reliable_can_send (const struct reliable *rel)$/;"	f
reliable_empty	reliable.c	/^reliable_empty (const struct reliable *rel)$/;"	f
reliable_entry	reliable.h	/^struct reliable_entry$/;"	s
reliable_free	reliable.c	/^reliable_free (struct reliable *rel)$/;"	f
reliable_get_buf	reliable.c	/^reliable_get_buf (struct reliable *rel)$/;"	f
reliable_get_buf_output_sequenced	reliable.c	/^reliable_get_buf_output_sequenced (struct reliable *rel)$/;"	f
reliable_get_buf_sequenced	reliable.c	/^reliable_get_buf_sequenced (struct reliable *rel)$/;"	f
reliable_init	reliable.c	/^reliable_init (struct reliable *rel, int buf_size, int offset, int array_size, bool hold)$/;"	f
reliable_mark_active_incoming	reliable.c	/^reliable_mark_active_incoming (struct reliable *rel, struct buffer *buf,$/;"	f
reliable_mark_active_outgoing	reliable.c	/^reliable_mark_active_outgoing (struct reliable *rel, struct buffer *buf, int opcode)$/;"	f
reliable_mark_deleted	reliable.c	/^reliable_mark_deleted (struct reliable *rel, struct buffer *buf, bool inc_pid)$/;"	f
reliable_not_replay	reliable.c	/^reliable_not_replay (const struct reliable *rel, packet_id_type id)$/;"	f
reliable_pid_in_range1	reliable.c	/^reliable_pid_in_range1 (const packet_id_type test,$/;"	f	file:
reliable_pid_in_range2	reliable.c	/^reliable_pid_in_range2 (const packet_id_type test,$/;"	f	file:
reliable_pid_min	reliable.c	/^reliable_pid_min (const packet_id_type p1,$/;"	f	file:
reliable_print_ids	reliable.c	/^reliable_print_ids (const struct reliable *rel, struct gc_arena *gc)$/;"	f	file:
reliable_schedule_now	reliable.c	/^reliable_schedule_now (struct reliable *rel)$/;"	f
reliable_send	reliable.c	/^reliable_send (struct reliable *rel, int *opcode)$/;"	f
reliable_send_purge	reliable.c	/^reliable_send_purge (struct reliable *rel, struct reliable_ack *ack)$/;"	f
reliable_send_timeout	reliable.c	/^reliable_send_timeout (const struct reliable *rel)$/;"	f
reliable_set_timeout	reliable.h	/^reliable_set_timeout (struct reliable *rel, interval_t timeout)$/;"	f
reliable_unique_retry	reliable.c	/^reliable_unique_retry (struct reliable *rel, time_t retry)$/;"	f	file:
reliable_wont_break_sequentiality	reliable.c	/^reliable_wont_break_sequentiality (const struct reliable *rel, packet_id_type id)$/;"	f
reload	pf.h	/^  struct event_timeout reload;$/;"	m	struct:pf_context	typeref:struct:pf_context::event_timeout
remap_signal	sig.c	/^remap_signal (struct context *c)$/;"	f
remap_sigusr1	options.h	/^  int remap_sigusr1;$/;"	m	struct:options
remote	manage.h	/^  struct openvpn_sockaddr remote;$/;"	m	struct:man_connection	typeref:struct:man_connection::openvpn_sockaddr
remote	options.h	/^  const char *remote;$/;"	m	struct:connection_entry
remote	options.h	/^  const char *remote;$/;"	m	struct:remote_entry
remote	socket.h	/^  struct openvpn_sockaddr remote;   \/* initial remote *\/$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::openvpn_sockaddr
remote_addr	ssl_common.h	/^  struct link_socket_actual remote_addr; \/* peer's IP addr *\/$/;"	m	struct:key_state	typeref:struct:key_state::link_socket_actual
remote_cert_eku	options.h	/^  const char *remote_cert_eku;$/;"	m	struct:options
remote_cert_eku	ssl_common.h	/^  const char *remote_cert_eku;$/;"	m	struct:tls_options
remote_cert_ku	options.h	/^  unsigned remote_cert_ku[MAX_PARMS];$/;"	m	struct:options
remote_cert_ku	ssl_common.h	/^  unsigned remote_cert_ku[MAX_PARMS];$/;"	m	struct:tls_options
remote_cmd	manage.h	/^  bool (*remote_cmd) (void *arg, const char **p);$/;"	m	struct:management_callback
remote_endpoint	route.h	/^  in_addr_t remote_endpoint;$/;"	m	struct:route_special_addr
remote_endpoint_defined	route.h	/^  bool remote_endpoint_defined;$/;"	m	struct:route_ipv6_list
remote_endpoint_ipv6	route.h	/^  struct in6_addr remote_endpoint_ipv6;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::in6_addr
remote_entry	options.h	/^struct remote_entry$/;"	s
remote_float	options.h	/^  bool remote_float;$/;"	m	struct:connection_entry
remote_float	socket.h	/^  bool remote_float;  $/;"	m	struct:link_socket_info
remote_host	route.h	/^  in_addr_t remote_host;$/;"	m	struct:route_special_addr
remote_host	socket.h	/^  const char *remote_host;$/;"	m	struct:link_socket
remote_host_local	route.h	/^  int remote_host_local;  \/* TLA_x value *\/$/;"	m	struct:route_special_addr
remote_host_store	options.h	/^struct remote_host_store$/;"	s
remote_ip	manage.h	/^  in_addr_t remote_ip;$/;"	m	struct:log_entry
remote_ip_hint	options.h	/^  char *remote_ip_hint;$/;"	m	struct:options
remote_ipv6	tun.h	/^  struct in6_addr remote_ipv6;$/;"	m	struct:tuntap	typeref:struct:tuntap::in6_addr
remote_list	options.h	/^  struct remote_list *remote_list;$/;"	m	struct:options	typeref:struct:options::remote_list
remote_list	options.h	/^struct remote_list$/;"	s
remote_netmask	tun.h	/^  in_addr_t remote_netmask;$/;"	m	struct:tuntap
remote_options	ssl_common.h	/^  const char *remote_options;$/;"	m	struct:tls_options
remote_port	options.h	/^  int remote_port;$/;"	m	struct:connection_entry
remote_port	options.h	/^  int remote_port;$/;"	m	struct:remote_entry
remote_port	socket.h	/^  int remote_port;$/;"	m	struct:link_socket
remote_random	options.h	/^  bool remote_random;$/;"	m	struct:options
remove_env_item	misc.c	/^remove_env_item (const char *str, const bool do_free, struct env_item **list)$/;"	f	file:
remove_iroutes_from_push_route_list	push.c	/^remove_iroutes_from_push_route_list (struct options *o)$/;"	f
renegotiate_bytes	options.h	/^  int renegotiate_bytes;$/;"	m	struct:options
renegotiate_bytes	ssl_common.h	/^  int renegotiate_bytes;$/;"	m	struct:tls_options
renegotiate_packets	options.h	/^  int renegotiate_packets;$/;"	m	struct:options
renegotiate_packets	ssl_common.h	/^  int renegotiate_packets;$/;"	m	struct:tls_options
renegotiate_seconds	options.h	/^  int renegotiate_seconds;$/;"	m	struct:options
renegotiate_seconds	ssl_common.h	/^  interval_t renegotiate_seconds;$/;"	m	struct:tls_options
replay	options.h	/^  bool replay;$/;"	m	struct:options
replay	ssl_common.h	/^  bool replay;$/;"	m	struct:tls_options
replay_time	options.h	/^  int replay_time;$/;"	m	struct:options
replay_time	ssl_common.h	/^  int replay_time;                     \/* --replay-window parm *\/$/;"	m	struct:tls_options
replay_window	options.h	/^  int replay_window;$/;"	m	struct:options
replay_window	ssl_common.h	/^  int replay_window;                   \/* --replay-window parm *\/$/;"	m	struct:tls_options
reporting_addr	multi.h	/^  in_addr_t reporting_addr;       \/* IP address shown in status listing *\/$/;"	m	struct:multi_instance
requested_initialization_point	plugin.h	/^  int requested_initialization_point;$/;"	m	struct:plugin
reset	event.h	/^  void (*reset)(struct event_set *es);$/;"	m	struct:event_set_functions
reset	otime.h	/^  time_t reset;$/;"	m	struct:frequency_limit
reset_check_status	error.c	/^reset_check_status ()$/;"	f
reset_coarse_timers	init.c	/^reset_coarse_timers (struct context *c)$/;"	f
reset_net_event_win32	win32.c	/^reset_net_event_win32 (struct rw_handle *event, socket_descriptor_t sd)$/;"	f
reset_session	ssl.c	/^reset_session (struct tls_multi *multi, struct tls_session *session)$/;"	f	file:
residual	manage.h	/^  struct buffer residual;$/;"	m	struct:command_line	typeref:struct:command_line::buffer
residual	socket.h	/^  struct buffer residual;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer
residual_fully_formed	socket.h	/^  bool residual_fully_formed;$/;"	m	struct:stream_buf
resolve_bind_local	socket.c	/^resolve_bind_local (struct link_socket *sock)$/;"	f	file:
resolve_remote	socket.c	/^resolve_remote (struct link_socket *sock,$/;"	f	file:
resolve_retry_seconds	options.h	/^  int resolve_retry_seconds;    \/* If hostname resolve fails, retry for n seconds *\/$/;"	m	struct:options
resolve_retry_seconds	socket.h	/^  int resolve_retry_seconds;$/;"	m	struct:link_socket
restart_sleep_seconds	openvpn.h	/^  int restart_sleep_seconds;$/;"	m	struct:context_persist
restore_signal_state	sig.c	/^restore_signal_state (void)$/;"	f
result_t	ssl_verify_backend.h	/^typedef enum { SUCCESS=0, FAILURE=1 } result_t;$/;"	t	typeref:enum:__anon5
ret	mtcp.c	/^  unsigned int ret;$/;"	m	struct:ta_iow_flags	file:
retry	proxy.h	/^  bool retry;$/;"	m	struct:http_proxy_options
retry	socks.h	/^  bool retry;$/;"	m	struct:socks_proxy_info
rgi	route.h	/^  struct route_gateway_info rgi;$/;"	m	struct:route_list	typeref:struct:route_list::route_gateway_info
rh_store	options.h	/^  struct remote_host_store *rh_store;$/;"	m	struct:options	typeref:struct:options::remote_host_store
rm_trailing_chars	buffer.c	/^rm_trailing_chars (char *str, const char *what_to_delete)$/;"	f
rmhash	list.c	/^rmhash (struct hash *hash, const char *word)$/;"	f	file:
rol6_check_alloc	options.c	/^rol6_check_alloc (struct options *options)$/;"	f
rol_check_alloc	options.c	/^rol_check_alloc (struct options *options)$/;"	f
roll	gremlin.c	/^static int roll(int low, int high) {$/;"	f	file:
root	schedule.h	/^  struct schedule_entry *root;            \/* the root of the treap (btree) *\/$/;"	m	struct:schedule	typeref:struct:schedule::schedule_entry
route_bypass	route.h	/^struct route_bypass$/;"	s
route_count	multi.h	/^  int route_count;             \/* number of routes (including cached routes) owned by this instance *\/$/;"	m	struct:multi_instance
route_default_gateway	options.h	/^  const char *route_default_gateway;$/;"	m	struct:options
route_default_metric	options.h	/^  int route_default_metric;$/;"	m	struct:options
route_delay	options.h	/^  int route_delay;$/;"	m	struct:options
route_delay_defined	options.h	/^  bool route_delay_defined;$/;"	m	struct:options
route_delay_window	options.h	/^  int route_delay_window;$/;"	m	struct:options
route_did_redirect_default_gateway	route.h	/^route_did_redirect_default_gateway(const struct route_list *rl)$/;"	f
route_gateway_address	route.h	/^struct route_gateway_address {$/;"	s
route_gateway_info	route.h	/^struct route_gateway_info {$/;"	s
route_gateway_via_dhcp	options.h	/^  bool route_gateway_via_dhcp;$/;"	m	struct:options
route_helper	multi.h	/^  struct mroute_helper *route_helper;$/;"	m	struct:multi_context	typeref:struct:multi_context::mroute_helper
route_ipv4	route.h	/^struct route_ipv4 {$/;"	s
route_ipv6	route.h	/^struct route_ipv6 {$/;"	s
route_ipv6_list	openvpn.h	/^  struct route_ipv6_list *route_ipv6_list;$/;"	m	struct:context_1	typeref:struct:context_1::route_ipv6_list
route_ipv6_list	route.h	/^struct route_ipv6_list {$/;"	s
route_ipv6_option	route.h	/^struct route_ipv6_option {$/;"	s
route_ipv6_option_list	route.h	/^struct route_ipv6_option_list {$/;"	s
route_list	openvpn.h	/^  struct route_list *route_list;$/;"	m	struct:context_1	typeref:struct:context_1::route_list
route_list	route.h	/^struct route_list {$/;"	s
route_list_add_vpn_gateway	route.c	/^route_list_add_vpn_gateway (struct route_list *rl,$/;"	f
route_list_vpn_gateway_needed	route.h	/^route_list_vpn_gateway_needed (const struct route_list *rl)$/;"	f
route_method	options.h	/^  int route_method;$/;"	m	struct:options
route_noexec	options.h	/^  bool route_noexec;$/;"	m	struct:options
route_nopull	options.h	/^  bool route_nopull;$/;"	m	struct:options
route_option	route.h	/^struct route_option {$/;"	s
route_option_list	route.h	/^struct route_option_list {$/;"	s
route_predown_script	options.h	/^  const char *route_predown_script;$/;"	m	struct:options
route_quota_dec	multi.h	/^route_quota_dec (struct multi_instance *mi)$/;"	f
route_quota_exceeded	multi.c	/^route_quota_exceeded (const struct multi_context *m, const struct multi_instance *mi)$/;"	f
route_quota_inc	multi.h	/^route_quota_inc (struct multi_instance *mi)$/;"	f
route_quota_test	multi.h	/^route_quota_test (const struct multi_context *m, const struct multi_instance *mi)$/;"	f
route_script	options.h	/^  const char *route_script;$/;"	m	struct:options
route_special_addr	route.h	/^struct route_special_addr$/;"	s
route_string	route.c	/^route_string (const struct route_ipv4 *r, struct gc_arena *gc)$/;"	f	file:
route_wakeup	openvpn.h	/^  struct event_timeout route_wakeup;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
route_wakeup_expire	openvpn.h	/^  struct event_timeout route_wakeup_expire;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
routes	options.h	/^  struct route_option_list *routes;$/;"	m	struct:options	typeref:struct:options::route_option_list
routes	options.h	/^  struct route_option_list *routes;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::route_option_list
routes	route.h	/^  struct route_ipv4 routes[EMPTY_ARRAY_SIZE];$/;"	m	struct:route_list	typeref:struct:route_list::route_ipv4
routes	route.h	/^  struct route_option routes[EMPTY_ARRAY_SIZE];$/;"	m	struct:route_option_list	typeref:struct:route_option_list::route_option
routes_added	route.h	/^  bool routes_added;$/;"	m	struct:route_ipv6_list
routes_defined	options.h	/^  bool routes_defined;$/;"	m	struct:options_pre_pull
routes_ipv6	options.h	/^  struct route_ipv6_option_list *routes_ipv6;			\/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::route_ipv6_option_list
routes_ipv6	options.h	/^  struct route_ipv6_option_list *routes_ipv6;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::route_ipv6_option_list
routes_ipv6	route.h	/^  struct route_ipv6 routes_ipv6[EMPTY_ARRAY_SIZE];$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::route_ipv6
routes_ipv6	route.h	/^  struct route_ipv6_option routes_ipv6[EMPTY_ARRAY_SIZE];$/;"	m	struct:route_ipv6_option_list	typeref:struct:route_ipv6_option_list::route_ipv6_option
routes_ipv6_defined	options.h	/^  bool routes_ipv6_defined;$/;"	m	struct:options_pre_pull
rsa_finish	ssl_openssl.c	/^rsa_finish(RSA *rsa)$/;"	f	file:
rsa_priv_dec	cryptoapi.c	/^static int rsa_priv_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_priv_dec	ssl_openssl.c	/^rsa_priv_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_priv_enc	cryptoapi.c	/^static int rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_priv_enc	ssl_openssl.c	/^rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_pub_dec	cryptoapi.c	/^static int rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_pub_dec	ssl_openssl.c	/^rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_pub_enc	cryptoapi.c	/^static int rsa_pub_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_pub_enc	ssl_openssl.c	/^rsa_pub_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:
rsa_sig	manage.h	/^  struct buffer_list *rsa_sig;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list
rtm	route.c	2636;"	d	file:
rtm	route.c	2749;"	d	file:
rtm	route.c	2957;"	d	file:
rtmsg	route.c	/^struct rtmsg {$/;"	s	file:
rule	pf.h	/^  struct ipv4_subnet rule;$/;"	m	struct:pf_subnet	typeref:struct:pf_subnet::ipv4_subnet
rule	pf.h	/^  struct pf_cn rule;$/;"	m	struct:pf_cn_elem	typeref:struct:pf_cn_elem::pf_cn
run_up_down	misc.c	/^run_up_down (const char *command,$/;"	f
rw_handle	socket.h	/^  struct rw_handle rw_handle;$/;"	m	struct:link_socket	typeref:struct:link_socket::rw_handle
rw_handle	tun.h	/^  struct rw_handle rw_handle;$/;"	m	struct:tuntap	typeref:struct:tuntap::rw_handle
rw_handle	win32.h	/^struct rw_handle {$/;"	s
rwflags	event.h	/^  unsigned int rwflags;$/;"	m	struct:event_set_return
rwflags	ps.c	/^  int rwflags;$/;"	m	struct:proxy_connection	file:
rwflags_debug	socket.h	/^  unsigned int rwflags_debug;$/;"	m	struct:link_socket
rwflags_debug	tun.h	/^  unsigned int rwflags_debug;$/;"	m	struct:tuntap
s_pkcs11h_sys_engine	pkcs11.c	/^static pkcs11h_engine_system_t s_pkcs11h_sys_engine = {$/;"	v	file:
sa	socket.h	/^    struct sockaddr sa;$/;"	m	union:openvpn_sockaddr::__anon8	typeref:struct:openvpn_sockaddr::__anon8::sockaddr
sa	win32.h	/^  SECURITY_ATTRIBUTES sa;$/;"	m	struct:security_attributes
saddr	proto.h	/^        struct  in6_addr        saddr;$/;"	m	struct:openvpn_ipv6hdr	typeref:struct:openvpn_ipv6hdr::in6_addr
saddr	proto.h	/^  uint32_t   saddr;$/;"	m	struct:openvpn_iphdr
safe_print	misc.c	/^safe_print (const char *str, struct gc_arena *gc)$/;"	f
sampledir	Makefile	/^sampledir = $(docdir)\/sample$/;"	m
sanitize_control_message	misc.c	/^sanitize_control_message(const char *src, struct gc_arena *gc)$/;"	f
save_inetd_socket_descriptor	misc.c	/^save_inetd_socket_descriptor (void)$/;"	f
save_ks	ssl_common.h	/^  struct key_state *save_ks;	\/* temporary pointer used between pre\/post routines *\/$/;"	m	struct:tls_multi	typeref:struct:tls_multi::key_state
save_pulled_options_digest	init.c	/^save_pulled_options_digest (struct context *c, const struct md5_digest *newdigest)$/;"	f	file:
saved	win32.h	/^  bool saved;$/;"	m	struct:window_title
sbin_PROGRAMS	Makefile	/^sbin_PROGRAMS = openvpn$(EXEEXT)$/;"	m
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sc_info	options.h	/^  struct static_challenge_info sc_info;$/;"	m	struct:options	typeref:struct:options::static_challenge_info
schedule	multi.h	/^  struct schedule *schedule;$/;"	m	struct:multi_context	typeref:struct:multi_context::schedule
schedule	schedule.h	/^struct schedule$/;"	s
schedule_add_entry	schedule.h	/^schedule_add_entry (struct schedule *s,$/;"	f
schedule_add_modify	schedule.c	/^schedule_add_modify (struct schedule *s, struct schedule_entry *e)$/;"	f
schedule_debug	schedule.c	/^schedule_debug (struct schedule *s, int *count, struct timeval *least)$/;"	f
schedule_debug_entry	schedule.c	/^schedule_debug_entry (const struct schedule_entry* e,$/;"	f
schedule_detach_parent	schedule.c	/^schedule_detach_parent (struct schedule *s, struct schedule_entry *e)$/;"	f	file:
schedule_entry	schedule.h	/^struct schedule_entry$/;"	s
schedule_entry_compare	schedule.c	/^schedule_entry_compare (const struct schedule_entry *e1,$/;"	f	file:
schedule_entry_debug_info	schedule.c	/^schedule_entry_debug_info (const char *caller, const struct schedule_entry *e)$/;"	f	file:
schedule_exit	forward.c	/^schedule_exit (struct context *c, const int n_seconds, const int signal)$/;"	f
schedule_find_earliest_wakeup	schedule.c	/^schedule_find_earliest_wakeup (struct schedule *s)$/;"	f	file:
schedule_find_least	schedule.c	/^schedule_find_least (struct schedule_entry *e)$/;"	f
schedule_free	schedule.c	/^schedule_free (struct schedule *s)$/;"	f
schedule_get_earliest_wakeup	schedule.h	/^schedule_get_earliest_wakeup (struct schedule *s,$/;"	f
schedule_init	schedule.c	/^schedule_init (void)$/;"	f
schedule_insert	schedule.c	/^schedule_insert (struct schedule *s, struct schedule_entry *e)$/;"	f	file:
schedule_print	schedule.c	/^schedule_print (struct schedule *s)$/;"	f
schedule_print_work	schedule.c	/^schedule_print_work (struct schedule_entry *e, int indent)$/;"	f
schedule_randomize_array	schedule.c	/^schedule_randomize_array (struct schedule_entry **array, int size)$/;"	f
schedule_remove_entry	schedule.c	/^schedule_remove_entry (struct schedule *s, struct schedule_entry *e)$/;"	f
schedule_remove_node	schedule.c	/^schedule_remove_node (struct schedule *s, struct schedule_entry *e)$/;"	f
schedule_rotate_up	schedule.c	/^schedule_rotate_up (struct schedule *s, struct schedule_entry *e)$/;"	f	file:
schedule_set_pri	schedule.c	/^schedule_set_pri (struct schedule_entry *e)$/;"	f	file:
schedule_test	schedule.c	/^schedule_test (void)$/;"	f
schedule_verify	schedule.c	/^schedule_verify (struct schedule *s)$/;"	f
scheduled_exit	openvpn.h	/^  struct event_timeout scheduled_exit;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
scheduled_exit_interval	options.h	/^  int scheduled_exit_interval;$/;"	m	struct:options
scheduled_exit_signal	openvpn.h	/^  int scheduled_exit_signal;$/;"	m	struct:context_2
sci	ssl_common.h	/^  const struct static_challenge_info *sci;$/;"	m	struct:tls_options	typeref:struct:tls_options::static_challenge_info
script_security	misc.c	/^int script_security = SSEC_BUILT_IN; \/* GLOBAL *\/$/;"	v
sd	ps.c	/^  int sd;$/;"	m	struct:proxy_connection	file:
sd	socket.h	/^  socket_descriptor_t sd;$/;"	m	struct:link_socket
sd	win32.h	/^  SECURITY_DESCRIPTOR sd;$/;"	m	struct:security_attributes
sd	win32.h	/^  socket_descriptor_t sd;$/;"	m	struct:net_event_win32
sd_cli	manage.h	/^  socket_descriptor_t sd_cli;$/;"	m	struct:man_connection
sd_close	socket.c	/^sd_close (socket_descriptor_t *sd)$/;"	f
sd_top	manage.h	/^  socket_descriptor_t sd_top;$/;"	m	struct:man_connection
se	multi.h	/^  struct schedule_entry se;    \/* this must be the first element of the structure *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::schedule_entry
se_ctl	event.c	/^se_ctl (struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
se_del	event.c	/^se_del (struct event_set *es, event_t event)$/;"	f	file:
se_free	event.c	/^se_free (struct event_set *es)$/;"	f	file:
se_init	event.c	/^se_init (int *maxevents, unsigned int flags)$/;"	f	file:
se_reset	event.c	/^se_reset (struct event_set *es)$/;"	f	file:
se_set	event.c	/^struct se_set$/;"	s	file:
se_wait_fast	event.c	/^se_wait_fast (struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:
se_wait_return	event.c	/^se_wait_return (struct se_set *ses,$/;"	f	file:
se_wait_scalable	event.c	/^se_wait_scalable (struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:
secs	dhcp.h	/^  uint16_t secs;       \/* seconds since request process began, set by client *\/$/;"	m	struct:dhcp
security_attributes	win32.h	/^struct security_attributes$/;"	s
selinux_context	options.h	/^  char *selinux_context;$/;"	m	struct:options
semaphore	win32.h	/^struct semaphore$/;"	s
semaphore_clear	win32.c	/^semaphore_clear (struct semaphore *s)$/;"	f
semaphore_close	win32.c	/^semaphore_close (struct semaphore *s)$/;"	f
semaphore_lock	win32.c	/^semaphore_lock (struct semaphore *s, int timeout_milliseconds)$/;"	f
semaphore_open	win32.c	/^semaphore_open (struct semaphore *s, const char *name)$/;"	f
semaphore_release	win32.c	/^semaphore_release (struct semaphore *s)$/;"	f
send	packet_id.h	/^  struct packet_id_send send;$/;"	m	struct:packet_id	typeref:struct:packet_id::packet_id_send
send_auth_failed	push.c	/^send_auth_failed (struct context *c, const char *client_reason)$/;"	f
send_control	ps.c	/^send_control (const socket_descriptor_t fd, int code)$/;"	f	file:
send_control_channel_string	forward.c	/^send_control_channel_string (struct context *c, const char *str, int msglevel)$/;"	f
send_crlf	proxy.c	/^send_crlf (socket_descriptor_t sd)$/;"	f	file:
send_line	proxy.c	/^send_line (socket_descriptor_t sd,$/;"	f	file:
send_line_crlf	proxy.c	/^send_line_crlf (socket_descriptor_t sd,$/;"	f	file:
send_push_reply	push.c	/^send_push_reply (struct context *c)$/;"	f
send_push_request	push.c	/^send_push_request (struct context *c)$/;"	f
send_reliable	ssl_common.h	/^  struct reliable *send_reliable; \/* holds a copy of outgoing packets until ACK received *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable
send_restart	push.c	/^send_restart (struct context *c, const char *kill_msg)$/;"	f
sent_push_reply_expiry	openvpn.h	/^  time_t sent_push_reply_expiry;$/;"	m	struct:context_2
seq	proto.h	/^  uint32_t      seq;       \/* sequence number *\/$/;"	m	struct:openvpn_tcphdr
seq_backtrack	packet_id.h	/^  int seq_backtrack;          \/* set from --replay-window *\/$/;"	m	struct:packet_id_rec
seq_id	fragment.h	/^  int seq_id;                   \/**< Highest fragmentation sequence ID of$/;"	m	struct:fragment_list
seq_list	packet_id.h	/^  struct seq_list *seq_list;  \/* packet-id "memory" *\/$/;"	m	struct:packet_id_rec	typeref:struct:packet_id_rec::seq_list
server	proxy.h	/^  const char *server;$/;"	m	struct:http_proxy_options
server	proxy.h	/^  const char *server;$/;"	m	struct:http_proxy_options_simple
server	socks.h	/^  char server[128];$/;"	m	struct:socks_proxy_info
server	ssl_common.h	/^  bool server;$/;"	m	struct:tls_options
server	ssl_common.h	/^  struct key_source server;     \/**< Random provided by server. *\/$/;"	m	struct:key_source2	typeref:struct:key_source2::key_source
server_bridge_defined	options.h	/^  bool server_bridge_defined;$/;"	m	struct:options
server_bridge_ip	options.h	/^  in_addr_t server_bridge_ip;$/;"	m	struct:options
server_bridge_netmask	options.h	/^  in_addr_t server_bridge_netmask;$/;"	m	struct:options
server_bridge_pool_end	options.h	/^  in_addr_t server_bridge_pool_end;$/;"	m	struct:options
server_bridge_pool_start	options.h	/^  in_addr_t server_bridge_pool_start;$/;"	m	struct:options
server_bridge_proxy_dhcp	options.h	/^  bool server_bridge_proxy_dhcp;$/;"	m	struct:options
server_defined	options.h	/^  bool server_defined;$/;"	m	struct:options
server_flags	options.h	/^  unsigned int server_flags;$/;"	m	struct:options
server_ipv6_defined	options.h	/^  bool server_ipv6_defined;				\/* IPv6 *\/$/;"	m	struct:options
server_netbits_ipv6	options.h	/^  unsigned int    server_netbits_ipv6;			\/* IPv6 *\/$/;"	m	struct:options
server_netmask	options.h	/^  in_addr_t server_netmask;$/;"	m	struct:options
server_network	options.h	/^  in_addr_t server_network;$/;"	m	struct:options
server_network_ipv6	options.h	/^  struct in6_addr server_network_ipv6;			\/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr
server_poll_interval	openvpn.h	/^  struct event_timeout server_poll_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
server_poll_timeout	options.h	/^  int server_poll_timeout;$/;"	m	struct:options
server_pushed_signal	push.c	/^server_pushed_signal (struct context *c, const struct buffer *buffer, const bool restart, const int adv)$/;"	f
session	ssl_common.h	/^  struct tls_session session[TM_SIZE];$/;"	m	struct:tls_multi	typeref:struct:tls_multi::tls_session
session_id	session_id.h	/^struct session_id$/;"	s
session_id	ssl_common.h	/^  struct session_id session_id;	\/* our random session ID *\/$/;"	m	struct:tls_session	typeref:struct:tls_session::session_id
session_id_defined	session_id.h	/^session_id_defined (const struct session_id *sid1)$/;"	f
session_id_equal	session_id.h	/^session_id_equal (const struct session_id *sid1,$/;"	f
session_id_print	session_id.c	/^session_id_print (const struct session_id *sid, struct gc_arena *gc)$/;"	f
session_id_random	session_id.c	/^session_id_random (struct session_id *sid)$/;"	f
session_id_read	session_id.h	/^session_id_read (struct session_id *sid, struct buffer *buf)$/;"	f
session_id_remote	ssl_common.h	/^  struct session_id session_id_remote;   \/* peer's random session ID *\/$/;"	m	struct:key_state	typeref:struct:key_state::session_id
session_id_write	session_id.h	/^session_id_write (const struct session_id *sid, struct buffer *buf)$/;"	f
session_id_write_prepend	session_id.h	/^session_id_write_prepend (const struct session_id *sid, struct buffer *buf)$/;"	f
session_index_name	ssl.c	/^session_index_name (int index)$/;"	f	file:
set_auth_token	misc.c	/^set_auth_token (struct user_pass *up, const char *token)$/;"	f
set_cc_config	multi.c	/^set_cc_config (struct multi_instance *mi, struct buffer_list *cc_config)$/;"	f	file:
set_check_status	error.c	/^set_check_status (unsigned int info_level, unsigned int verbose_level)$/;"	f
set_check_status_error_delay	error.h	/^set_check_status_error_delay (unsigned int milliseconds)$/;"	f
set_cloexec	fdmisc.c	/^set_cloexec (int fd)$/;"	f
set_cloexec_action	fdmisc.c	/^set_cloexec_action (int fd)$/;"	f
set_common_name	ssl_verify.c	/^set_common_name (struct tls_session *session, const char *common_name)$/;"	f	file:
set_debug_level	error.c	/^set_debug_level (const int level, const unsigned int flags)$/;"	f
set_lladdr	lladdr.c	/^int set_lladdr(const char *ifname, const char *lladdr,$/;"	f
set_mtu_discover_type	mtu.c	/^set_mtu_discover_type (int sd, int mtu_type)$/;"	f
set_mute_cutoff	error.c	/^set_mute_cutoff (const int cutoff)$/;"	f
set_nonblock	fdmisc.c	/^set_nonblock (int fd)$/;"	f
set_nonblock_action	fdmisc.c	/^set_nonblock_action (int fd)$/;"	f
set_pause_exit_win32	win32.c	/^set_pause_exit_win32 (void)$/;"	f
set_prefix	multi.h	/^set_prefix (struct multi_instance *mi)$/;"	f
set_signals	ps.c	/^set_signals (void)$/;"	f	file:
set_sock_extended_error_passing	mtu.c	/^set_sock_extended_error_passing (int sd)$/;"	f
set_std_files_to_null	misc.c	/^set_std_files_to_null (bool stdin_only)$/;"	f
set_suppress_timestamps	error.c	/^set_suppress_timestamps (bool suppressed)$/;"	f
set_user_script	options.c	/^set_user_script (struct options *options,$/;"	f	file:
set_win_sys_path	win32.c	/^set_win_sys_path (const char *newpath, struct env_set *es)$/;"	f
set_win_sys_path_via_env	win32.c	/^set_win_sys_path_via_env (struct env_set *es)$/;"	f
setenv_connection_entry	options.c	/^setenv_connection_entry (struct env_set *es,$/;"	f
setenv_counter	misc.c	/^setenv_counter (struct env_set *es, const char *name, counter_type value)$/;"	f
setenv_del	misc.c	/^setenv_del (struct env_set *es, const char *name)$/;"	f
setenv_format_indexed_name	misc.c	/^setenv_format_indexed_name (const char *name, const int i, struct gc_arena *gc)$/;"	f	file:
setenv_in_addr_t	socket.c	/^setenv_in_addr_t (struct env_set *es, const char *name_prefix, in_addr_t addr, const unsigned int flags)$/;"	f
setenv_int	misc.c	/^setenv_int (struct env_set *es, const char *name, int value)$/;"	f
setenv_int_i	misc.c	/^setenv_int_i (struct env_set *es, const char *name, const int value, const int i)$/;"	f
setenv_link_socket_actual	socket.c	/^setenv_link_socket_actual (struct env_set *es,$/;"	f
setenv_route	route.c	/^setenv_route (struct env_set *es, const struct route_ipv4 *r, int i)$/;"	f	file:
setenv_route_addr	route.c	/^setenv_route_addr (struct env_set *es, const char *key, const in_addr_t addr, int i)$/;"	f	file:
setenv_route_ipv6	route.c	/^setenv_route_ipv6 (struct env_set *es, const struct route_ipv6 *r6, int i)$/;"	f	file:
setenv_routes	route.c	/^setenv_routes (struct env_set *es, const struct route_list *rl)$/;"	f
setenv_routes_ipv6	route.c	/^setenv_routes_ipv6 (struct env_set *es, const struct route_ipv6_list *rl6)$/;"	f
setenv_settings	options.c	/^setenv_settings (struct env_set *es, const struct options *o)$/;"	f
setenv_sockaddr	socket.c	/^setenv_sockaddr (struct env_set *es, const char *name_prefix, const struct openvpn_sockaddr *addr, const unsigned int flags)$/;"	f
setenv_stats	multi.c	/^setenv_stats (struct context *c)$/;"	f	file:
setenv_str	misc.c	/^setenv_str (struct env_set *es, const char *name, const char *value)$/;"	f
setenv_str_ex	misc.c	/^setenv_str_ex (struct env_set *es,$/;"	f
setenv_str_i	misc.c	/^setenv_str_i (struct env_set *es, const char *name, const char *value, const int i)$/;"	f
setenv_str_safe	misc.c	/^setenv_str_safe (struct env_set *es, const char *name, const char *value)$/;"	f
setenv_trusted	socket.c	/^setenv_trusted (struct env_set *es, const struct link_socket_info *info)$/;"	f
setenv_unsigned	misc.c	/^setenv_unsigned (struct env_set *es, const char *name, unsigned int value)$/;"	f
setenv_untrusted	ssl_verify.c	/^setenv_untrusted (struct tls_session *session)$/;"	f	file:
settings	manage.h	/^  struct man_settings settings;$/;"	m	struct:management	typeref:struct:management::man_settings
setup_engine	crypto_openssl.c	/^setup_engine (const char *engine)$/;"	f	file:
sf2gaf	socket.c	/^sf2gaf(const unsigned int getaddr_flags,$/;"	f	file:
sha1_hash	ssl_verify.h	/^  unsigned char sha1_hash[SHA_DIGEST_LENGTH]; \/**< The SHA1 hash for a certificate *\/$/;"	m	struct:cert_hash
shaper	openvpn.h	/^  struct shaper shaper;$/;"	m	struct:context_2	typeref:struct:context_2::shaper
shaper	options.h	/^  int shaper;$/;"	m	struct:options
shaper	shaper.h	/^struct shaper $/;"	s
shaper_current_bandwidth	shaper.h	/^shaper_current_bandwidth (struct shaper *s)$/;"	f
shaper_delay	shaper.h	/^shaper_delay (struct shaper* s)$/;"	f
shaper_init	shaper.h	/^shaper_init (struct shaper *s, int bytes_per_second)$/;"	f
shaper_msg	shaper.c	/^shaper_msg (struct shaper *s)$/;"	f
shaper_reset	shaper.h	/^shaper_reset (struct shaper *s, int bytes_per_second)$/;"	f
shaper_reset_wakeup	shaper.c	/^shaper_reset_wakeup (struct shaper *s)$/;"	f
shaper_soonest_event	shaper.c	/^shaper_soonest_event (struct timeval *tv, int delay)$/;"	f
shaper_wrote_bytes	shaper.h	/^shaper_wrote_bytes (struct shaper* s, int nbytes)$/;"	f
shared_secret_file	options.h	/^  const char *shared_secret_file;$/;"	m	struct:options
shared_secret_file_inline	options.h	/^  const char *shared_secret_file_inline;$/;"	m	struct:options
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
short_form	socket.c	/^  const char *short_form;$/;"	m	struct:proto_names	file:
short_form	tun.c	/^  const char *short_form;$/;"	m	struct:ipset_names	file:
show_adapter	tun.c	/^show_adapter (int msglev, const IP_ADAPTER_INFO *a, struct gc_arena *gc)$/;"	f	file:
show_adapters	tun.c	/^show_adapters (int msglev)$/;"	f
show_available_ciphers	crypto_openssl.c	/^show_available_ciphers ()$/;"	f
show_available_ciphers	crypto_polarssl.c	/^show_available_ciphers ()$/;"	f
show_available_digests	crypto_openssl.c	/^show_available_digests ()$/;"	f
show_available_digests	crypto_polarssl.c	/^show_available_digests ()$/;"	f
show_available_engines	crypto_openssl.c	/^show_available_engines ()$/;"	f
show_available_engines	crypto_polarssl.c	/^show_available_engines ()$/;"	f
show_available_tls_ciphers	ssl_openssl.c	/^show_available_tls_ciphers (const char *cipher_list)$/;"	f
show_available_tls_ciphers	ssl_polarssl.c	/^show_available_tls_ciphers (const char *cipher_list)$/;"	f
show_ciphers	options.h	/^  bool show_ciphers;$/;"	m	struct:options
show_connection_entries	options.c	/^show_connection_entries (const struct options *o)$/;"	f	file:
show_connection_entry	options.c	/^show_connection_entry (const struct connection_entry *o)$/;"	f	file:
show_dhcp_option_addrs	options.c	/^show_dhcp_option_addrs (const char *name, const in_addr_t *array, int len)$/;"	f	file:
show_digests	options.h	/^  bool show_digests;$/;"	m	struct:options
show_engines	options.h	/^  bool show_engines;$/;"	m	struct:options
show_http_proxy_options	options.c	/^show_http_proxy_options (const struct http_proxy_options *o)$/;"	f	file:
show_library_versions	options.c	/^show_library_versions(const unsigned int flags)$/;"	f
show_net	manage.h	/^  void (*show_net) (void *arg, const int msglevel);$/;"	m	struct:management_callback
show_net_up	options.h	/^  bool show_net_up;$/;"	m	struct:options
show_opt	route.c	/^show_opt (const char *option)$/;"	f	file:
show_p2mp_parms	options.c	/^show_p2mp_parms (const struct options *o)$/;"	f	file:
show_pkcs11_ids	pkcs11.c	/^show_pkcs11_ids ($/;"	f
show_routes	route.c	/^show_routes (int msglev)$/;"	f
show_settings	options.c	/^show_settings (const struct options *o)$/;"	f
show_tap_win_adapters	tun.c	/^show_tap_win_adapters (int msglev, int warnlev)$/;"	f
show_tls_ciphers	options.h	/^  bool show_tls_ciphers;$/;"	m	struct:options
show_tls_performance_stats	ssl.c	/^show_tls_performance_stats(void)$/;"	f
show_tuntap_options	options.c	/^show_tuntap_options (const struct tuntap_options *o)$/;"	f	file:
show_valid_win32_tun_subnets	tun.c	/^void show_valid_win32_tun_subnets (void)$/;"	f
show_wait_status	forward.c	/^show_wait_status (struct context *c)$/;"	f
siaddr	dhcp.h	/^  uint32_t siaddr;     \/* server IP address *\/$/;"	m	struct:dhcp
sig	openvpn.h	/^  struct signal_info *sig;      \/**< Internal error signaling object. *\/$/;"	m	struct:context	typeref:struct:context::signal_info
siginfo_static	sig.c	/^struct signal_info siginfo_static; \/* GLOBAL *\/$/;"	v	typeref:struct:signal_info
signal_description	sig.c	/^signal_description (const int signum, const char *sigtext)$/;"	f
signal_handler	sig.c	/^signal_handler (const int signum)$/;"	f	file:
signal_info	sig.h	/^struct signal_info$/;"	s
signal_mode	sig.c	/^static int signal_mode; \/* GLOBAL *\/$/;"	v	file:
signal_name	sig.c	/^signal_name (const int sig, const bool upper)$/;"	f
signal_received	sig.h	/^  volatile int signal_received;$/;"	m	struct:signal_info
signal_reset	sig.c	/^signal_reset (struct signal_info *si)$/;"	f	file:
signal_restart_status	sig.c	/^signal_restart_status (const struct signal_info *si)$/;"	f
signal_text	sig.h	/^  const char *signal_text;$/;"	m	struct:signal_info
signame	sig.c	/^struct signame {$/;"	s	file:
signames	sig.c	/^static const struct signame signames[] = {$/;"	v	typeref:struct:signame	file:
signature_length	ssl_polarssl.c	/^  size_t signature_length;$/;"	m	struct:external_context	file:
single_session	options.h	/^  bool single_session;$/;"	m	struct:options
single_session	ssl_common.h	/^  bool single_session;$/;"	m	struct:tls_options
size	buffer.h	/^  int size;                  \/* current number of entries *\/$/;"	m	struct:buffer_list
size	manage.h	/^  int size;$/;"	m	struct:log_history
size	pool.h	/^  int size;$/;"	m	struct:ifconfig_pool
size	reliable.h	/^  int size;$/;"	m	struct:reliable
size	win32.h	/^  DWORD size;$/;"	m	struct:overlapped_io
size_ipv6	pool.h	/^  unsigned int size_ipv6;$/;"	m	struct:ifconfig_pool
sk_x509_name_cmp	ssl_openssl.c	/^sk_x509_name_cmp(const X509_NAME * const *a, const X509_NAME * const *b)$/;"	f	file:
skip_leading_whitespace	buffer.c	/^skip_leading_whitespace (const char *str)$/;"	f
sleep	syshead.h	43;"	d
sname	dhcp.h	/^  uint8_t  sname[64];  \/* optional server host name *\/$/;"	m	struct:dhcp
sndbuf	options.h	/^  int sndbuf;$/;"	m	struct:options
sndbuf	socket.h	/^  int sndbuf;$/;"	m	struct:socket_buffer_size
sns	pf.h	/^  struct pf_subnet_set sns;$/;"	m	struct:pf_set	typeref:struct:pf_set::pf_subnet_set
so_pathname	plugin.h	/^  const char *so_pathname;$/;"	m	struct:plugin
so_pathname	plugin.h	/^  const char *so_pathname;$/;"	m	struct:plugin_option
sock	mtcp.c	/^  unsigned int sock;$/;"	m	struct:ta_iow_flags	file:
sock_addr_set	ps.c	/^sock_addr_set (struct openvpn_sockaddr *osaddr,$/;"	f	file:
sockaddr_unix_init	socket.c	/^sockaddr_unix_init (struct sockaddr_un *local, const char *path)$/;"	f
sockaddr_unix_name	socket.c	/^sockaddr_unix_name (const struct sockaddr_un *local, const char *null)$/;"	f
socket_accept_unix	socket.c	/^socket_accept_unix (socket_descriptor_t sd,$/;"	f
socket_adjust_frame_parameters	socket.c	/^socket_adjust_frame_parameters (struct frame *frame, int proto)$/;"	f
socket_bind	socket.c	/^socket_bind (socket_descriptor_t sd,$/;"	f
socket_bind_unix	socket.c	/^socket_bind_unix (socket_descriptor_t sd,$/;"	f
socket_buffer_size	socket.h	/^struct socket_buffer_size$/;"	s
socket_buffer_sizes	socket.h	/^  struct socket_buffer_size socket_buffer_sizes;$/;"	m	struct:link_socket	typeref:struct:link_socket::socket_buffer_size
socket_connect	socket.c	/^socket_connect (socket_descriptor_t *sd,$/;"	f
socket_connect_unix	socket.c	/^socket_connect_unix (socket_descriptor_t sd,$/;"	f
socket_connection_reset	socket.h	/^socket_connection_reset (const struct link_socket *sock, int status)$/;"	f
socket_defined	syshead.h	/^socket_defined (const socket_descriptor_t sd)$/;"	f
socket_delete_unix	socket.c	/^socket_delete_unix (const struct sockaddr_un *local)$/;"	f
socket_descriptor_t	syshead.h	/^typedef SOCKET socket_descriptor_t;$/;"	t
socket_descriptor_t	syshead.h	/^typedef int socket_descriptor_t;$/;"	t
socket_do_accept	socket.c	/^socket_do_accept (socket_descriptor_t sd,$/;"	f
socket_do_listen	socket.c	/^socket_do_listen (socket_descriptor_t sd,$/;"	f	file:
socket_event_handle	socket.h	/^socket_event_handle (const struct link_socket *s)$/;"	f
socket_finalize	socket.c	/^socket_finalize (SOCKET s,$/;"	f
socket_foreign_protocol_detected	socket.h	/^socket_foreign_protocol_detected (const struct link_socket *sock)$/;"	f
socket_foreign_protocol_head	socket.h	/^socket_foreign_protocol_head (const struct link_socket *sock)$/;"	f
socket_foreign_protocol_sd	socket.h	/^socket_foreign_protocol_sd (const struct link_socket *sock)$/;"	f
socket_frame_init	socket.c	/^socket_frame_init (const struct frame *frame, struct link_socket *sock)$/;"	f	file:
socket_get_rcvbuf	socket.c	/^socket_get_rcvbuf (int sd)$/;"	f	file:
socket_get_sndbuf	socket.c	/^socket_get_sndbuf (int sd)$/;"	f	file:
socket_listen_accept	socket.c	/^socket_listen_accept (socket_descriptor_t sd,$/;"	f	file:
socket_listen_event_handle	socket.c	/^socket_listen_event_handle (struct link_socket *s)$/;"	f
socket_read_residual	socket.h	/^socket_read_residual (const struct link_socket *s)$/;"	f
socket_recv_queue	socket.c	/^socket_recv_queue (struct link_socket *sock, int maxsize)$/;"	f
socket_reset_listen_persistent	socket.h	/^socket_reset_listen_persistent (struct link_socket *s)$/;"	f
socket_restart_pause	init.c	/^socket_restart_pause (struct context *c)$/;"	f	file:
socket_send_queue	socket.c	/^socket_send_queue (struct link_socket *sock, struct buffer *buf, const struct link_socket_actual *to)$/;"	f
socket_set	socket.c	/^socket_set (struct link_socket *s,$/;"	f
socket_set_buffers	socket.c	/^socket_set_buffers (int fd, const struct socket_buffer_size *sbs)$/;"	f	file:
socket_set_called	multi.h	/^  bool socket_set_called;$/;"	m	struct:multi_instance
socket_set_flags	socket.c	/^socket_set_flags (int sd, unsigned int sockflags)$/;"	f	file:
socket_set_listen_persistent	socket.h	/^socket_set_listen_persistent (struct link_socket *s,$/;"	f
socket_set_mark	socket.c	/^socket_set_mark (int sd, int mark)$/;"	f	file:
socket_set_rcvbuf	socket.c	/^socket_set_rcvbuf (int sd, int size)$/;"	f	file:
socket_set_sndbuf	socket.c	/^socket_set_sndbuf (int sd, int size)$/;"	f	file:
socket_set_tcp_nodelay	socket.c	/^socket_set_tcp_nodelay (int sd, int state)$/;"	f	file:
socket_stat	socket.c	/^socket_stat (const struct link_socket *s, unsigned int rwflags, struct gc_arena *gc)$/;"	f
sockflags	options.h	/^  unsigned int sockflags;$/;"	m	struct:options
sockflags	socket.h	/^  unsigned int sockflags;$/;"	m	struct:link_socket
socks_adjust_frame_parameters	socks.c	/^socks_adjust_frame_parameters (struct frame *frame, int proto)$/;"	f
socks_handshake	socks.c	/^socks_handshake (struct socks_proxy_info *p,$/;"	f	file:
socks_postprocess_incoming_link	forward.c	/^socks_postprocess_incoming_link (struct context *c)$/;"	f	file:
socks_preprocess_outgoing_link	forward.c	/^socks_preprocess_outgoing_link (struct context *c,$/;"	f	file:
socks_process_incoming_udp	socks.c	/^socks_process_incoming_udp (struct buffer *buf,$/;"	f
socks_process_outgoing_udp	socks.c	/^socks_process_outgoing_udp (struct buffer *buf,$/;"	f
socks_proxy	openvpn.h	/^  struct socks_proxy_info *socks_proxy;$/;"	m	struct:context_1	typeref:struct:context_1::socks_proxy_info
socks_proxy	socket.h	/^  struct socks_proxy_info *socks_proxy;$/;"	m	struct:link_socket	typeref:struct:link_socket::socks_proxy_info
socks_proxy_authfile	options.h	/^  const char *socks_proxy_authfile;$/;"	m	struct:connection_entry
socks_proxy_close	socks.c	/^socks_proxy_close (struct socks_proxy_info *sp)$/;"	f
socks_proxy_info	socks.h	/^struct socks_proxy_info {$/;"	s
socks_proxy_new	socks.c	/^socks_proxy_new (const char *server,$/;"	f
socks_proxy_owned	openvpn.h	/^  bool socks_proxy_owned;$/;"	m	struct:context_1
socks_proxy_port	options.h	/^  int socks_proxy_port;$/;"	m	struct:connection_entry
socks_proxy_retry	options.h	/^  bool socks_proxy_retry;$/;"	m	struct:connection_entry
socks_proxy_server	options.h	/^  const char *socks_proxy_server;$/;"	m	struct:connection_entry
socks_relay	socket.h	/^  struct link_socket_actual socks_relay; \/* Socks UDP relay address *\/$/;"	m	struct:link_socket	typeref:struct:link_socket::link_socket_actual
socks_username_password_auth	socks.c	/^socks_username_password_auth (struct socks_proxy_info *p,$/;"	f	file:
sofar	perf.c	/^  double sofar;$/;"	m	struct:perf	file:
solaris_close_tun	tun.c	/^solaris_close_tun (struct tuntap *tt)$/;"	f	file:
solaris_error_close	tun.c	/^solaris_error_close (struct tuntap *tt, const struct env_set *es, $/;"	f	file:
source	proto.h	/^  uint16_t      source;    \/* source port *\/$/;"	m	struct:openvpn_tcphdr
source	proto.h	/^  uint16_t   source;$/;"	m	struct:openvpn_udphdr
source	proto.h	/^  uint8_t source[OPENVPN_ETH_ALEN];   \/* source ethernet addr	*\/$/;"	m	struct:openvpn_ethhdr
space	options.c	/^space (unsigned char c)$/;"	f	file:
spec	route.h	/^  struct route_special_addr spec;$/;"	m	struct:route_list	typeref:struct:route_list::route_special_addr
special_state_msg	manage.h	/^  const char *special_state_msg;$/;"	m	struct:man_persist
srandom	syshead.h	45;"	d
srcdir	Makefile	/^srcdir = .$/;"	m
sru	schedule.c	/^  int sru;$/;"	m	struct:status	file:
ssl	ssl_openssl.h	/^    SSL *ssl;			\/* SSL object -- new obj created for each new key *\/$/;"	m	struct:key_state_ssl
ssl_bio	ssl_openssl.h	/^    BIO *ssl_bio;			\/* read\/write plaintext from here *\/$/;"	m	struct:key_state_ssl
ssl_ctx	openvpn.h	/^  struct tls_root_ctx ssl_ctx;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::tls_root_ctx
ssl_ctx	ssl_common.h	/^  struct tls_root_ctx ssl_ctx;$/;"	m	struct:tls_options	typeref:struct:tls_options::tls_root_ctx
ssl_default_options_string	ssl.c	/^static const char ssl_default_options_string[] = "V0 UNDEF";$/;"	v	file:
ssl_flags	options.h	/^  unsigned int ssl_flags; \/* set to SSLF_x flags from ssl.h *\/$/;"	m	struct:options
ssl_flags	ssl_common.h	/^  unsigned int ssl_flags;$/;"	m	struct:tls_options
ssl_purge_auth	ssl.c	/^ssl_purge_auth (const bool auth_user_pass_only)$/;"	f
ssl_purge_auth_challenge	ssl.c	/^ssl_purge_auth_challenge (void)$/;"	f
ssl_put_auth_challenge	ssl.c	/^ssl_put_auth_challenge (const char *cr_str)$/;"	f
ssl_set_auth_nocache	ssl.c	/^ssl_set_auth_nocache (void)$/;"	f
ssl_set_auth_token	ssl.c	/^ssl_set_auth_token (const char *token)$/;"	f
stack	perf.c	/^  int stack[STACK_N];$/;"	m	struct:perf_set	file:
stack_len	perf.c	/^  int stack_len;$/;"	m	struct:perf_set	file:
stale_route_check_trigger	multi.c	/^stale_route_check_trigger (struct multi_context *m)$/;"	f
stale_routes_ageing_time	options.h	/^  int stale_routes_ageing_time;$/;"	m	struct:options
stale_routes_check_et	multi.h	/^  struct event_timeout stale_routes_check_et;$/;"	m	struct:multi_context	typeref:struct:multi_context::event_timeout
stale_routes_check_interval	options.h	/^  int stale_routes_check_interval;$/;"	m	struct:options
standalone_disabled	manage.h	/^  bool standalone_disabled;$/;"	m	struct:man_persist
standby_iter	tun.h	/^  int standby_iter;$/;"	m	struct:tuntap
start	interval.h	/^  struct timeval start;$/;"	m	struct:usec_timer	typeref:struct:usec_timer::timeval
start	perf.c	/^  struct timeval start;$/;"	m	struct:perf	typeref:struct:perf::timeval	file:
state	manage.h	/^  int state;$/;"	m	struct:man_connection
state	manage.h	/^  int state;$/;"	m	union:log_entry_union
state	manage.h	/^  struct log_history *state;$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history
state	mstats.h	/^  int state;$/;"	m	struct:mmap_stats
state	perf.c	/^  int state;$/;"	m	struct:perf	file:
state	ssl_common.h	/^  int state;$/;"	m	struct:key_state
state_buffer_size	manage.h	/^  int state_buffer_size;$/;"	m	struct:man_settings
state_id	misc.h	/^  const char *state_id;$/;"	m	struct:auth_challenge_info
state_must_be	perf.c	/^state_must_be (const struct perf *p, const int wanted)$/;"	f	file:
state_name	ssl.c	/^state_name (int state)$/;"	f	file:
state_realtime	manage.h	/^  bool state_realtime;$/;"	m	struct:man_connection
static_challenge_info	misc.h	/^struct static_challenge_info {$/;"	s
static_challenge_info	misc.h	/^struct static_challenge_info {};$/;"	s
static_context	init.c	/^static struct context *static_context; \/* GLOBAL *\/$/;"	v	typeref:struct:context	file:
static_key	openvpn.h	/^  struct key_ctx_bi static_key;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_ctx_bi
static_key_foot	crypto.c	/^static const char static_key_foot[] = "-----END OpenVPN Static key V1-----";$/;"	v	file:
static_key_head	crypto.c	/^static const char static_key_head[] = "-----BEGIN OpenVPN Static key V1-----";$/;"	v	file:
static_plugin_common	plugin.c	/^static struct plugin_common *static_plugin_common = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:plugin_common	file:
static_proxy_user_pass	proxy.c	/^static struct user_pass static_proxy_user_pass;$/;"	v	typeref:struct:user_pass	file:
status	manage.h	/^  void (*status) (void *arg, const int version, struct status_output *so);$/;"	m	struct:management_callback
status	schedule.c	/^struct status$/;"	s	file:
status	win32.h	/^  int status;$/;"	m	struct:overlapped_io
status_close	status.c	/^status_close (struct status_output *so)$/;"	f
status_file	options.h	/^  const char *status_file;$/;"	m	struct:options
status_file_update_freq	options.h	/^  int status_file_update_freq;$/;"	m	struct:options
status_file_version	multi.h	/^  int status_file_version;$/;"	m	struct:multi_context
status_file_version	options.h	/^  int status_file_version;$/;"	m	struct:options
status_flush	status.c	/^status_flush (struct status_output *so)$/;"	f
status_open	status.c	/^status_open (const char *filename,$/;"	f
status_output	openvpn.h	/^  struct status_output *status_output;$/;"	m	struct:context_1	typeref:struct:context_1::status_output
status_output	status.h	/^struct status_output$/;"	s
status_output_owned	openvpn.h	/^  bool status_output_owned;$/;"	m	struct:context_1
status_printf	status.c	/^status_printf (struct status_output *so, const char *format, ...)$/;"	f
status_read	status.c	/^status_read (struct status_output *so, struct buffer *buf)$/;"	f
status_reset	status.c	/^status_reset (struct status_output *so)$/;"	f
status_rw_flags	status.h	/^status_rw_flags (const struct status_output *so)$/;"	f
status_trigger	status.c	/^status_trigger (struct status_output *so)$/;"	f
status_trigger_tv	status.c	/^status_trigger_tv (struct status_output *so, struct timeval *tv)$/;"	f
std_redir	error.c	/^static bool std_redir;      \/* GLOBAL *\/$/;"	v	file:
store_proxy_authenticate	proxy.c	/^store_proxy_authenticate (struct http_proxy_info *p, char *data)$/;"	f	file:
stream_buf	socket.h	/^  struct stream_buf stream_buf;$/;"	m	struct:link_socket	typeref:struct:link_socket::stream_buf
stream_buf	socket.h	/^struct stream_buf$/;"	s
stream_buf_added	socket.c	/^stream_buf_added (struct stream_buf *sb,$/;"	f
stream_buf_close	socket.c	/^stream_buf_close (struct stream_buf* sb)$/;"	f
stream_buf_data	socket.h	/^  struct buffer stream_buf_data;$/;"	m	struct:link_socket	typeref:struct:link_socket::buffer
stream_buf_get_final	socket.c	/^stream_buf_get_final (struct stream_buf *sb, struct buffer *buf)$/;"	f	file:
stream_buf_get_next	socket.c	/^stream_buf_get_next (struct stream_buf *sb, struct buffer *buf)$/;"	f	file:
stream_buf_init	socket.c	/^stream_buf_init (struct stream_buf *sb,$/;"	f
stream_buf_read_setup	socket.h	/^stream_buf_read_setup (struct link_socket* sock)$/;"	f
stream_buf_read_setup_dowork	socket.c	/^stream_buf_read_setup_dowork (struct link_socket* sock)$/;"	f
stream_buf_reset	socket.c	/^stream_buf_reset (struct stream_buf *sb)$/;"	f	file:
stream_buf_set_next	socket.c	/^stream_buf_set_next (struct stream_buf *sb)$/;"	f	file:
stream_reset	socket.h	/^  bool stream_reset;$/;"	m	struct:link_socket
streq	options.h	599;"	d
strerror_ts	misc.c	/^strerror_ts (int errnum, struct gc_arena *gc)$/;"	f
strerror_win32	error.c	/^strerror_win32 (DWORD errnum, struct gc_arena *gc)$/;"	f
string	manage.h	/^  const char *string;$/;"	m	struct:log_entry
string	misc.h	/^  char *string;$/;"	m	struct:env_item
string_alloc	buffer.h	145;"	d
string_alloc_buf	buffer.h	146;"	d
string_alloc_buf_debug	buffer.c	/^string_alloc_buf_debug (const char *str, struct gc_arena *gc, const char *file, int line)$/;"	f
string_alloc_debug	buffer.c	/^string_alloc_debug (const char *str, struct gc_arena *gc, const char *file, int line)$/;"	f
string_array_len	buffer.c	/^string_array_len (const char **array)$/;"	f
string_class	buffer.c	/^string_class (const char *str, const unsigned int inclusive, const unsigned int exclusive)$/;"	f
string_clear	buffer.c	/^string_clear (char *str)$/;"	f
string_defined_equal	options.c	/^string_defined_equal (const char *s1, const char *s2)$/;"	f
string_mod	buffer.c	/^string_mod (char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace)$/;"	f
string_mod_const	buffer.c	/^string_mod_const (const char *str,$/;"	f
string_mod_remap_name	ssl_verify.c	/^string_mod_remap_name (char *str, const unsigned int restrictive_flags)$/;"	f	file:
string_null_terminate	buffer.c	/^string_null_terminate (char *str, int len, int capacity)$/;"	f
string_replace_leading	buffer.c	/^string_replace_leading (char *str, const char match, const char replace)$/;"	f
string_substitute	options.c	/^string_substitute (const char *src, int from, int to, struct gc_arena *gc)$/;"	f	file:
strncpynt	buffer.h	/^strncpynt (char *dest, const char *src, size_t maxlen)$/;"	f
subdir	Makefile	/^subdir = src\/openvpn$/;"	m
sum	perf.c	/^  double sum;$/;"	m	struct:perf	file:
suppress_timestamps	error.c	/^static bool suppress_timestamps; \/* GLOBAL *\/$/;"	v	file:
suppress_timestamps	options.h	/^  bool suppress_timestamps;$/;"	m	struct:options
swap_hmac	ssl.c	/^swap_hmac (struct buffer *buf, const struct crypto_options *co, bool incoming)$/;"	f	file:
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
system_error_message	misc.c	/^system_error_message (int stat, struct gc_arena *gc)$/;"	f
system_str	misc.h	/^  char *system_str;$/;"	m	struct:argv
ta_iow_flags	mtcp.c	/^struct ta_iow_flags$/;"	s	file:
tail	buffer.h	/^  struct buffer_entry *tail; \/* last item pushed *\/$/;"	m	struct:buffer_list	typeref:struct:buffer_list::buffer_entry
tail	pushlist.h	/^  struct push_entry *tail;$/;"	m	struct:push_list	typeref:struct:push_list::push_entry
tap_allow_nonadmin_access	tun.c	/^tap_allow_nonadmin_access (const char *dev_node)$/;"	f
tap_allow_nonadmin_access_handle	tun.c	/^tap_allow_nonadmin_access_handle (const char *device_path, HANDLE hand)$/;"	f	file:
tap_reg	tun.h	/^struct tap_reg$/;"	s
tap_sleep	tun.h	/^  int tap_sleep;$/;"	m	struct:tuntap_options
tap_win_getinfo	tun.c	/^tap_win_getinfo (const struct tuntap *tt, struct gc_arena *gc)$/;"	f
target_alias	Makefile	/^target_alias = arm-none-linux-gnueabi$/;"	m
tas_last	ssl_common.h	/^  time_t tas_last;$/;"	m	struct:tls_multi
tcp	proto.h	/^    struct openvpn_tcphdr tcp;$/;"	m	union:ip_tcp_udp_hdr::__anon1	typeref:struct:ip_tcp_udp_hdr::__anon1::openvpn_tcphdr
tcp_connection_established	socket.c	/^tcp_connection_established (const struct link_socket_actual *act)$/;"	f	file:
tcp_link_out_deferred	multi.h	/^  struct mbuf_set *tcp_link_out_deferred;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::mbuf_set
tcp_mode	ssl_common.h	/^  bool tcp_mode;$/;"	m	struct:tls_options
tcp_queue_limit	multi.h	/^  int tcp_queue_limit;$/;"	m	struct:multi_context
tcp_queue_limit	options.h	/^  int tcp_queue_limit;$/;"	m	struct:options
tcp_rwflags	multi.h	/^  unsigned int tcp_rwflags;$/;"	m	struct:multi_instance
test_adapter_ip_netmask	tun.c	/^test_adapter_ip_netmask (const IP_ADAPTER_INFO *ai, const in_addr_t ip, const in_addr_t netmask)$/;"	f	file:
test_crypto	crypto.c	/^test_crypto (const struct crypto_options *co, struct frame* frame)$/;"	f
test_crypto	options.h	/^  bool test_crypto;$/;"	m	struct:options
test_crypto_thread	init.c	/^test_crypto_thread (void *arg)$/;"	f	file:
test_file	misc.c	/^test_file (const char *filename)$/;"	f
test_local_addr	route.c	/^test_local_addr (const in_addr_t addr, const struct route_gateway_info *rgi) \/* PLATFORM-SPECIFIC *\/$/;"	f
test_local_addr	route.c	/^test_local_addr (const in_addr_t addr, const struct route_gateway_info *rgi)$/;"	f
test_route	route.c	/^test_route (const IP_ADAPTER_INFO *adapters,$/;"	f	file:
test_route_helper	route.c	/^test_route_helper (bool *ret,$/;"	f	file:
test_routes	route.c	/^test_routes (const struct route_list *rl, const struct tuntap *tt)$/;"	f
test_routes	route.h	/^static inline bool test_routes (const struct route_list *rl, const struct tuntap *tt) { return true; }$/;"	f
thread_mode	multi.h	/^  int thread_mode;$/;"	m	struct:multi_context
throw_signal	sig.c	/^throw_signal (const int signum)$/;"	f
throw_signal_soft	sig.c	/^throw_signal_soft (const int signum, const char *signal_text)$/;"	f
time	packet_id.h	/^  time_t time;                \/* highest time stamp received *\/$/;"	m	struct:packet_id_rec
time	packet_id.h	/^  time_t time;             \/* time stamp *\/$/;"	m	struct:packet_id_persist
time	packet_id.h	/^  time_t time;             \/* time stamp *\/$/;"	m	struct:packet_id_persist_file_image
time	packet_id.h	/^  time_t time; \/* converted to net_time_t before transmission *\/$/;"	m	struct:packet_id_net
time	packet_id.h	/^  time_t time;$/;"	m	struct:packet_id_send
time_backtrack	packet_id.h	/^  int time_backtrack;         \/* set from --replay-window *\/$/;"	m	struct:packet_id_rec
time_format	common.h	61;"	d
time_last_written	packet_id.h	/^  time_t time_last_written;$/;"	m	struct:packet_id_persist
time_string	otime.c	/^time_string (time_t t, int usec, bool show_usec, struct gc_arena *gc)$/;"	f
time_test	otime.c	/^time_test (void)$/;"	f
time_type	common.h	/^typedef unsigned long time_type;$/;"	t
timeout	proxy.h	/^  int timeout;$/;"	m	struct:http_proxy_options
timeout	reliable.h	/^  interval_t timeout;$/;"	m	struct:reliable_entry
timeout_random_component	openvpn.h	/^  struct timeval timeout_random_component;$/;"	m	struct:context_2	typeref:struct:context_2::timeval
timestamp	fragment.h	/^  time_t timestamp;		\/**< Timestamp for time-to-live purposes. *\/$/;"	m	struct:fragment
timestamp	manage.h	/^  time_t timestamp;$/;"	m	struct:log_entry
timeval	openvpn.h	/^  struct timeval timeval;$/;"	m	struct:context_2	typeref:struct:context_2::timeval
title_string	options.c	/^const char title_string[] =$/;"	v
tls1_PRF	ssl.c	/^tls1_PRF(uint8_t *label,$/;"	f	file:
tls1_P_hash	ssl.c	/^tls1_P_hash(const md_kt_t *md_kt,$/;"	f
tls_adjust_frame_parameters	ssl.c	/^tls_adjust_frame_parameters(struct frame *frame)$/;"	f
tls_auth	ssl_common.h	/^  struct crypto_options tls_auth;$/;"	m	struct:tls_options	typeref:struct:tls_options::crypto_options
tls_auth	ssl_common.h	/^  struct crypto_options tls_auth;$/;"	m	struct:tls_session	typeref:struct:tls_session::crypto_options
tls_auth_file	options.h	/^  const char *tls_auth_file;		\/* shared secret *\/$/;"	m	struct:options
tls_auth_file_inline	options.h	/^  const char *tls_auth_file_inline;$/;"	m	struct:options
tls_auth_key	openvpn.h	/^  struct key_ctx_bi tls_auth_key;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_ctx_bi
tls_auth_key	ssl.h	/^  struct key_ctx_bi tls_auth_key;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::key_ctx_bi
tls_auth_key	ssl_common.h	/^  struct key_ctx_bi tls_auth_key;$/;"	m	struct:tls_options	typeref:struct:tls_options::key_ctx_bi
tls_auth_options	ssl.h	/^  struct crypto_options tls_auth_options;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::crypto_options
tls_auth_pid	ssl_common.h	/^  struct packet_id tls_auth_pid;$/;"	m	struct:tls_session	typeref:struct:tls_session::packet_id
tls_auth_standalone	openvpn.h	/^  struct tls_auth_standalone *tls_auth_standalone;$/;"	m	struct:context_2	typeref:struct:context_2::tls_auth_standalone
tls_auth_standalone	ssl.h	/^struct tls_auth_standalone$/;"	s
tls_auth_standalone_finalize	ssl.c	/^tls_auth_standalone_finalize (struct tls_auth_standalone *tas,$/;"	f
tls_auth_standalone_init	ssl.c	/^tls_auth_standalone_init (struct tls_options *tls_options,$/;"	f
tls_authenticate_key	ssl_verify.c	/^tls_authenticate_key (struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason)$/;"	f
tls_authentication_status	ssl_verify.c	/^tls_authentication_status (struct tls_multi *multi, const int latency)$/;"	f
tls_cipher_name_pair	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	t	typeref:struct:__anon10
tls_cipher_name_translation_table	ssl.c	/^static const tls_cipher_name_pair tls_cipher_name_translation_table[] = {$/;"	v	file:
tls_clear_error	ssl_openssl.c	/^tls_clear_error()$/;"	f
tls_clear_error	ssl_polarssl.c	/^tls_clear_error()$/;"	f
tls_client	options.h	/^  bool tls_client;$/;"	m	struct:options
tls_client_reason	ssl_verify.h	/^tls_client_reason (struct tls_multi *multi)$/;"	f
tls_common_name	ssl_verify.c	/^tls_common_name (const struct tls_multi *multi, const bool null)$/;"	f
tls_common_name_hash	ssl_verify.h	/^tls_common_name_hash (const struct tls_multi *multi, const char **cn, uint32_t *cn_hash)$/;"	f
tls_ctx_add_extra_certs	ssl_openssl.c	/^tls_ctx_add_extra_certs (struct tls_root_ctx *ctx, BIO *bio)$/;"	f	file:
tls_ctx_client_new	ssl_openssl.c	/^tls_ctx_client_new(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f
tls_ctx_client_new	ssl_polarssl.c	/^tls_ctx_client_new(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f
tls_ctx_free	ssl_openssl.c	/^tls_ctx_free(struct tls_root_ctx *ctx)$/;"	f
tls_ctx_free	ssl_polarssl.c	/^tls_ctx_free(struct tls_root_ctx *ctx)$/;"	f
tls_ctx_free_cert_file	ssl_openssl.c	/^tls_ctx_free_cert_file (X509 *x509)$/;"	f
tls_ctx_initialised	ssl_openssl.c	/^bool tls_ctx_initialised(struct tls_root_ctx *ctx)$/;"	f
tls_ctx_initialised	ssl_polarssl.c	/^tls_ctx_initialised(struct tls_root_ctx *ctx)$/;"	f
tls_ctx_load_ca	ssl_openssl.c	/^tls_ctx_load_ca (struct tls_root_ctx *ctx, const char *ca_file,$/;"	f
tls_ctx_load_ca	ssl_polarssl.c	/^void tls_ctx_load_ca (struct tls_root_ctx *ctx, const char *ca_file,$/;"	f
tls_ctx_load_cert_file	ssl_openssl.c	/^tls_ctx_load_cert_file (struct tls_root_ctx *ctx, const char *cert_file,$/;"	f
tls_ctx_load_cert_file	ssl_polarssl.c	/^tls_ctx_load_cert_file (struct tls_root_ctx *ctx, const char *cert_file,$/;"	f
tls_ctx_load_cert_file_and_copy	ssl_openssl.c	/^tls_ctx_load_cert_file_and_copy (struct tls_root_ctx *ctx,$/;"	f	file:
tls_ctx_load_cryptoapi	ssl_openssl.c	/^tls_ctx_load_cryptoapi(struct tls_root_ctx *ctx, const char *cryptoapi_cert)$/;"	f
tls_ctx_load_cryptoapi	ssl_polarssl.c	/^tls_ctx_load_cryptoapi(struct tls_root_ctx *ctx, const char *cryptoapi_cert)$/;"	f
tls_ctx_load_dh_params	ssl_openssl.c	/^tls_ctx_load_dh_params (struct tls_root_ctx *ctx, const char *dh_file,$/;"	f
tls_ctx_load_dh_params	ssl_polarssl.c	/^tls_ctx_load_dh_params (struct tls_root_ctx *ctx, const char *dh_file,$/;"	f
tls_ctx_load_extra_certs	ssl_openssl.c	/^tls_ctx_load_extra_certs (struct tls_root_ctx *ctx, const char *extra_certs_file,$/;"	f
tls_ctx_load_extra_certs	ssl_polarssl.c	/^tls_ctx_load_extra_certs (struct tls_root_ctx *ctx, const char *extra_certs_file,$/;"	f
tls_ctx_load_pkcs12	ssl_openssl.c	/^tls_ctx_load_pkcs12(struct tls_root_ctx *ctx, const char *pkcs12_file,$/;"	f
tls_ctx_load_pkcs12	ssl_polarssl.c	/^tls_ctx_load_pkcs12(struct tls_root_ctx *ctx, const char *pkcs12_file,$/;"	f
tls_ctx_load_priv_file	ssl_openssl.c	/^tls_ctx_load_priv_file (struct tls_root_ctx *ctx, const char *priv_key_file,$/;"	f
tls_ctx_load_priv_file	ssl_polarssl.c	/^tls_ctx_load_priv_file (struct tls_root_ctx *ctx, const char *priv_key_file,$/;"	f
tls_ctx_personalise_random	ssl_polarssl.c	/^void tls_ctx_personalise_random(struct tls_root_ctx *ctx)$/;"	f
tls_ctx_restrict_ciphers	ssl_openssl.c	/^tls_ctx_restrict_ciphers(struct tls_root_ctx *ctx, const char *ciphers)$/;"	f
tls_ctx_restrict_ciphers	ssl_polarssl.c	/^tls_ctx_restrict_ciphers(struct tls_root_ctx *ctx, const char *ciphers)$/;"	f
tls_ctx_server_new	ssl_openssl.c	/^tls_ctx_server_new(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f
tls_ctx_server_new	ssl_polarssl.c	/^tls_ctx_server_new(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f
tls_ctx_set_options	ssl_openssl.c	/^tls_ctx_set_options (struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f
tls_ctx_set_options	ssl_polarssl.c	/^tls_ctx_set_options (struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f
tls_ctx_use_external_private_key	ssl_openssl.c	/^tls_ctx_use_external_private_key (struct tls_root_ctx *ctx,$/;"	f
tls_ctx_use_external_private_key	ssl_polarssl.c	/^tls_ctx_use_external_private_key (struct tls_root_ctx *ctx,$/;"	f
tls_ctx_use_pkcs11	pkcs11.c	/^tls_ctx_use_pkcs11 ($/;"	f
tls_deauthenticate	ssl_verify.c	/^tls_deauthenticate (struct tls_multi *multi)$/;"	f	file:
tls_exit	options.h	/^  bool tls_exit;$/;"	m	struct:options
tls_exit_signal	openvpn.h	/^  int tls_exit_signal;$/;"	m	struct:context_2
tls_export_cert	options.h	/^  const char *tls_export_cert;$/;"	m	struct:options
tls_free_lib	ssl_openssl.c	/^tls_free_lib()$/;"	f
tls_free_lib	ssl_polarssl.c	/^tls_free_lib()$/;"	f
tls_get_cipher_name_pair	ssl.c	/^tls_get_cipher_name_pair (const char * cipher_name, size_t len) {$/;"	f
tls_get_peer_info	ssl.h	/^tls_get_peer_info(const struct tls_multi *multi)$/;"	f
tls_handshake_error	ssl.c	/^static int tls_handshake_error;   \/* GLOBAL *\/$/;"	v	file:
tls_handshake_success	ssl.c	/^static int tls_handshake_success; \/* GLOBAL *\/$/;"	v	file:
tls_init_control_channel_frame_parameters	ssl.c	/^tls_init_control_channel_frame_parameters(const struct frame *data_channel_frame,$/;"	f	file:
tls_init_lib	ssl_openssl.c	/^tls_init_lib()$/;"	f
tls_init_lib	ssl_polarssl.c	/^tls_init_lib()$/;"	f
tls_initial_packet_received	ssl.h	/^tls_initial_packet_received (const struct tls_multi *multi)$/;"	f
tls_lock_cert_hash_set	ssl_verify.c	/^tls_lock_cert_hash_set (struct tls_multi *multi)$/;"	f
tls_lock_common_name	ssl_verify.c	/^tls_lock_common_name (struct tls_multi *multi)$/;"	f
tls_lock_username	ssl_verify.c	/^tls_lock_username (struct tls_multi *multi, const char *username)$/;"	f	file:
tls_multi	openvpn.h	/^  struct tls_multi *tls_multi;  \/**< TLS state structure for this VPN$/;"	m	struct:context_2	typeref:struct:context_2::tls_multi
tls_multi	ssl_common.h	/^struct tls_multi$/;"	s
tls_multi_free	ssl.c	/^tls_multi_free (struct tls_multi *multi, bool clear)$/;"	f
tls_multi_init	ssl.c	/^tls_multi_init (struct tls_options *tls_options)$/;"	f
tls_multi_init_finalize	ssl.c	/^tls_multi_init_finalize (struct tls_multi* multi, const struct frame* frame)$/;"	f
tls_multi_init_set_options	ssl.c	/^tls_multi_init_set_options (struct tls_multi* multi,$/;"	f
tls_multi_process	ssl.c	/^tls_multi_process (struct tls_multi *multi,$/;"	f
tls_options	ssl_common.h	/^struct tls_options$/;"	s
tls_packets_generated	ssl.c	/^static int tls_packets_generated; \/* GLOBAL *\/$/;"	v	file:
tls_packets_sent	ssl.c	/^static int tls_packets_sent;      \/* GLOBAL *\/$/;"	v	file:
tls_post_encrypt	ssl.c	/^tls_post_encrypt (struct tls_multi *multi, struct buffer *buf)$/;"	f
tls_pre_decrypt	ssl.c	/^tls_pre_decrypt (struct tls_multi *multi,$/;"	f
tls_pre_decrypt_lite	ssl.c	/^tls_pre_decrypt_lite (const struct tls_auth_standalone *tas,$/;"	f
tls_pre_encrypt	ssl.c	/^tls_pre_encrypt (struct tls_multi *multi,$/;"	f
tls_process	ssl.c	/^tls_process (struct tls_multi *multi,$/;"	f	file:
tls_rec_payload	ssl.c	/^tls_rec_payload (struct tls_multi *multi,$/;"	f
tls_root_ctx	ssl_openssl.h	/^struct tls_root_ctx {$/;"	s
tls_root_ctx	ssl_polarssl.h	/^struct tls_root_ctx {$/;"	s
tls_send_payload	ssl.c	/^tls_send_payload (struct tls_multi *multi,$/;"	f
tls_server	options.h	/^  bool tls_server;$/;"	m	struct:options
tls_session	ssl_common.h	/^struct tls_session$/;"	s
tls_session_free	ssl.c	/^tls_session_free (struct tls_session *session, bool clear)$/;"	f	file:
tls_session_init	ssl.c	/^tls_session_init (struct tls_multi *multi, struct tls_session *session)$/;"	f	file:
tls_session_set_self_referential_pointers	ssl.c	/^static inline void tls_session_set_self_referential_pointers (struct tls_session* session) {$/;"	f	file:
tls_set_single_session	ssl.h	/^tls_set_single_session (struct tls_multi *multi)$/;"	f
tls_test_auth_deferred_interval	ssl.h	/^tls_test_auth_deferred_interval (const struct tls_multi *multi)$/;"	f
tls_test_payload_len	ssl.h	/^tls_test_payload_len (const struct tls_multi *multi)$/;"	f
tls_timeout	options.h	/^  int tls_timeout;$/;"	m	struct:options
tls_translate_cipher_name	ssl_polarssl.c	/^tls_translate_cipher_name (const char * cipher_name) {$/;"	f	file:
tls_username	ssl_verify.c	/^tls_username (const struct tls_multi *multi, const bool null)$/;"	f
tls_verify	options.h	/^  const char *tls_verify;$/;"	m	struct:options
tls_version_max	ssl_openssl.c	/^tls_version_max(void)$/;"	f
tls_version_max	ssl_polarssl.c	/^tls_version_max(void)$/;"	f
tls_version_min_parse	ssl.c	/^tls_version_min_parse(const char *vstr, const char *extra)$/;"	f
tmp_dir	options.h	/^  const char *tmp_dir;$/;"	m	struct:options
tmp_dir	ssl_common.h	/^  const char *tmp_dir;$/;"	m	struct:tls_options
tmp_int	openvpn.h	/^  struct interval tmp_int;$/;"	m	struct:context_2	typeref:struct:context_2::interval
tmp_rsa_cb	ssl_openssl.c	/^tmp_rsa_cb (SSL * s, int is_export, int keylength)$/;"	f	file:
to_link	openvpn.h	/^  struct buffer to_link;$/;"	m	struct:context_2	typeref:struct:context_2::buffer
to_link_addr	openvpn.h	/^  struct link_socket_actual *to_link_addr;	\/* IP address of remote *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_actual
to_link_addr	ssl_common.h	/^  struct link_socket_actual to_link_addr;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::link_socket_actual
to_tun	openvpn.h	/^  struct buffer to_tun;$/;"	m	struct:context_2	typeref:struct:context_2::buffer
token_decode	base64.c	/^token_decode(const char *token)$/;"	f	file:
top	multi.h	/^  struct context top;           \/**< Storage structure for process-wide$/;"	m	struct:multi_context	typeref:struct:multi_context::context
top_build_prefix	Makefile	/^top_build_prefix = ..\/..\/$/;"	m
top_builddir	Makefile	/^top_builddir = ..\/..$/;"	m
top_srcdir	Makefile	/^top_srcdir = ..\/..$/;"	m
topology	options.h	/^  int topology; \/* one of the TOP_x values from proto.h *\/$/;"	m	struct:options
topology	tun.h	/^  int topology; \/* one of the TOP_x values *\/$/;"	m	struct:tuntap
tos	proto.h	/^  uint8_t    tos;$/;"	m	struct:openvpn_iphdr
tot_len	proto.h	/^  uint16_t   tot_len;$/;"	m	struct:openvpn_iphdr
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
transition_window	options.h	/^  int transition_window;$/;"	m	struct:options
transition_window	ssl_common.h	/^  int transition_window;$/;"	m	struct:tls_options
translate_cipher_name_from_openvpn	crypto_openssl.c	/^translate_cipher_name_from_openvpn (const char *cipher_name) {$/;"	f
translate_cipher_name_from_openvpn	crypto_polarssl.c	/^translate_cipher_name_from_openvpn (const char *cipher_name) {$/;"	f
translate_cipher_name_to_openvpn	crypto_openssl.c	/^translate_cipher_name_to_openvpn (const char *cipher_name) {$/;"	f
translate_cipher_name_to_openvpn	crypto_polarssl.c	/^translate_cipher_name_to_openvpn (const char *cipher_name) {$/;"	f
translate_mtu_discover_type_name	mtu.c	/^translate_mtu_discover_type_name (const char *name)$/;"	f
try_load_engine	crypto_openssl.c	/^try_load_engine (const char *engine)$/;"	f	file:
ttl	mtu.c	/^  uint32_t ttl;$/;"	m	struct:probehdr	file:
ttl	proto.h	/^  uint8_t    ttl;$/;"	m	struct:openvpn_iphdr
tun	mtcp.c	/^  unsigned int tun;$/;"	m	struct:ta_iow_flags	file:
tun_abort	init.c	/^tun_abort()$/;"	f
tun_adjust_frame_parameters	tun.h	/^tun_adjust_frame_parameters (struct frame* frame, int size)$/;"	f
tun_event_handle	tun.h	/^tun_event_handle (const struct tuntap *tt)$/;"	f
tun_finalize	tun.c	/^tun_finalize ($/;"	f
tun_ipv6	options.h	/^  bool tun_ipv6;                \/* Build tun dev that supports IPv6 *\/$/;"	m	struct:options
tun_mtu	options.h	/^  int tun_mtu;           \/* MTU of tun device *\/$/;"	m	struct:connection_entry
tun_mtu_defined	options.h	/^  bool tun_mtu_defined;  \/* true if user overriding parm with command line option *\/$/;"	m	struct:connection_entry
tun_mtu_extra	options.h	/^  int tun_mtu_extra;$/;"	m	struct:connection_entry
tun_mtu_extra_defined	options.h	/^  bool tun_mtu_extra_defined;$/;"	m	struct:connection_entry
tun_read_bytes	openvpn.h	/^  counter_type tun_read_bytes;$/;"	m	struct:context_2
tun_read_queue	tun.c	/^tun_read_queue (struct tuntap *tt, int maxsize)$/;"	f
tun_rwflags	mtcp.h	/^  unsigned int tun_rwflags;$/;"	m	struct:multi_tcp
tun_set	tun.h	/^tun_set (struct tuntap *tt,$/;"	f
tun_show_debug	tun.c	/^tun_show_debug (struct tuntap *tt)$/;"	f
tun_standby	tun.c	/^tun_standby (struct tuntap *tt)$/;"	f
tun_standby	tun.h	/^tun_standby (struct tuntap *tt)$/;"	f
tun_standby_init	tun.c	/^tun_standby_init (struct tuntap *tt)$/;"	f
tun_standby_init	tun.h	/^tun_standby_init (struct tuntap *tt)$/;"	f
tun_stat	tun.c	/^tun_stat (const struct tuntap *tt, unsigned int rwflags, struct gc_arena *gc)$/;"	f
tun_write_bytes	openvpn.h	/^  counter_type tun_write_bytes;$/;"	m	struct:context_2
tun_write_queue	tun.c	/^tun_write_queue (struct tuntap *tt, struct buffer *buf)$/;"	f
tun_write_win32	tun.h	/^tun_write_win32 (struct tuntap *tt, struct buffer *buf)$/;"	f
tuncfg	tun.c	/^tuncfg (const char *dev, const char *dev_type, const char *dev_node, int persist_mode, const char *username, const char *groupname, const struct tuntap_options *options)$/;"	f
tunnel_point_to_point	openvpn.c	/^tunnel_point_to_point (struct context *c)$/;"	f	file:
tunnel_server	multi.c	/^tunnel_server (struct context *top)$/;"	f
tunnel_server_tcp	mtcp.c	/^tunnel_server_tcp (struct context *top)$/;"	f
tunnel_server_udp	mudp.c	/^tunnel_server_udp (struct context *top)$/;"	f
tunnel_server_udp_single_threaded	mudp.c	/^tunnel_server_udp_single_threaded (struct context *top)$/;"	f	file:
tuntap	openvpn.h	/^  struct tuntap *tuntap;        \/**< Tun\/tap virtual network interface. *\/$/;"	m	struct:context_1	typeref:struct:context_1::tuntap
tuntap	tun.h	/^struct tuntap$/;"	s
tuntap_defined	tun.h	/^tuntap_defined (const struct tuntap *tt)$/;"	f
tuntap_options	options.h	/^  struct tuntap_options tuntap_options;$/;"	m	struct:options	typeref:struct:options::tuntap_options
tuntap_options	options.h	/^  struct tuntap_options tuntap_options;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::tuntap_options
tuntap_options	tun.h	/^struct tuntap_options {$/;"	s
tuntap_options_defined	options.h	/^  bool tuntap_options_defined;$/;"	m	struct:options_pre_pull
tuntap_owned	openvpn.h	/^  bool tuntap_owned;            \/**< Whether the tun\/tap interface should$/;"	m	struct:context_1
tuntap_stop	tun.h	/^tuntap_stop (int status)$/;"	f
tv	mtu.c	/^  struct timeval tv;$/;"	m	struct:probehdr	typeref:struct:probehdr::timeval	file:
tv	schedule.h	/^  struct timeval tv;             \/* wakeup time *\/$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::timeval
tv_add	otime.h	/^tv_add (struct timeval *dest, const struct timeval *src)$/;"	f
tv_clear	otime.h	/^tv_clear (struct timeval *tv)$/;"	f
tv_defined	otime.h	/^tv_defined (const struct timeval *tv)$/;"	f
tv_delta	otime.h	/^tv_delta (struct timeval *dest, const struct timeval *t1, const struct timeval *t2)$/;"	f
tv_eq	otime.h	/^tv_eq (const struct timeval *t1, const struct timeval *t2)$/;"	f
tv_ge	otime.h	/^tv_ge (const struct timeval *t1, const struct timeval *t2)$/;"	f
tv_gt	otime.h	/^tv_gt (const struct timeval *t1, const struct timeval *t2)$/;"	f
tv_le	otime.h	/^tv_le (const struct timeval *t1, const struct timeval *t2)$/;"	f
tv_lt	otime.h	/^tv_lt (const struct timeval *t1, const struct timeval *t2)$/;"	f
tv_randomize	schedule.c	/^tv_randomize (struct timeval *tv)$/;"	f
tv_string	otime.c	/^tv_string (const struct timeval *tv, struct gc_arena *gc)$/;"	f
tv_string_abs	otime.c	/^tv_string_abs (const struct timeval *tv, struct gc_arena *gc)$/;"	f
tv_subtract	otime.h	/^tv_subtract (const struct timeval *tv1, const struct timeval *tv2, const unsigned int max_seconds)$/;"	f
tv_to_ms_timeout	event.c	/^tv_to_ms_timeout (const struct timeval *tv)$/;"	f	file:
tv_within_sigma	otime.h	/^tv_within_sigma (const struct timeval *t1, const struct timeval *t2, unsigned int sigma)$/;"	f
txqueuelen	tun.h	/^  int txqueuelen;$/;"	m	struct:tuntap
txqueuelen	tun.h	/^  int txqueuelen;$/;"	m	struct:tuntap_options
type	clinat.h	/^  int type;$/;"	m	struct:client_nat_entry
type	mroute.h	/^  uint8_t type;     \/* MR_ADDR\/MR_WITH flags *\/$/;"	m	struct:mroute_addr
type	options.c	/^  int type;$/;"	m	struct:in_src	file:
type	pool.h	/^  int type;$/;"	m	struct:ifconfig_pool
type	tun.h	/^  int type; \/* DEV_TYPE_x as defined in proto.h *\/$/;"	m	struct:tuntap
u	manage.h	/^  union log_entry_union u;$/;"	m	struct:log_entry	typeref:union:log_entry::log_entry_union
u	options.c	/^  } u;$/;"	m	struct:in_src	typeref:union:in_src::__anon3	file:
u	proto.h	/^  } u;$/;"	m	struct:ip_tcp_udp_hdr	typeref:union:ip_tcp_udp_hdr::__anon1
udp	dhcp.h	/^  struct openvpn_udphdr udp;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::openvpn_udphdr
udp	proto.h	/^    struct openvpn_udphdr udp;$/;"	m	union:ip_tcp_udp_hdr::__anon1	typeref:struct:ip_tcp_udp_hdr::__anon1::openvpn_udphdr
udp_checksum	dhcp.c	/^udp_checksum (const uint8_t *buf,$/;"	f	file:
uid_gid_set	openvpn.h	/^  bool uid_gid_set;$/;"	m	struct:context_0
uid_gid_specified	openvpn.h	/^  bool uid_gid_specified;$/;"	m	struct:context_0
undo_redirect_default_route_to_vpn	route.c	/^undo_redirect_default_route_to_vpn (struct route_list *rl, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	file:
ungenerate_prefix	multi.c	/^ungenerate_prefix (struct multi_instance *mi)$/;"	f
unicodize	ntlm.c	/^unicodize (char *dst, const char *src)$/;"	f	file:
uninit_management_callback	init.c	/^uninit_management_callback (void)$/;"	f
uninit_management_callback_multi	multi.c	/^uninit_management_callback_multi (struct multi_context *m)$/;"	f
uninit_options	options.c	/^uninit_options (struct options *o)$/;"	f
uninit_proxy	init.c	/^uninit_proxy (struct context *c)$/;"	f	file:
uninit_proxy_dowork	init.c	/^uninit_proxy_dowork (struct context *c)$/;"	f	file:
uninit_static	init.c	/^uninit_static (void)$/;"	f
uninit_win32	win32.c	/^uninit_win32 (void)$/;"	f
unit	packet_id.h	/^  int unit;$/;"	m	struct:packet_id_rec
unix_socket_get_peer_uid_gid	socket.c	/^unix_socket_get_peer_uid_gid (const socket_descriptor_t sd, int *uid, int *gid)$/;"	f
unlikely	syshead.h	34;"	d
unlikely	syshead.h	37;"	d
unprintable_char_fmt	crypto.c	/^static const char unprintable_char_fmt[] =$/;"	v	file:
untrusted_addr	ssl_common.h	/^  struct link_socket_actual untrusted_addr;$/;"	m	struct:tls_session	typeref:struct:tls_session::link_socket_actual
unused	mroute.h	/^  uint8_t unused;$/;"	m	struct:mroute_addr
up	gremlin.c	/^static bool up;          \/* GLOBAL *\/$/;"	v	file:
up	manage.h	/^  struct user_pass up;$/;"	m	struct:man_settings	typeref:struct:man_settings::user_pass
up	proxy.h	/^  struct user_pass up;$/;"	m	struct:http_proxy_info	typeref:struct:http_proxy_info::user_pass
up_delay	options.h	/^  bool up_delay;$/;"	m	struct:options
up_high	gremlin.c	/^static const int up_high[] = { 600, 60, 10 };$/;"	v	file:
up_low	gremlin.c	/^static const int up_low[] =  {  60, 10,  5 };$/;"	v	file:
up_query	manage.h	/^  struct user_pass up_query;$/;"	m	struct:man_connection	typeref:struct:man_connection::user_pass
up_query_mode	manage.h	/^  int up_query_mode;$/;"	m	struct:man_connection
up_query_type	manage.h	/^  const char *up_query_type;$/;"	m	struct:man_connection
up_restart	options.h	/^  bool up_restart;$/;"	m	struct:options
up_script	options.h	/^  const char *up_script;$/;"	m	struct:options
update_mstat_n_clients	multi.c	/^update_mstat_n_clients(const int n_clients)$/;"	f	file:
update_now	otime.c	/^update_now (const time_t system_time)$/;"	f
update_now_usec	otime.c	/^update_now_usec (struct timeval *tv)$/;"	f
update_options_ce_post	init.c	/^update_options_ce_post (struct options *options)$/;"	f	file:
update_remote	socket.c	/^update_remote (const char* host,$/;"	f	file:
update_sofar	perf.c	/^update_sofar (struct perf *p)$/;"	f	file:
update_time	otime.h	/^update_time (void)$/;"	f
update_timeout_random_component	openvpn.h	/^  time_t update_timeout_random_component;$/;"	m	struct:context_2
upper	sig.c	/^  const char *upper;$/;"	m	struct:signame	file:
urg_ptr	proto.h	/^  uint16_t      urg_ptr;$/;"	m	struct:openvpn_tcphdr
usage	options.c	/^usage (void)$/;"	f	file:
usage_message	options.c	/^static const char usage_message[] =$/;"	v	file:
usage_small	options.c	/^usage_small (void)$/;"	f
usage_version	options.c	/^usage_version (void)$/;"	f	file:
use_iv	options.h	/^  bool use_iv;$/;"	m	struct:options
use_prediction_resistance	options.h	/^  bool use_prediction_resistance;$/;"	m	struct:options
use_syslog	error.c	/^static bool use_syslog;     \/* GLOBAL *\/$/;"	v	file:
usec_timer	interval.h	/^struct usec_timer {$/;"	s
usec_timer_end	interval.h	/^usec_timer_end (struct usec_timer *obj)$/;"	f
usec_timer_interval	interval.h	/^usec_timer_interval (struct usec_timer *obj)$/;"	f
usec_timer_interval_defined	interval.h	/^usec_timer_interval_defined (struct usec_timer *obj)$/;"	f
usec_timer_start	interval.h	/^usec_timer_start (struct usec_timer *obj)$/;"	f
user	misc.h	/^  const char *user;$/;"	m	struct:auth_challenge_info
user_agent	proxy.h	/^  const char *user_agent;$/;"	m	struct:http_proxy_options
user_pass	misc.h	/^struct user_pass$/;"	s
user_script_used	options.h	/^  bool user_script_used;$/;"	m	struct:options
username	misc.h	/^  char username[USER_PASS_LEN];$/;"	m	struct:user_pass
username	options.h	/^  const char *username;$/;"	m	struct:options
username	platform.h	/^  const char *username;$/;"	m	struct:platform_state_user
username_password_as_base64	proxy.c	/^username_password_as_base64 (const struct http_proxy_info *p,$/;"	f	file:
utun_open_helper	tun.c	/^int utun_open_helper (struct ctl_info ctlInfo, int utunnum)$/;"	f	file:
vaddr_handle	multi.h	/^  ifconfig_pool_handle vaddr_handle;$/;"	m	struct:multi_instance
validate_peer_info_line	manage.c	/^validate_peer_info_line(const char *line)$/;"	f	file:
valign4	buffer.c	/^valign4 (const struct buffer *buf, const char *file, const int line)$/;"	f
value	list.h	/^  void *value;$/;"	m	struct:hash_element
value	sig.c	/^  int value;$/;"	m	struct:signame	file:
verbosity	options.h	/^  int verbosity;$/;"	m	struct:options
verified	ssl_common.h	/^  bool verified;                \/* true if peer certificate was verified against CA *\/$/;"	m	struct:tls_session
verify_255_255_255_252	tun.c	/^verify_255_255_255_252 (in_addr_t local, in_addr_t remote)$/;"	f
verify_align_4	buffer.h	768;"	d
verify_align_4	buffer.h	770;"	d
verify_callback	ssl_verify_openssl.c	/^verify_callback (int preverify_ok, X509_STORE_CTX * ctx)$/;"	f
verify_callback	ssl_verify_polarssl.c	/^verify_callback (void *session_obj, x509_cert *cert, int cert_depth,$/;"	f
verify_cert	ssl_verify.c	/^verify_cert(struct tls_session *session, openvpn_x509_cert_t *cert, int cert_depth)$/;"	f
verify_cert_call_command	ssl_verify.c	/^verify_cert_call_command(const char *verify_command, struct env_set *es,$/;"	f	file:
verify_cert_call_plugin	ssl_verify.c	/^verify_cert_call_plugin(const struct plugin_list *plugins, struct env_set *es,$/;"	f	file:
verify_cert_export_cert	ssl_verify.c	/^verify_cert_export_cert(openvpn_x509_cert_t *peercert, const char *tmp_dir, struct gc_arena *gc)$/;"	f	file:
verify_cert_set_env	ssl_verify.c	/^verify_cert_set_env(struct env_set *es, openvpn_x509_cert_t *peer_cert, int cert_depth,$/;"	f	file:
verify_check_crl_dir	ssl_verify.c	/^verify_check_crl_dir(const char *crl_dir, openvpn_x509_cert_t *cert)$/;"	f	file:
verify_command	ssl_common.h	/^  const char *verify_command;$/;"	m	struct:tls_options
verify_common_subnet	helper.c	/^verify_common_subnet (const char *opt, const in_addr_t a, const in_addr_t b, const in_addr_t subnet)$/;"	f	file:
verify_export_cert	ssl_common.h	/^  const char *verify_export_cert;$/;"	m	struct:tls_options
verify_final_auth_checks	ssl_verify.c	/^verify_final_auth_checks(struct tls_multi *multi, struct tls_session *session)$/;"	f
verify_fix_key2	crypto.c	/^verify_fix_key2 (struct key2 *key2, const struct key_type *kt, const char *shared_secret_file)$/;"	f
verify_hash	options.h	/^  uint8_t *verify_hash;$/;"	m	struct:options
verify_hash	ssl_common.h	/^  uint8_t *verify_hash;$/;"	m	struct:tls_options
verify_maxlevel	ssl_common.h	/^  int verify_maxlevel;$/;"	m	struct:tls_session
verify_peer_cert	ssl_verify.c	/^verify_peer_cert(const struct tls_options *opt, openvpn_x509_cert_t *peer_cert,$/;"	f	file:
verify_permission	options.c	/^verify_permission (const char *name,$/;"	f	file:
verify_user_pass	ssl_verify.c	/^verify_user_pass(struct user_pass *up, struct tls_multi *multi,$/;"	f
verify_user_pass_enabled	ssl_verify.h	/^static inline bool verify_user_pass_enabled(struct tls_session *session)$/;"	f
verify_user_pass_management	ssl_verify.c	/^verify_user_pass_management (struct tls_session *session, const struct user_pass *up, const char *raw_username)$/;"	f	file:
verify_user_pass_plugin	ssl_verify.c	/^verify_user_pass_plugin (struct tls_session *session, const struct user_pass *up, const char *raw_username)$/;"	f	file:
verify_user_pass_script	ssl_verify.c	/^verify_user_pass_script (struct tls_session *session, const struct user_pass *up)$/;"	f	file:
verify_x509_name	options.h	/^  const char *verify_x509_name;$/;"	m	struct:options
verify_x509_name	ssl_common.h	/^  const char *verify_x509_name;$/;"	m	struct:tls_options
verify_x509_type	options.h	/^  int verify_x509_type;$/;"	m	struct:options
verify_x509_type	ssl_common.h	/^  int verify_x509_type;$/;"	m	struct:tls_options
version_len	proto.h	/^  uint8_t    version_len;$/;"	m	struct:openvpn_iphdr
version_prio	proto.h	/^        uint8_t		version_prio;$/;"	m	struct:openvpn_ipv6hdr
vhash	multi.h	/^  struct hash *vhash;           \/**< VPN tunnel instances indexed by$/;"	m	struct:multi_context	typeref:struct:multi_context::hash
virtual_hash_size	options.h	/^  int virtual_hash_size;$/;"	m	struct:options
virtual_output	status.h	/^struct virtual_output {$/;"	s
virtual_output_callback_func	manage.c	/^virtual_output_callback_func (void *arg, const unsigned int flags, const char *str)$/;"	f	file:
virtual_output_print	status.h	/^virtual_output_print (const struct virtual_output *vo, const unsigned int flags, const char *str)$/;"	f
void_ptr_compare_function	list.c	/^void_ptr_compare_function (const void *key1, const void *key2)$/;"	f
void_ptr_hash_function	list.c	/^void_ptr_hash_function (const void *key, uint32_t iv)$/;"	f
vout	manage.h	/^  struct virtual_output vout;$/;"	m	struct:man_persist	typeref:struct:man_persist::virtual_output
vout	status.h	/^  const struct virtual_output *vout;$/;"	m	struct:status_output	typeref:struct:status_output::virtual_output
wait	event.h	/^  int  (*wait)(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen);$/;"	m	struct:event_set_functions
wait_for_connect	openvpn.h	/^  struct event_timeout wait_for_connect;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout
wait_signal	event.h	/^wait_signal (struct event_set *es, void *arg)$/;"	f
wait_status_string	forward.c	/^wait_status_string (struct context *c, struct gc_arena *gc)$/;"	f
wakeup	fragment.h	/^  struct event_timeout wakeup;  \/**< Timeout structure used by the main$/;"	m	struct:fragment_master	typeref:struct:fragment_master::event_timeout
wakeup	multi.h	/^  struct timeval wakeup;       \/* absolute time *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::timeval
wakeup	shaper.h	/^  struct timeval wakeup;$/;"	m	struct:shaper	typeref:struct:shaper::timeval
warn_if_group_others_accessible	misc.c	/^warn_if_group_others_accessible (const char* filename)$/;"	f
warn_on_use_of_common_subnets	tun.c	/^warn_on_use_of_common_subnets (void)$/;"	f
we_append_event	event.c	/^we_append_event (struct we_set *wes, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
we_ctl	event.c	/^we_ctl (struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
we_del	event.c	/^we_del (struct event_set *es, event_t event)$/;"	f	file:
we_del_event	event.c	/^we_del_event (struct we_set *wes, event_t event)$/;"	f	file:
we_del_index	event.c	/^we_del_index (struct we_set *wes, int index)$/;"	f	file:
we_free	event.c	/^we_free (struct event_set *es)$/;"	f	file:
we_get_rw_indices	event.c	/^we_get_rw_indices (struct we_set *wes, event_t event, int *ri, int *wi)$/;"	f	file:
we_init	event.c	/^we_init (int *maxevents, unsigned int flags)$/;"	f	file:
we_reset	event.c	/^we_reset (struct event_set *es)$/;"	f	file:
we_set	event.c	/^struct we_set$/;"	s	file:
we_set_event	event.c	/^we_set_event (struct we_set *wes, int i, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:
we_wait	event.c	/^we_wait (struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:
wide_cmd_line	win32.c	/^wide_cmd_line (const struct argv *a, struct gc_arena *gc)$/;"	f	file:
wide_string	win32.c	/^wide_string (const char* utf8, struct gc_arena *gc)$/;"	f
win32_keyboard_get	win32.c	/^win32_keyboard_get (struct win32_signal *ws)$/;"	f	file:
win32_pause	win32.c	/^win32_pause (struct win32_signal *ws)$/;"	f
win32_service_interrupt	win32.c	/^win32_service_interrupt (struct win32_signal *ws)$/;"	f
win32_signal	win32.c	/^struct win32_signal win32_signal; \/* GLOBAL *\/$/;"	v	typeref:struct:win32_signal
win32_signal	win32.h	/^struct win32_signal {$/;"	s
win32_signal_clear	win32.c	/^win32_signal_clear (struct win32_signal *ws)$/;"	f
win32_signal_close	win32.c	/^win32_signal_close (struct win32_signal *ws)$/;"	f
win32_signal_get	win32.c	/^win32_signal_get (struct win32_signal *ws)$/;"	f
win32_signal_open	win32.c	/^win32_signal_open (struct win32_signal *ws,$/;"	f
win_get_tempdir	win32.c	/^win_get_tempdir()$/;"	f
win_safe_filename	win32.c	/^win_safe_filename (const char *fn)$/;"	f
win_sys_path	win32.c	/^static char *win_sys_path = NULL; \/* GLOBAL *\/$/;"	v	file:
window	proto.h	/^  uint16_t      window;$/;"	m	struct:openvpn_tcphdr
window_title	win32.c	/^struct window_title window_title; \/* GLOBAL*\/$/;"	v	typeref:struct:window_title
window_title	win32.h	/^struct window_title$/;"	s
window_title_clear	win32.c	/^window_title_clear (struct window_title *wt)$/;"	f
window_title_generate	win32.c	/^window_title_generate (const char *title)$/;"	f
window_title_restore	win32.c	/^window_title_restore (const struct window_title *wt)$/;"	f
window_title_save	win32.c	/^window_title_save (struct window_title *wt)$/;"	f
windows_route_find_if_index	route.c	/^windows_route_find_if_index (const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f	file:
wins	tun.h	/^  in_addr_t wins[N_DHCP_ADDR];$/;"	m	struct:tuntap_options
wins_len	tun.h	/^  int wins_len;$/;"	m	struct:tuntap_options
wmain	openvpn.c	/^wmain (int argc, wchar_t *wargv[]) {$/;"	f
wmem	lzo.h	/^  lzo_voidp wmem;$/;"	m	struct:lzo_compress_workspace
wmem_size	lzo.h	/^  int wmem_size;$/;"	m	struct:lzo_compress_workspace
word	list.c	/^  const char *word;$/;"	m	struct:word	file:
word	list.c	/^struct word$/;"	s	file:
word_compare_function	list.c	/^word_compare_function (const void *key1, const void *key2)$/;"	f	file:
word_hash_function	list.c	/^word_hash_function (const void *key, uint32_t iv)$/;"	f	file:
write	win32.h	/^  HANDLE write;$/;"	m	struct:rw_handle
write_control_auth	ssl.c	/^write_control_auth (struct tls_session *session,$/;"	f	file:
write_dhcp_str	tun.c	/^write_dhcp_str (struct buffer *buf, const int type, const char *str, bool *error)$/;"	f	file:
write_dhcp_u32_array	tun.c	/^write_dhcp_u32_array (struct buffer *buf, const int type, const uint32_t *data, const unsigned int len, bool *error)$/;"	f	file:
write_dhcp_u8	tun.c	/^write_dhcp_u8 (struct buffer *buf, const int type, const int data, bool *error)$/;"	f	file:
write_empty_string	ssl.c	/^write_empty_string (struct buffer *buf)$/;"	f	file:
write_key	crypto.c	/^write_key (const struct key *key, const struct key_type *kt,$/;"	f
write_key_file	crypto.c	/^write_key_file (const int nkeys, const char *filename)$/;"	f
write_peer_info_file	manage.h	/^  char *write_peer_info_file;$/;"	m	struct:man_settings
write_pid	misc.c	/^write_pid (const struct pid_state *state)$/;"	f
write_string	ssl.c	/^write_string (struct buffer *buf, const char *str, const int maxlen)$/;"	f	file:
write_tun	tun.c	/^write_tun (struct tuntap* tt, uint8_t *buf, int len)$/;"	f
write_tun	tun.c	/^write_tun(struct tuntap *tt, uint8_t *buf, int len)$/;"	f
write_tun_buffered	tun.h	/^write_tun_buffered (struct tuntap *tt, struct buffer *buf)$/;"	f
write_tun_header	tun.c	/^write_tun_header (struct tuntap* tt, uint8_t *buf, int len)$/;"	f
writefds	event.c	/^  fd_set writefds;$/;"	m	struct:se_set	file:
writepid	options.h	/^  const char *writepid;$/;"	m	struct:options
writes	socket.h	/^  struct overlapped_io writes;$/;"	m	struct:link_socket	typeref:struct:link_socket::overlapped_io
writes	tun.h	/^  struct overlapped_io writes;$/;"	m	struct:tuntap	typeref:struct:tuntap::overlapped_io
wsa_state	win32.c	/^static struct WSAData wsa_state; \/* GLOBAL *\/$/;"	v	typeref:struct:WSAData	file:
x509_get_sha1_hash	ssl_verify_openssl.c	/^x509_get_sha1_hash (X509 *cert, struct gc_arena *gc)$/;"	f
x509_get_sha1_hash	ssl_verify_polarssl.c	/^x509_get_sha1_hash (x509_cert *cert, struct gc_arena *gc)$/;"	f
x509_get_subject	ssl_verify_openssl.c	/^x509_get_subject (X509 *cert, struct gc_arena *gc)$/;"	f
x509_get_subject	ssl_verify_polarssl.c	/^x509_get_subject(x509_cert *cert, struct gc_arena *gc)$/;"	f
x509_get_username	ssl_verify_openssl.c	/^x509_get_username (char *common_name, int cn_len,$/;"	f
x509_get_username	ssl_verify_polarssl.c	/^x509_get_username (char *cn, int cn_len,$/;"	f
x509_setenv	ssl_verify_openssl.c	/^x509_setenv (struct env_set *es, int cert_depth, openvpn_x509_cert_t *peer_cert)$/;"	f
x509_setenv	ssl_verify_polarssl.c	/^x509_setenv (struct env_set *es, int cert_depth, openvpn_x509_cert_t *cert)$/;"	f
x509_setenv_track	ssl_verify_openssl.c	/^x509_setenv_track (const struct x509_track *xt, struct env_set *es, const int depth, X509 *x509)$/;"	f
x509_track	options.h	/^  const struct x509_track *x509_track;$/;"	m	struct:options	typeref:struct:options::x509_track
x509_track	ssl_common.h	/^  const struct x509_track *x509_track;$/;"	m	struct:tls_options	typeref:struct:tls_options::x509_track
x509_track	ssl_verify.h	/^struct x509_track$/;"	s
x509_track_add	ssl_verify_openssl.c	/^x509_track_add (const struct x509_track **ll_head, const char *name, int msglevel, struct gc_arena *gc)$/;"	f
x509_username_field	options.h	/^  char *x509_username_field;$/;"	m	struct:options
x509_username_field	ssl_common.h	/^  char *x509_username_field;$/;"	m	struct:tls_options
x509_verify_cert_eku	ssl_verify_openssl.c	/^x509_verify_cert_eku (X509 *x509, const char * const expected_oid)$/;"	f
x509_verify_cert_eku	ssl_verify_polarssl.c	/^x509_verify_cert_eku (x509_cert *cert, const char * const expected_oid)$/;"	f
x509_verify_cert_ku	ssl_verify_openssl.c	/^x509_verify_cert_ku (X509 *x509, const unsigned * const expected_ku,$/;"	f
x509_verify_cert_ku	ssl_verify_polarssl.c	/^x509_verify_cert_ku (x509_cert *cert, const unsigned * const expected_ku,$/;"	f
x509_verify_crl	ssl_verify_openssl.c	/^x509_verify_crl(const char *crl_file, X509 *peer_cert, const char *subject)$/;"	f
x509_verify_crl	ssl_verify_polarssl.c	/^x509_verify_crl(const char *crl_file, x509_cert *cert, const char *subject)$/;"	f
x509_verify_ns_cert_type	ssl_verify_openssl.c	/^x509_verify_ns_cert_type(const openvpn_x509_cert_t *peer_cert, const int usage)$/;"	f
x509_verify_ns_cert_type	ssl_verify_polarssl.c	/^x509_verify_ns_cert_type(const x509_cert *cert, const int usage)$/;"	f
x509_write_pem	ssl_verify_openssl.c	/^x509_write_pem(FILE *peercert_file, X509 *peercert)$/;"	f
x509_write_pem	ssl_verify_polarssl.c	/^x509_write_pem(FILE *peercert_file, x509_cert *peercert)$/;"	f
x_check_status	error.c	/^x_check_status (int status,$/;"	f
x_cs_err_delay_ms	error.c	/^unsigned int x_cs_err_delay_ms;  \/* GLOBAL *\/$/;"	v
x_cs_info_level	error.c	/^unsigned int x_cs_info_level;    \/* GLOBAL *\/$/;"	v
x_cs_verbose_level	error.c	/^unsigned int x_cs_verbose_level; \/* GLOBAL *\/$/;"	v
x_debug_level	error.c	/^unsigned int x_debug_level; \/* GLOBAL *\/$/;"	v
x_gc_free	buffer.c	/^x_gc_free (struct gc_arena *a)$/;"	f
x_msg	error.c	/^void x_msg (const unsigned int flags, const char *format, ...)$/;"	f
x_msg_line_num	error.c	/^int x_msg_line_num; \/* GLOBAL *\/$/;"	v
x_msg_prefix	error.c	/^const char *x_msg_prefix; \/* GLOBAL *\/$/;"	v
x_msg_va	error.c	/^void x_msg_va (const unsigned int flags, const char *format, va_list arglist)$/;"	f
x_msg_virtual_output	error.c	/^const struct virtual_output *x_msg_virtual_output; \/* GLOBAL *\/$/;"	v	typeref:struct:virtual_output
x_session_id_zero	session_id.c	/^const struct session_id x_session_id_zero;$/;"	v	typeref:struct:session_id
xid	dhcp.h	/^  uint32_t xid;        \/* transaction ID, chosen by client *\/$/;"	m	struct:dhcp
xmit_hold	ssl_common.h	/^  bool xmit_hold;$/;"	m	struct:tls_options
yiaddr	dhcp.h	/^  uint32_t yiaddr;     \/* 'your' IP address -- server's response to client *\/$/;"	m	struct:dhcp
z	schedule.c	/^static struct status z;$/;"	v	typeref:struct:status	file:
